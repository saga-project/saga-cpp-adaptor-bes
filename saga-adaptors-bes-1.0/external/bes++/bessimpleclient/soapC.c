/* soapC.c
   Generated by gSOAP 2.7.10 from bes-factory.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.10 2010-03-26 09:24:04 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_jsdl__CreationFlagEnumeration:
		return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_jsdl__FileSystemTypeEnumeration:
		return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration:
		return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration:
		return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_wsa__FaultCodesType:
		return soap_in_wsa__FaultCodesType(soap, NULL, NULL, "wsa:FaultCodesType");
	case SOAP_TYPE_wsa__RelationshipType:
		return soap_in_wsa__RelationshipType(soap, NULL, NULL, "wsa:RelationshipType");
	case SOAP_TYPE_bes__ActivityStateEnumeration:
		return soap_in_bes__ActivityStateEnumeration(soap, NULL, NULL, "bes:ActivityStateEnumeration");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE_posix__POSIXApplication_USCOREType:
		return soap_in_posix__POSIXApplication_USCOREType(soap, NULL, NULL, "posix:POSIXApplication_Type");
	case SOAP_TYPE_posix__GroupName_USCOREType:
		return soap_in_posix__GroupName_USCOREType(soap, NULL, NULL, "posix:GroupName_Type");
	case SOAP_TYPE_posix__UserName_USCOREType:
		return soap_in_posix__UserName_USCOREType(soap, NULL, NULL, "posix:UserName_Type");
	case SOAP_TYPE_posix__Limits_USCOREType:
		return soap_in_posix__Limits_USCOREType(soap, NULL, NULL, "posix:Limits_Type");
	case SOAP_TYPE_posix__DirectoryName_USCOREType:
		return soap_in_posix__DirectoryName_USCOREType(soap, NULL, NULL, "posix:DirectoryName_Type");
	case SOAP_TYPE_posix__FileName_USCOREType:
		return soap_in_posix__FileName_USCOREType(soap, NULL, NULL, "posix:FileName_Type");
	case SOAP_TYPE_posix__Argument_USCOREType:
		return soap_in_posix__Argument_USCOREType(soap, NULL, NULL, "posix:Argument_Type");
	case SOAP_TYPE_posix__Environment_USCOREType:
		return soap_in_posix__Environment_USCOREType(soap, NULL, NULL, "posix:Environment_Type");
	case SOAP_TYPE_app__HPCProfileApplication_USCOREType:
		return soap_in_app__HPCProfileApplication_USCOREType(soap, NULL, NULL, "app:HPCProfileApplication_Type");
	case SOAP_TYPE_app__UserName_USCOREType:
		return soap_in_app__UserName_USCOREType(soap, NULL, NULL, "app:UserName_Type");
	case SOAP_TYPE_app__DirectoryName_USCOREType:
		return soap_in_app__DirectoryName_USCOREType(soap, NULL, NULL, "app:DirectoryName_Type");
	case SOAP_TYPE_app__FileName_USCOREType:
		return soap_in_app__FileName_USCOREType(soap, NULL, NULL, "app:FileName_Type");
	case SOAP_TYPE_app__Argument_USCOREType:
		return soap_in_app__Argument_USCOREType(soap, NULL, NULL, "app:Argument_Type");
	case SOAP_TYPE_app__Environment_USCOREType:
		return soap_in_app__Environment_USCOREType(soap, NULL, NULL, "app:Environment_Type");
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_jsdl__Application_USCOREType:
		return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_jsdl__Range_USCOREType:
		return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_wsa__ProblemActionType:
		return soap_in_wsa__ProblemActionType(soap, NULL, NULL, "wsa:ProblemActionType");
	case SOAP_TYPE_wsa__AttributedQNameType:
		return soap_in_wsa__AttributedQNameType(soap, NULL, NULL, "wsa:AttributedQNameType");
	case SOAP_TYPE_wsa__AttributedUnsignedLongType:
		return soap_in_wsa__AttributedUnsignedLongType(soap, NULL, NULL, "wsa:AttributedUnsignedLongType");
	case SOAP_TYPE_wsa__AttributedURIType:
		return soap_in_wsa__AttributedURIType(soap, NULL, NULL, "wsa:AttributedURIType");
	case SOAP_TYPE_wsa__RelatesToType:
		return soap_in_wsa__RelatesToType(soap, NULL, NULL, "wsa:RelatesToType");
	case SOAP_TYPE_wsa__MetadataType:
		return soap_in_wsa__MetadataType(soap, NULL, NULL, "wsa:MetadataType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_in_wsa__ReferenceParametersType(soap, NULL, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, "wsa:EndpointReferenceType");
	case SOAP_TYPE_bes__TerminateActivityResponseType:
		return soap_in_bes__TerminateActivityResponseType(soap, NULL, NULL, "bes:TerminateActivityResponseType");
	case SOAP_TYPE_bes__GetActivityDocumentResponseType:
		return soap_in_bes__GetActivityDocumentResponseType(soap, NULL, NULL, "bes:GetActivityDocumentResponseType");
	case SOAP_TYPE_bes__GetActivityStatusResponseType:
		return soap_in_bes__GetActivityStatusResponseType(soap, NULL, NULL, "bes:GetActivityStatusResponseType");
	case SOAP_TYPE_bes__ActivityStatusType:
		return soap_in_bes__ActivityStatusType(soap, NULL, NULL, "bes:ActivityStatusType");
	case SOAP_TYPE_bes__ActivityDocumentType:
		return soap_in_bes__ActivityDocumentType(soap, NULL, NULL, "bes:ActivityDocumentType");
	case SOAP_TYPE_bes__FactoryResourceAttributesDocumentType:
		return soap_in_bes__FactoryResourceAttributesDocumentType(soap, NULL, NULL, "bes:FactoryResourceAttributesDocumentType");
	case SOAP_TYPE_bes__BasicResourceAttributesDocumentType:
		return soap_in_bes__BasicResourceAttributesDocumentType(soap, NULL, NULL, "bes:BasicResourceAttributesDocumentType");
	case SOAP_TYPE_bes__InvalidRequestMessageFaultType:
		return soap_in_bes__InvalidRequestMessageFaultType(soap, NULL, NULL, "bes:InvalidRequestMessageFaultType");
	case SOAP_TYPE_bes__InvalidActivityIdentifierFaultType:
		return soap_in_bes__InvalidActivityIdentifierFaultType(soap, NULL, NULL, "bes:InvalidActivityIdentifierFaultType");
	case SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType:
		return soap_in_bes__OperationWillBeAppliedEventuallyFaultType(soap, NULL, NULL, "bes:OperationWillBeAppliedEventuallyFaultType");
	case SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType:
		return soap_in_bes__CantApplyOperationToCurrentStateFaultType(soap, NULL, NULL, "bes:CantApplyOperationToCurrentStateFaultType");
	case SOAP_TYPE_bes__UnsupportedFeatureFaultType:
		return soap_in_bes__UnsupportedFeatureFaultType(soap, NULL, NULL, "bes:UnsupportedFeatureFaultType");
	case SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType:
		return soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, "bes:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_bes__NotAuthorizedFaultType:
		return soap_in_bes__NotAuthorizedFaultType(soap, NULL, NULL, "bes:NotAuthorizedFaultType");
	case SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType:
		return soap_in_bes__GetFactoryAttributesDocumentResponseType(soap, NULL, NULL, "bes:GetFactoryAttributesDocumentResponseType");
	case SOAP_TYPE_bes__GetFactoryAttributesDocumentType:
		return soap_in_bes__GetFactoryAttributesDocumentType(soap, NULL, NULL, "bes:GetFactoryAttributesDocumentType");
	case SOAP_TYPE_bes__GetActivityDocumentsResponseType:
		return soap_in_bes__GetActivityDocumentsResponseType(soap, NULL, NULL, "bes:GetActivityDocumentsResponseType");
	case SOAP_TYPE_bes__GetActivityDocumentsType:
		return soap_in_bes__GetActivityDocumentsType(soap, NULL, NULL, "bes:GetActivityDocumentsType");
	case SOAP_TYPE_bes__TerminateActivitiesResponseType:
		return soap_in_bes__TerminateActivitiesResponseType(soap, NULL, NULL, "bes:TerminateActivitiesResponseType");
	case SOAP_TYPE_bes__TerminateActivitiesType:
		return soap_in_bes__TerminateActivitiesType(soap, NULL, NULL, "bes:TerminateActivitiesType");
	case SOAP_TYPE_bes__GetActivityStatusesResponseType:
		return soap_in_bes__GetActivityStatusesResponseType(soap, NULL, NULL, "bes:GetActivityStatusesResponseType");
	case SOAP_TYPE_bes__GetActivityStatusesType:
		return soap_in_bes__GetActivityStatusesType(soap, NULL, NULL, "bes:GetActivityStatusesType");
	case SOAP_TYPE_bes__CreateActivityResponseType:
		return soap_in_bes__CreateActivityResponseType(soap, NULL, NULL, "bes:CreateActivityResponseType");
	case SOAP_TYPE_bes__CreateActivityType:
		return soap_in_bes__CreateActivityType(soap, NULL, NULL, "bes:CreateActivityType");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_in_xsd__anyAttribute(soap, NULL, NULL, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentResponseType:
		return soap_in_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, NULL, NULL, "bes:GetFactoryAttributesDocumentResponseType");
	case SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentType:
		return soap_in_PointerTobes__GetFactoryAttributesDocumentType(soap, NULL, NULL, "bes:GetFactoryAttributesDocumentType");
	case SOAP_TYPE_PointerTobes__GetActivityDocumentsResponseType:
		return soap_in_PointerTobes__GetActivityDocumentsResponseType(soap, NULL, NULL, "bes:GetActivityDocumentsResponseType");
	case SOAP_TYPE_PointerTobes__TerminateActivitiesResponseType:
		return soap_in_PointerTobes__TerminateActivitiesResponseType(soap, NULL, NULL, "bes:TerminateActivitiesResponseType");
	case SOAP_TYPE_PointerTobes__GetActivityStatusesResponseType:
		return soap_in_PointerTobes__GetActivityStatusesResponseType(soap, NULL, NULL, "bes:GetActivityStatusesResponseType");
	case SOAP_TYPE_PointerTobes__CreateActivityResponseType:
		return soap_in_PointerTobes__CreateActivityResponseType(soap, NULL, NULL, "bes:CreateActivityResponseType");
	case SOAP_TYPE_PointerTobes__CreateActivityType:
		return soap_in_PointerTobes__CreateActivityType(soap, NULL, NULL, "bes:CreateActivityType");
	case SOAP_TYPE_PointerTobes__UnsupportedFeatureFaultType:
		return soap_in_PointerTobes__UnsupportedFeatureFaultType(soap, NULL, NULL, "bes:UnsupportedFeatureFaultType");
	case SOAP_TYPE_PointerTobes__NotAuthorizedFaultType:
		return soap_in_PointerTobes__NotAuthorizedFaultType(soap, NULL, NULL, "bes:NotAuthorizedFaultType");
	case SOAP_TYPE_PointerTobes__NotAcceptingNewActivitiesFaultType:
		return soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, "bes:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_PointerTobes__InvalidRequestMessageFaultType:
		return soap_in_PointerTobes__InvalidRequestMessageFaultType(soap, NULL, NULL, "bes:InvalidRequestMessageFaultType");
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_in_PointerTo_wsa__FaultTo(soap, NULL, NULL, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_in_PointerTo_wsa__ReplyTo(soap, NULL, NULL, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_in_PointerTo_wsa__From(soap, NULL, NULL, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_in_PointerTo_wsa__RelatesTo(soap, NULL, NULL, "wsa:RelatesTo");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
	case SOAP_TYPE_PointerToposix__GroupName_USCOREType:
		return soap_in_PointerToposix__GroupName_USCOREType(soap, NULL, NULL, "posix:GroupName_Type");
	case SOAP_TYPE_PointerToposix__UserName_USCOREType:
		return soap_in_PointerToposix__UserName_USCOREType(soap, NULL, NULL, "posix:UserName_Type");
	case SOAP_TYPE_PointerToposix__Limits_USCOREType:
		return soap_in_PointerToposix__Limits_USCOREType(soap, NULL, NULL, "posix:Limits_Type");
	case SOAP_TYPE_PointerToposix__Environment_USCOREType:
		return soap_in_PointerToposix__Environment_USCOREType(soap, NULL, NULL, "posix:Environment_Type");
	case SOAP_TYPE_PointerToposix__DirectoryName_USCOREType:
		return soap_in_PointerToposix__DirectoryName_USCOREType(soap, NULL, NULL, "posix:DirectoryName_Type");
	case SOAP_TYPE_PointerToposix__Argument_USCOREType:
		return soap_in_PointerToposix__Argument_USCOREType(soap, NULL, NULL, "posix:Argument_Type");
	case SOAP_TYPE_PointerToposix__FileName_USCOREType:
		return soap_in_PointerToposix__FileName_USCOREType(soap, NULL, NULL, "posix:FileName_Type");
	case SOAP_TYPE_PointerToapp__UserName_USCOREType:
		return soap_in_PointerToapp__UserName_USCOREType(soap, NULL, NULL, "app:UserName_Type");
	case SOAP_TYPE_PointerToapp__Environment_USCOREType:
		return soap_in_PointerToapp__Environment_USCOREType(soap, NULL, NULL, "app:Environment_Type");
	case SOAP_TYPE_PointerToapp__DirectoryName_USCOREType:
		return soap_in_PointerToapp__DirectoryName_USCOREType(soap, NULL, NULL, "app:DirectoryName_Type");
	case SOAP_TYPE_PointerToapp__Argument_USCOREType:
		return soap_in_PointerToapp__Argument_USCOREType(soap, NULL, NULL, "app:Argument_Type");
	case SOAP_TYPE_PointerToapp__FileName_USCOREType:
		return soap_in_PointerToapp__FileName_USCOREType(soap, NULL, NULL, "app:FileName_Type");
	case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
		return soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
		return soap_in_PointerTojsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
		return soap_in_PointerTojsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
		return soap_in_PointerTojsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
		return soap_in_PointerTojsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
		return soap_in_PointerTojsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
		return soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
		return soap_in_PointerTojsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
		return soap_in_PointerTojsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
		return soap_in_PointerTojsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
		return soap_in_PointerTojsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_PointerTowsa__MetadataType:
		return soap_in_PointerTowsa__MetadataType(soap, NULL, NULL, "wsa:MetadataType");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_in_PointerTowsa__ReferenceParametersType(soap, NULL, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__AttributedURIType:
		return soap_in_PointerTowsa__AttributedURIType(soap, NULL, NULL, "wsa:AttributedURIType");
	case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
		return soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTowsa__EndpointReferenceType:
		return soap_in_PointerTowsa__EndpointReferenceType(soap, NULL, NULL, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTobes__BasicResourceAttributesDocumentType:
		return soap_in_PointerTobes__BasicResourceAttributesDocumentType(soap, NULL, NULL, "bes:BasicResourceAttributesDocumentType");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_PointerTobes__ActivityStatusType:
		return soap_in_PointerTobes__ActivityStatusType(soap, NULL, NULL, "bes:ActivityStatusType");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTobes__TerminateActivityResponseType:
		return soap_in_PointerTobes__TerminateActivityResponseType(soap, NULL, NULL, "bes:TerminateActivityResponseType");
	case SOAP_TYPE_jsdl__Description_USCOREType:
	{	char **s;
		s = soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa__FaultCodesOpenEnumType(soap, NULL, NULL, "wsa:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa__RelationshipTypeOpenEnum(soap, NULL, NULL, "wsa:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_xsd__normalizedString:
	{	char **s;
		s = soap_in_xsd__normalizedString(soap, NULL, NULL, "xsd:normalizedString");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonNegativeInteger:
	{	char **s;
		s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NCName:
	{	char **s;
		s = soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__ID:
	{	char **s;
		s = soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CreationFlagEnumeration"))
		{	*type = SOAP_TYPE_jsdl__CreationFlagEnumeration;
			return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_jsdl__FileSystemTypeEnumeration;
			return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration;
			return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:ProcessorArchitectureEnumeration"))
		{	*type = SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration;
			return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa__FaultCodesType;
			return soap_in_wsa__FaultCodesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelationshipType"))
		{	*type = SOAP_TYPE_wsa__RelationshipType;
			return soap_in_wsa__RelationshipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:ActivityStateEnumeration"))
		{	*type = SOAP_TYPE_bes__ActivityStateEnumeration;
			return soap_in_bes__ActivityStateEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:POSIXApplication_Type"))
		{	*type = SOAP_TYPE_posix__POSIXApplication_USCOREType;
			return soap_in_posix__POSIXApplication_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:GroupName_Type"))
		{	*type = SOAP_TYPE_posix__GroupName_USCOREType;
			return soap_in_posix__GroupName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:UserName_Type"))
		{	*type = SOAP_TYPE_posix__UserName_USCOREType;
			return soap_in_posix__UserName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:Limits_Type"))
		{	*type = SOAP_TYPE_posix__Limits_USCOREType;
			return soap_in_posix__Limits_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:DirectoryName_Type"))
		{	*type = SOAP_TYPE_posix__DirectoryName_USCOREType;
			return soap_in_posix__DirectoryName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:FileName_Type"))
		{	*type = SOAP_TYPE_posix__FileName_USCOREType;
			return soap_in_posix__FileName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:Argument_Type"))
		{	*type = SOAP_TYPE_posix__Argument_USCOREType;
			return soap_in_posix__Argument_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:Environment_Type"))
		{	*type = SOAP_TYPE_posix__Environment_USCOREType;
			return soap_in_posix__Environment_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:HPCProfileApplication_Type"))
		{	*type = SOAP_TYPE_app__HPCProfileApplication_USCOREType;
			return soap_in_app__HPCProfileApplication_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:UserName_Type"))
		{	*type = SOAP_TYPE_app__UserName_USCOREType;
			return soap_in_app__UserName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:DirectoryName_Type"))
		{	*type = SOAP_TYPE_app__DirectoryName_USCOREType;
			return soap_in_app__DirectoryName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:FileName_Type"))
		{	*type = SOAP_TYPE_app__FileName_USCOREType;
			return soap_in_app__FileName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:Argument_Type"))
		{	*type = SOAP_TYPE_app__Argument_USCOREType;
			return soap_in_app__Argument_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:Environment_Type"))
		{	*type = SOAP_TYPE_app__Environment_USCOREType;
			return soap_in_app__Environment_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:SourceTarget_Type"))
		{	*type = SOAP_TYPE_jsdl__SourceTarget_USCOREType;
			return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:DataStaging_Type"))
		{	*type = SOAP_TYPE_jsdl__DataStaging_USCOREType;
			return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemType_Type"))
		{	*type = SOAP_TYPE_jsdl__OperatingSystemType_USCOREType;
			return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystem_Type"))
		{	*type = SOAP_TYPE_jsdl__OperatingSystem_USCOREType;
			return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystem_Type"))
		{	*type = SOAP_TYPE_jsdl__FileSystem_USCOREType;
			return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CPUArchitecture_Type"))
		{	*type = SOAP_TYPE_jsdl__CPUArchitecture_USCOREType;
			return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CandidateHosts_Type"))
		{	*type = SOAP_TYPE_jsdl__CandidateHosts_USCOREType;
			return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Resources_Type"))
		{	*type = SOAP_TYPE_jsdl__Resources_USCOREType;
			return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Application_Type"))
		{	*type = SOAP_TYPE_jsdl__Application_USCOREType;
			return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobIdentification_Type"))
		{	*type = SOAP_TYPE_jsdl__JobIdentification_USCOREType;
			return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDescription_Type"))
		{	*type = SOAP_TYPE_jsdl__JobDescription_USCOREType;
			return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDefinition_Type"))
		{	*type = SOAP_TYPE_jsdl__JobDefinition_USCOREType;
			return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:RangeValue_Type"))
		{	*type = SOAP_TYPE_jsdl__RangeValue_USCOREType;
			return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Range_Type"))
		{	*type = SOAP_TYPE_jsdl__Range_USCOREType;
			return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Exact_Type"))
		{	*type = SOAP_TYPE_jsdl__Exact_USCOREType;
			return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Boundary_Type"))
		{	*type = SOAP_TYPE_jsdl__Boundary_USCOREType;
			return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa__ProblemActionType;
			return soap_in_wsa__ProblemActionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:AttributedQNameType"))
		{	*type = SOAP_TYPE_wsa__AttributedQNameType;
			return soap_in_wsa__AttributedQNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:AttributedUnsignedLongType"))
		{	*type = SOAP_TYPE_wsa__AttributedUnsignedLongType;
			return soap_in_wsa__AttributedUnsignedLongType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:AttributedURIType"))
		{	*type = SOAP_TYPE_wsa__AttributedURIType;
			return soap_in_wsa__AttributedURIType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelatesToType"))
		{	*type = SOAP_TYPE_wsa__RelatesToType;
			return soap_in_wsa__RelatesToType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:MetadataType"))
		{	*type = SOAP_TYPE_wsa__MetadataType;
			return soap_in_wsa__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa__ReferenceParametersType;
			return soap_in_wsa__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa__EndpointReferenceType;
			return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:TerminateActivityResponseType"))
		{	*type = SOAP_TYPE_bes__TerminateActivityResponseType;
			return soap_in_bes__TerminateActivityResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityDocumentResponseType"))
		{	*type = SOAP_TYPE_bes__GetActivityDocumentResponseType;
			return soap_in_bes__GetActivityDocumentResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityStatusResponseType"))
		{	*type = SOAP_TYPE_bes__GetActivityStatusResponseType;
			return soap_in_bes__GetActivityStatusResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:ActivityStatusType"))
		{	*type = SOAP_TYPE_bes__ActivityStatusType;
			return soap_in_bes__ActivityStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:ActivityDocumentType"))
		{	*type = SOAP_TYPE_bes__ActivityDocumentType;
			return soap_in_bes__ActivityDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:FactoryResourceAttributesDocumentType"))
		{	*type = SOAP_TYPE_bes__FactoryResourceAttributesDocumentType;
			return soap_in_bes__FactoryResourceAttributesDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:BasicResourceAttributesDocumentType"))
		{	*type = SOAP_TYPE_bes__BasicResourceAttributesDocumentType;
			return soap_in_bes__BasicResourceAttributesDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:InvalidRequestMessageFaultType"))
		{	*type = SOAP_TYPE_bes__InvalidRequestMessageFaultType;
			return soap_in_bes__InvalidRequestMessageFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:InvalidActivityIdentifierFaultType"))
		{	*type = SOAP_TYPE_bes__InvalidActivityIdentifierFaultType;
			return soap_in_bes__InvalidActivityIdentifierFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:OperationWillBeAppliedEventuallyFaultType"))
		{	*type = SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType;
			return soap_in_bes__OperationWillBeAppliedEventuallyFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:CantApplyOperationToCurrentStateFaultType"))
		{	*type = SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType;
			return soap_in_bes__CantApplyOperationToCurrentStateFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:UnsupportedFeatureFaultType"))
		{	*type = SOAP_TYPE_bes__UnsupportedFeatureFaultType;
			return soap_in_bes__UnsupportedFeatureFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:NotAcceptingNewActivitiesFaultType"))
		{	*type = SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType;
			return soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:NotAuthorizedFaultType"))
		{	*type = SOAP_TYPE_bes__NotAuthorizedFaultType;
			return soap_in_bes__NotAuthorizedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetFactoryAttributesDocumentResponseType"))
		{	*type = SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType;
			return soap_in_bes__GetFactoryAttributesDocumentResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetFactoryAttributesDocumentType"))
		{	*type = SOAP_TYPE_bes__GetFactoryAttributesDocumentType;
			return soap_in_bes__GetFactoryAttributesDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityDocumentsResponseType"))
		{	*type = SOAP_TYPE_bes__GetActivityDocumentsResponseType;
			return soap_in_bes__GetActivityDocumentsResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityDocumentsType"))
		{	*type = SOAP_TYPE_bes__GetActivityDocumentsType;
			return soap_in_bes__GetActivityDocumentsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:TerminateActivitiesResponseType"))
		{	*type = SOAP_TYPE_bes__TerminateActivitiesResponseType;
			return soap_in_bes__TerminateActivitiesResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:TerminateActivitiesType"))
		{	*type = SOAP_TYPE_bes__TerminateActivitiesType;
			return soap_in_bes__TerminateActivitiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityStatusesResponseType"))
		{	*type = SOAP_TYPE_bes__GetActivityStatusesResponseType;
			return soap_in_bes__GetActivityStatusesResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityStatusesType"))
		{	*type = SOAP_TYPE_bes__GetActivityStatusesType;
			return soap_in_bes__GetActivityStatusesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:CreateActivityResponseType"))
		{	*type = SOAP_TYPE_bes__CreateActivityResponseType;
			return soap_in_bes__CreateActivityResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:CreateActivityType"))
		{	*type = SOAP_TYPE_bes__CreateActivityType;
			return soap_in_bes__CreateActivityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyAttribute"))
		{	*type = SOAP_TYPE_xsd__anyAttribute;
			return soap_in_xsd__anyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Description_Type"))
		{	char **s;
			*type = SOAP_TYPE_jsdl__Description_USCOREType;
			s = soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa__FaultCodesOpenEnumType;
			s = soap_in_wsa__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa__RelationshipTypeOpenEnum;
			s = soap_in_wsa__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:normalizedString"))
		{	char **s;
			*type = SOAP_TYPE_xsd__normalizedString;
			s = soap_in_xsd__normalizedString(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__nonNegativeInteger;
			s = soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NCName;
			s = soap_in_xsd__NCName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	char **s;
			*type = SOAP_TYPE_xsd__ID;
			s = soap_in_xsd__ID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "jsdl:DeleteOnTermination"))
		{	*type = SOAP_TYPE__jsdl__DeleteOnTermination;
			return soap_in__jsdl__DeleteOnTermination(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CreationFlag"))
		{	*type = SOAP_TYPE__jsdl__CreationFlag;
			return soap_in__jsdl__CreationFlag(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystemType"))
		{	*type = SOAP_TYPE__jsdl__FileSystemType;
			return soap_in__jsdl__FileSystemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CPUArchitectureName"))
		{	*type = SOAP_TYPE__jsdl__CPUArchitectureName;
			return soap_in__jsdl__CPUArchitectureName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:ExclusiveExecution"))
		{	*type = SOAP_TYPE__jsdl__ExclusiveExecution;
			return soap_in__jsdl__ExclusiveExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemName"))
		{	*type = SOAP_TYPE__jsdl__OperatingSystemName;
			return soap_in__jsdl__OperatingSystemName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa__IsReferenceParameter;
			return soap_in__wsa__IsReferenceParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:GroupName"))
		{	*type = SOAP_TYPE__posix__GroupName;
			return soap_in__posix__GroupName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:UserName"))
		{	*type = SOAP_TYPE__posix__UserName;
			return soap_in__posix__UserName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:ThreadCountLimit"))
		{	*type = SOAP_TYPE__posix__ThreadCountLimit;
			return soap_in__posix__ThreadCountLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:VirtualMemoryLimit"))
		{	*type = SOAP_TYPE__posix__VirtualMemoryLimit;
			return soap_in__posix__VirtualMemoryLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:ProcessCountLimit"))
		{	*type = SOAP_TYPE__posix__ProcessCountLimit;
			return soap_in__posix__ProcessCountLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:CPUTimeLimit"))
		{	*type = SOAP_TYPE__posix__CPUTimeLimit;
			return soap_in__posix__CPUTimeLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:StackSizeLimit"))
		{	*type = SOAP_TYPE__posix__StackSizeLimit;
			return soap_in__posix__StackSizeLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:PipeSizeLimit"))
		{	*type = SOAP_TYPE__posix__PipeSizeLimit;
			return soap_in__posix__PipeSizeLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:OpenDescriptorsLimit"))
		{	*type = SOAP_TYPE__posix__OpenDescriptorsLimit;
			return soap_in__posix__OpenDescriptorsLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:MemoryLimit"))
		{	*type = SOAP_TYPE__posix__MemoryLimit;
			return soap_in__posix__MemoryLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:LockedMemoryLimit"))
		{	*type = SOAP_TYPE__posix__LockedMemoryLimit;
			return soap_in__posix__LockedMemoryLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:DataSegmentLimit"))
		{	*type = SOAP_TYPE__posix__DataSegmentLimit;
			return soap_in__posix__DataSegmentLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:CoreDumpLimit"))
		{	*type = SOAP_TYPE__posix__CoreDumpLimit;
			return soap_in__posix__CoreDumpLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:FileSizeLimit"))
		{	*type = SOAP_TYPE__posix__FileSizeLimit;
			return soap_in__posix__FileSizeLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:WallTimeLimit"))
		{	*type = SOAP_TYPE__posix__WallTimeLimit;
			return soap_in__posix__WallTimeLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:Environment"))
		{	*type = SOAP_TYPE__posix__Environment;
			return soap_in__posix__Environment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:WorkingDirectory"))
		{	*type = SOAP_TYPE__posix__WorkingDirectory;
			return soap_in__posix__WorkingDirectory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:Error"))
		{	*type = SOAP_TYPE__posix__Error;
			return soap_in__posix__Error(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:Output"))
		{	*type = SOAP_TYPE__posix__Output;
			return soap_in__posix__Output(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:Input"))
		{	*type = SOAP_TYPE__posix__Input;
			return soap_in__posix__Input(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:Argument"))
		{	*type = SOAP_TYPE__posix__Argument;
			return soap_in__posix__Argument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:Executable"))
		{	*type = SOAP_TYPE__posix__Executable;
			return soap_in__posix__Executable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "posix:POSIXApplication"))
		{	*type = SOAP_TYPE__posix__POSIXApplication;
			return soap_in__posix__POSIXApplication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:UserName"))
		{	*type = SOAP_TYPE__app__UserName;
			return soap_in__app__UserName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:Environment"))
		{	*type = SOAP_TYPE__app__Environment;
			return soap_in__app__Environment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:WorkingDirectory"))
		{	*type = SOAP_TYPE__app__WorkingDirectory;
			return soap_in__app__WorkingDirectory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:Error"))
		{	*type = SOAP_TYPE__app__Error;
			return soap_in__app__Error(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:Output"))
		{	*type = SOAP_TYPE__app__Output;
			return soap_in__app__Output(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:Input"))
		{	*type = SOAP_TYPE__app__Input;
			return soap_in__app__Input(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:Argument"))
		{	*type = SOAP_TYPE__app__Argument;
			return soap_in__app__Argument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:Executable"))
		{	*type = SOAP_TYPE__app__Executable;
			return soap_in__app__Executable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "app:HPCProfileApplication"))
		{	*type = SOAP_TYPE__app__HPCProfileApplication;
			return soap_in__app__HPCProfileApplication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Target"))
		{	*type = SOAP_TYPE__jsdl__Target;
			return soap_in__jsdl__Target(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Source"))
		{	*type = SOAP_TYPE__jsdl__Source;
			return soap_in__jsdl__Source(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:DataStaging"))
		{	*type = SOAP_TYPE__jsdl__DataStaging;
			return soap_in__jsdl__DataStaging(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:TotalResourceCount"))
		{	*type = SOAP_TYPE__jsdl__TotalResourceCount;
			return soap_in__jsdl__TotalResourceCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:TotalDiskSpace"))
		{	*type = SOAP_TYPE__jsdl__TotalDiskSpace;
			return soap_in__jsdl__TotalDiskSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:TotalVirtualMemory"))
		{	*type = SOAP_TYPE__jsdl__TotalVirtualMemory;
			return soap_in__jsdl__TotalVirtualMemory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:TotalPhysicalMemory"))
		{	*type = SOAP_TYPE__jsdl__TotalPhysicalMemory;
			return soap_in__jsdl__TotalPhysicalMemory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:TotalCPUCount"))
		{	*type = SOAP_TYPE__jsdl__TotalCPUCount;
			return soap_in__jsdl__TotalCPUCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:TotalCPUTime"))
		{	*type = SOAP_TYPE__jsdl__TotalCPUTime;
			return soap_in__jsdl__TotalCPUTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:IndividualDiskSpace"))
		{	*type = SOAP_TYPE__jsdl__IndividualDiskSpace;
			return soap_in__jsdl__IndividualDiskSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:IndividualNetworkBandwidth"))
		{	*type = SOAP_TYPE__jsdl__IndividualNetworkBandwidth;
			return soap_in__jsdl__IndividualNetworkBandwidth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:IndividualVirtualMemory"))
		{	*type = SOAP_TYPE__jsdl__IndividualVirtualMemory;
			return soap_in__jsdl__IndividualVirtualMemory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:IndividualPhysicalMemory"))
		{	*type = SOAP_TYPE__jsdl__IndividualPhysicalMemory;
			return soap_in__jsdl__IndividualPhysicalMemory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:IndividualCPUCount"))
		{	*type = SOAP_TYPE__jsdl__IndividualCPUCount;
			return soap_in__jsdl__IndividualCPUCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:IndividualCPUSpeed"))
		{	*type = SOAP_TYPE__jsdl__IndividualCPUSpeed;
			return soap_in__jsdl__IndividualCPUSpeed(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:IndividualCPUTime"))
		{	*type = SOAP_TYPE__jsdl__IndividualCPUTime;
			return soap_in__jsdl__IndividualCPUTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:DiskSpace"))
		{	*type = SOAP_TYPE__jsdl__DiskSpace;
			return soap_in__jsdl__DiskSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystem"))
		{	*type = SOAP_TYPE__jsdl__FileSystem;
			return soap_in__jsdl__FileSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CPUArchitecture"))
		{	*type = SOAP_TYPE__jsdl__CPUArchitecture;
			return soap_in__jsdl__CPUArchitecture(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemType"))
		{	*type = SOAP_TYPE__jsdl__OperatingSystemType;
			return soap_in__jsdl__OperatingSystemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystem"))
		{	*type = SOAP_TYPE__jsdl__OperatingSystem;
			return soap_in__jsdl__OperatingSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CandidateHosts"))
		{	*type = SOAP_TYPE__jsdl__CandidateHosts;
			return soap_in__jsdl__CandidateHosts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Resources"))
		{	*type = SOAP_TYPE__jsdl__Resources;
			return soap_in__jsdl__Resources(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Application"))
		{	*type = SOAP_TYPE__jsdl__Application;
			return soap_in__jsdl__Application(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobIdentification"))
		{	*type = SOAP_TYPE__jsdl__JobIdentification;
			return soap_in__jsdl__JobIdentification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDescription"))
		{	*type = SOAP_TYPE__jsdl__JobDescription;
			return soap_in__jsdl__JobDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDefinition"))
		{	*type = SOAP_TYPE__jsdl__JobDefinition;
			return soap_in__jsdl__JobDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ProblemAction"))
		{	*type = SOAP_TYPE__wsa__ProblemAction;
			return soap_in__wsa__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ProblemIRI"))
		{	*type = SOAP_TYPE__wsa__ProblemIRI;
			return soap_in__wsa__ProblemIRI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ProblemHeaderQName"))
		{	*type = SOAP_TYPE__wsa__ProblemHeaderQName;
			return soap_in__wsa__ProblemHeaderQName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RetryAfter"))
		{	*type = SOAP_TYPE__wsa__RetryAfter;
			return soap_in__wsa__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:Action"))
		{	*type = SOAP_TYPE__wsa__Action;
			return soap_in__wsa__Action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:To"))
		{	*type = SOAP_TYPE__wsa__To;
			return soap_in__wsa__To(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultTo"))
		{	*type = SOAP_TYPE__wsa__FaultTo;
			return soap_in__wsa__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:From"))
		{	*type = SOAP_TYPE__wsa__From;
			return soap_in__wsa__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReplyTo"))
		{	*type = SOAP_TYPE__wsa__ReplyTo;
			return soap_in__wsa__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelatesTo"))
		{	*type = SOAP_TYPE__wsa__RelatesTo;
			return soap_in__wsa__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:MessageID"))
		{	*type = SOAP_TYPE__wsa__MessageID;
			return soap_in__wsa__MessageID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:Metadata"))
		{	*type = SOAP_TYPE__wsa__Metadata;
			return soap_in__wsa__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa__ReferenceParameters;
			return soap_in__wsa__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReference"))
		{	*type = SOAP_TYPE__wsa__EndpointReference;
			return soap_in__wsa__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:ActivityStatus"))
		{	*type = SOAP_TYPE__bes__ActivityStatus;
			return soap_in__bes__ActivityStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:ActivityDocument"))
		{	*type = SOAP_TYPE__bes__ActivityDocument;
			return soap_in__bes__ActivityDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:FactoryResourceAttributesDocument"))
		{	*type = SOAP_TYPE__bes__FactoryResourceAttributesDocument;
			return soap_in__bes__FactoryResourceAttributesDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:BasicResourceAttributesDocument"))
		{	*type = SOAP_TYPE__bes__BasicResourceAttributesDocument;
			return soap_in__bes__BasicResourceAttributesDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:InvalidRequestMessageFault"))
		{	*type = SOAP_TYPE__bes__InvalidRequestMessageFault;
			return soap_in__bes__InvalidRequestMessageFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:InvalidActivityIdentifierFault"))
		{	*type = SOAP_TYPE__bes__InvalidActivityIdentifierFault;
			return soap_in__bes__InvalidActivityIdentifierFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:OperationWillBeAppliedEventuallyFault"))
		{	*type = SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault;
			return soap_in__bes__OperationWillBeAppliedEventuallyFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:CantApplyOperationToCurrentStateFault"))
		{	*type = SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault;
			return soap_in__bes__CantApplyOperationToCurrentStateFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:UnsupportedFeatureFault"))
		{	*type = SOAP_TYPE__bes__UnsupportedFeatureFault;
			return soap_in__bes__UnsupportedFeatureFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:NotAcceptingNewActivitiesFault"))
		{	*type = SOAP_TYPE__bes__NotAcceptingNewActivitiesFault;
			return soap_in__bes__NotAcceptingNewActivitiesFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:NotAuthorizedFault"))
		{	*type = SOAP_TYPE__bes__NotAuthorizedFault;
			return soap_in__bes__NotAuthorizedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetFactoryAttributesDocumentResponse"))
		{	*type = SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse;
			return soap_in__bes__GetFactoryAttributesDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetFactoryAttributesDocument"))
		{	*type = SOAP_TYPE__bes__GetFactoryAttributesDocument;
			return soap_in__bes__GetFactoryAttributesDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityDocumentsResponse"))
		{	*type = SOAP_TYPE__bes__GetActivityDocumentsResponse;
			return soap_in__bes__GetActivityDocumentsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityDocuments"))
		{	*type = SOAP_TYPE__bes__GetActivityDocuments;
			return soap_in__bes__GetActivityDocuments(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:TerminateActivitiesResponse"))
		{	*type = SOAP_TYPE__bes__TerminateActivitiesResponse;
			return soap_in__bes__TerminateActivitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:TerminateActivities"))
		{	*type = SOAP_TYPE__bes__TerminateActivities;
			return soap_in__bes__TerminateActivities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityStatusesResponse"))
		{	*type = SOAP_TYPE__bes__GetActivityStatusesResponse;
			return soap_in__bes__GetActivityStatusesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityStatuses"))
		{	*type = SOAP_TYPE__bes__GetActivityStatuses;
			return soap_in__bes__GetActivityStatuses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:CreateActivityResponse"))
		{	*type = SOAP_TYPE__bes__CreateActivityResponse;
			return soap_in__bes__CreateActivityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:CreateActivity"))
		{	*type = SOAP_TYPE__bes__CreateActivity;
			return soap_in__bes__CreateActivity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:URI"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__URI;
			s = soap_in__jsdl__URI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:FilesystemName"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__FilesystemName;
			s = soap_in__jsdl__FilesystemName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:FileName"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__FileName;
			s = soap_in__jsdl__FileName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:MountPoint"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__MountPoint;
			s = soap_in__jsdl__MountPoint(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemVersion"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__OperatingSystemVersion;
			s = soap_in__jsdl__OperatingSystemVersion(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:HostName"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__HostName;
			s = soap_in__jsdl__HostName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:ApplicationVersion"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__ApplicationVersion;
			s = soap_in__jsdl__ApplicationVersion(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:ApplicationName"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__ApplicationName;
			s = soap_in__jsdl__ApplicationName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:JobProject"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__JobProject;
			s = soap_in__jsdl__JobProject(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:JobAnnotation"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__JobAnnotation;
			s = soap_in__jsdl__JobAnnotation(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:Description"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__Description;
			s = soap_in__jsdl__Description(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "jsdl:JobName"))
		{	char **s;
			*type = SOAP_TYPE__jsdl__JobName;
			s = soap_in__jsdl__JobName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE__jsdl__DeleteOnTermination:
		return soap_out__jsdl__DeleteOnTermination(soap, "jsdl:DeleteOnTermination", id, (const enum xsd__boolean *)ptr, NULL);
	case SOAP_TYPE__jsdl__CreationFlag:
		return soap_out__jsdl__CreationFlag(soap, "jsdl:CreationFlag", id, (const enum jsdl__CreationFlagEnumeration *)ptr, NULL);
	case SOAP_TYPE__jsdl__FileSystemType:
		return soap_out__jsdl__FileSystemType(soap, "jsdl:FileSystemType", id, (const enum jsdl__FileSystemTypeEnumeration *)ptr, NULL);
	case SOAP_TYPE__jsdl__CPUArchitectureName:
		return soap_out__jsdl__CPUArchitectureName(soap, "jsdl:CPUArchitectureName", id, (const enum jsdl__ProcessorArchitectureEnumeration *)ptr, NULL);
	case SOAP_TYPE__jsdl__ExclusiveExecution:
		return soap_out__jsdl__ExclusiveExecution(soap, "jsdl:ExclusiveExecution", id, (const enum xsd__boolean *)ptr, NULL);
	case SOAP_TYPE__jsdl__OperatingSystemName:
		return soap_out__jsdl__OperatingSystemName(soap, "jsdl:OperatingSystemName", id, (const enum jsdl__OperatingSystemTypeEnumeration *)ptr, NULL);
	case SOAP_TYPE__wsa__IsReferenceParameter:
		return soap_out__wsa__IsReferenceParameter(soap, "wsa:IsReferenceParameter", id, (const enum xsd__boolean *)ptr, NULL);
	case SOAP_TYPE_jsdl__CreationFlagEnumeration:
		return soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, (const enum jsdl__CreationFlagEnumeration *)ptr, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_jsdl__FileSystemTypeEnumeration:
		return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, (const enum jsdl__FileSystemTypeEnumeration *)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration:
		return soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, (const enum jsdl__OperatingSystemTypeEnumeration *)ptr, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration:
		return soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, (const enum jsdl__ProcessorArchitectureEnumeration *)ptr, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_wsa__FaultCodesType:
		return soap_out_wsa__FaultCodesType(soap, tag, id, (const enum wsa__FaultCodesType *)ptr, "wsa:FaultCodesType");
	case SOAP_TYPE_wsa__RelationshipType:
		return soap_out_wsa__RelationshipType(soap, tag, id, (const enum wsa__RelationshipType *)ptr, "wsa:RelationshipType");
	case SOAP_TYPE_bes__ActivityStateEnumeration:
		return soap_out_bes__ActivityStateEnumeration(soap, tag, id, (const enum bes__ActivityStateEnumeration *)ptr, "bes:ActivityStateEnumeration");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE__posix__GroupName:
		return soap_out__posix__GroupName(soap, "posix:GroupName", id, (const struct posix__GroupName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__UserName:
		return soap_out__posix__UserName(soap, "posix:UserName", id, (const struct posix__UserName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__ThreadCountLimit:
		return soap_out__posix__ThreadCountLimit(soap, "posix:ThreadCountLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__VirtualMemoryLimit:
		return soap_out__posix__VirtualMemoryLimit(soap, "posix:VirtualMemoryLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__ProcessCountLimit:
		return soap_out__posix__ProcessCountLimit(soap, "posix:ProcessCountLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__CPUTimeLimit:
		return soap_out__posix__CPUTimeLimit(soap, "posix:CPUTimeLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__StackSizeLimit:
		return soap_out__posix__StackSizeLimit(soap, "posix:StackSizeLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__PipeSizeLimit:
		return soap_out__posix__PipeSizeLimit(soap, "posix:PipeSizeLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__OpenDescriptorsLimit:
		return soap_out__posix__OpenDescriptorsLimit(soap, "posix:OpenDescriptorsLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__MemoryLimit:
		return soap_out__posix__MemoryLimit(soap, "posix:MemoryLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__LockedMemoryLimit:
		return soap_out__posix__LockedMemoryLimit(soap, "posix:LockedMemoryLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__DataSegmentLimit:
		return soap_out__posix__DataSegmentLimit(soap, "posix:DataSegmentLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__CoreDumpLimit:
		return soap_out__posix__CoreDumpLimit(soap, "posix:CoreDumpLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__FileSizeLimit:
		return soap_out__posix__FileSizeLimit(soap, "posix:FileSizeLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__WallTimeLimit:
		return soap_out__posix__WallTimeLimit(soap, "posix:WallTimeLimit", id, (const struct posix__Limits_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__Environment:
		return soap_out__posix__Environment(soap, "posix:Environment", id, (const struct posix__Environment_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__WorkingDirectory:
		return soap_out__posix__WorkingDirectory(soap, "posix:WorkingDirectory", id, (const struct posix__DirectoryName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__Error:
		return soap_out__posix__Error(soap, "posix:Error", id, (const struct posix__FileName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__Output:
		return soap_out__posix__Output(soap, "posix:Output", id, (const struct posix__FileName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__Input:
		return soap_out__posix__Input(soap, "posix:Input", id, (const struct posix__FileName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__Argument:
		return soap_out__posix__Argument(soap, "posix:Argument", id, (const struct posix__Argument_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__Executable:
		return soap_out__posix__Executable(soap, "posix:Executable", id, (const struct posix__FileName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__posix__POSIXApplication:
		return soap_out__posix__POSIXApplication(soap, "posix:POSIXApplication", id, (const struct posix__POSIXApplication_USCOREType *)ptr, NULL);
	case SOAP_TYPE__app__UserName:
		return soap_out__app__UserName(soap, "app:UserName", id, (const struct app__UserName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__app__Environment:
		return soap_out__app__Environment(soap, "app:Environment", id, (const struct app__Environment_USCOREType *)ptr, NULL);
	case SOAP_TYPE__app__WorkingDirectory:
		return soap_out__app__WorkingDirectory(soap, "app:WorkingDirectory", id, (const struct app__DirectoryName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__app__Error:
		return soap_out__app__Error(soap, "app:Error", id, (const struct app__FileName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__app__Output:
		return soap_out__app__Output(soap, "app:Output", id, (const struct app__FileName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__app__Input:
		return soap_out__app__Input(soap, "app:Input", id, (const struct app__FileName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__app__Argument:
		return soap_out__app__Argument(soap, "app:Argument", id, (const struct app__Argument_USCOREType *)ptr, NULL);
	case SOAP_TYPE__app__Executable:
		return soap_out__app__Executable(soap, "app:Executable", id, (const struct app__FileName_USCOREType *)ptr, NULL);
	case SOAP_TYPE__app__HPCProfileApplication:
		return soap_out__app__HPCProfileApplication(soap, "app:HPCProfileApplication", id, (const struct app__HPCProfileApplication_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__Target:
		return soap_out__jsdl__Target(soap, "jsdl:Target", id, (const struct jsdl__SourceTarget_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__Source:
		return soap_out__jsdl__Source(soap, "jsdl:Source", id, (const struct jsdl__SourceTarget_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__DataStaging:
		return soap_out__jsdl__DataStaging(soap, "jsdl:DataStaging", id, (const struct jsdl__DataStaging_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__TotalResourceCount:
		return soap_out__jsdl__TotalResourceCount(soap, "jsdl:TotalResourceCount", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__TotalDiskSpace:
		return soap_out__jsdl__TotalDiskSpace(soap, "jsdl:TotalDiskSpace", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__TotalVirtualMemory:
		return soap_out__jsdl__TotalVirtualMemory(soap, "jsdl:TotalVirtualMemory", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__TotalPhysicalMemory:
		return soap_out__jsdl__TotalPhysicalMemory(soap, "jsdl:TotalPhysicalMemory", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__TotalCPUCount:
		return soap_out__jsdl__TotalCPUCount(soap, "jsdl:TotalCPUCount", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__TotalCPUTime:
		return soap_out__jsdl__TotalCPUTime(soap, "jsdl:TotalCPUTime", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__IndividualDiskSpace:
		return soap_out__jsdl__IndividualDiskSpace(soap, "jsdl:IndividualDiskSpace", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__IndividualNetworkBandwidth:
		return soap_out__jsdl__IndividualNetworkBandwidth(soap, "jsdl:IndividualNetworkBandwidth", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__IndividualVirtualMemory:
		return soap_out__jsdl__IndividualVirtualMemory(soap, "jsdl:IndividualVirtualMemory", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__IndividualPhysicalMemory:
		return soap_out__jsdl__IndividualPhysicalMemory(soap, "jsdl:IndividualPhysicalMemory", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__IndividualCPUCount:
		return soap_out__jsdl__IndividualCPUCount(soap, "jsdl:IndividualCPUCount", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__IndividualCPUSpeed:
		return soap_out__jsdl__IndividualCPUSpeed(soap, "jsdl:IndividualCPUSpeed", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__IndividualCPUTime:
		return soap_out__jsdl__IndividualCPUTime(soap, "jsdl:IndividualCPUTime", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__DiskSpace:
		return soap_out__jsdl__DiskSpace(soap, "jsdl:DiskSpace", id, (const struct jsdl__RangeValue_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__FileSystem:
		return soap_out__jsdl__FileSystem(soap, "jsdl:FileSystem", id, (const struct jsdl__FileSystem_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__CPUArchitecture:
		return soap_out__jsdl__CPUArchitecture(soap, "jsdl:CPUArchitecture", id, (const struct jsdl__CPUArchitecture_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__OperatingSystemType:
		return soap_out__jsdl__OperatingSystemType(soap, "jsdl:OperatingSystemType", id, (const struct jsdl__OperatingSystemType_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__OperatingSystem:
		return soap_out__jsdl__OperatingSystem(soap, "jsdl:OperatingSystem", id, (const struct jsdl__OperatingSystem_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__CandidateHosts:
		return soap_out__jsdl__CandidateHosts(soap, "jsdl:CandidateHosts", id, (const struct jsdl__CandidateHosts_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__Resources:
		return soap_out__jsdl__Resources(soap, "jsdl:Resources", id, (const struct jsdl__Resources_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__Application:
		return soap_out__jsdl__Application(soap, "jsdl:Application", id, (const struct jsdl__Application_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__JobIdentification:
		return soap_out__jsdl__JobIdentification(soap, "jsdl:JobIdentification", id, (const struct jsdl__JobIdentification_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__JobDescription:
		return soap_out__jsdl__JobDescription(soap, "jsdl:JobDescription", id, (const struct jsdl__JobDescription_USCOREType *)ptr, NULL);
	case SOAP_TYPE__jsdl__JobDefinition:
		return soap_out__jsdl__JobDefinition(soap, "jsdl:JobDefinition", id, (const struct jsdl__JobDefinition_USCOREType *)ptr, NULL);
	case SOAP_TYPE__wsa__ProblemAction:
		return soap_out__wsa__ProblemAction(soap, "wsa:ProblemAction", id, (const struct wsa__ProblemActionType *)ptr, NULL);
	case SOAP_TYPE__wsa__ProblemIRI:
		return soap_out__wsa__ProblemIRI(soap, "wsa:ProblemIRI", id, (const struct wsa__AttributedURIType *)ptr, NULL);
	case SOAP_TYPE__wsa__ProblemHeaderQName:
		return soap_out__wsa__ProblemHeaderQName(soap, "wsa:ProblemHeaderQName", id, (const struct wsa__AttributedQNameType *)ptr, NULL);
	case SOAP_TYPE__wsa__RetryAfter:
		return soap_out__wsa__RetryAfter(soap, "wsa:RetryAfter", id, (const struct wsa__AttributedUnsignedLongType *)ptr, NULL);
	case SOAP_TYPE__wsa__Action:
		return soap_out__wsa__Action(soap, "wsa:Action", id, (const struct wsa__AttributedURIType *)ptr, NULL);
	case SOAP_TYPE__wsa__To:
		return soap_out__wsa__To(soap, "wsa:To", id, (const struct wsa__AttributedURIType *)ptr, NULL);
	case SOAP_TYPE__wsa__FaultTo:
		return soap_out__wsa__FaultTo(soap, "wsa:FaultTo", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa__From:
		return soap_out__wsa__From(soap, "wsa:From", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa__ReplyTo:
		return soap_out__wsa__ReplyTo(soap, "wsa:ReplyTo", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa__RelatesTo:
		return soap_out__wsa__RelatesTo(soap, "wsa:RelatesTo", id, (const struct wsa__RelatesToType *)ptr, NULL);
	case SOAP_TYPE__wsa__MessageID:
		return soap_out__wsa__MessageID(soap, "wsa:MessageID", id, (const struct wsa__AttributedURIType *)ptr, NULL);
	case SOAP_TYPE__wsa__Metadata:
		return soap_out__wsa__Metadata(soap, "wsa:Metadata", id, (const struct wsa__MetadataType *)ptr, NULL);
	case SOAP_TYPE__wsa__ReferenceParameters:
		return soap_out__wsa__ReferenceParameters(soap, "wsa:ReferenceParameters", id, (const struct wsa__ReferenceParametersType *)ptr, NULL);
	case SOAP_TYPE__wsa__EndpointReference:
		return soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__bes__ActivityStatus:
		return soap_out__bes__ActivityStatus(soap, "bes:ActivityStatus", id, (const struct bes__ActivityStatusType *)ptr, NULL);
	case SOAP_TYPE__bes__ActivityDocument:
		return soap_out__bes__ActivityDocument(soap, "bes:ActivityDocument", id, (const struct bes__ActivityDocumentType *)ptr, NULL);
	case SOAP_TYPE__bes__FactoryResourceAttributesDocument:
		return soap_out__bes__FactoryResourceAttributesDocument(soap, "bes:FactoryResourceAttributesDocument", id, (const struct bes__FactoryResourceAttributesDocumentType *)ptr, NULL);
	case SOAP_TYPE__bes__BasicResourceAttributesDocument:
		return soap_out__bes__BasicResourceAttributesDocument(soap, "bes:BasicResourceAttributesDocument", id, (const struct bes__BasicResourceAttributesDocumentType *)ptr, NULL);
	case SOAP_TYPE__bes__InvalidRequestMessageFault:
		return soap_out__bes__InvalidRequestMessageFault(soap, "bes:InvalidRequestMessageFault", id, (const struct bes__InvalidRequestMessageFaultType *)ptr, NULL);
	case SOAP_TYPE__bes__InvalidActivityIdentifierFault:
		return soap_out__bes__InvalidActivityIdentifierFault(soap, "bes:InvalidActivityIdentifierFault", id, (const struct bes__InvalidActivityIdentifierFaultType *)ptr, NULL);
	case SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault:
		return soap_out__bes__OperationWillBeAppliedEventuallyFault(soap, "bes:OperationWillBeAppliedEventuallyFault", id, (const struct bes__OperationWillBeAppliedEventuallyFaultType *)ptr, NULL);
	case SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault:
		return soap_out__bes__CantApplyOperationToCurrentStateFault(soap, "bes:CantApplyOperationToCurrentStateFault", id, (const struct bes__CantApplyOperationToCurrentStateFaultType *)ptr, NULL);
	case SOAP_TYPE__bes__UnsupportedFeatureFault:
		return soap_out__bes__UnsupportedFeatureFault(soap, "bes:UnsupportedFeatureFault", id, (const struct bes__UnsupportedFeatureFaultType *)ptr, NULL);
	case SOAP_TYPE__bes__NotAcceptingNewActivitiesFault:
		return soap_out__bes__NotAcceptingNewActivitiesFault(soap, "bes:NotAcceptingNewActivitiesFault", id, (const struct bes__NotAcceptingNewActivitiesFaultType *)ptr, NULL);
	case SOAP_TYPE__bes__NotAuthorizedFault:
		return soap_out__bes__NotAuthorizedFault(soap, "bes:NotAuthorizedFault", id, (const struct bes__NotAuthorizedFaultType *)ptr, NULL);
	case SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse:
		return soap_out__bes__GetFactoryAttributesDocumentResponse(soap, "bes:GetFactoryAttributesDocumentResponse", id, (const struct bes__GetFactoryAttributesDocumentResponseType *)ptr, NULL);
	case SOAP_TYPE__bes__GetFactoryAttributesDocument:
		return soap_out__bes__GetFactoryAttributesDocument(soap, "bes:GetFactoryAttributesDocument", id, (const struct bes__GetFactoryAttributesDocumentType *)ptr, NULL);
	case SOAP_TYPE__bes__GetActivityDocumentsResponse:
		return soap_out__bes__GetActivityDocumentsResponse(soap, "bes:GetActivityDocumentsResponse", id, (const struct bes__GetActivityDocumentsResponseType *)ptr, NULL);
	case SOAP_TYPE__bes__GetActivityDocuments:
		return soap_out__bes__GetActivityDocuments(soap, "bes:GetActivityDocuments", id, (const struct bes__GetActivityDocumentsType *)ptr, NULL);
	case SOAP_TYPE__bes__TerminateActivitiesResponse:
		return soap_out__bes__TerminateActivitiesResponse(soap, "bes:TerminateActivitiesResponse", id, (const struct bes__TerminateActivitiesResponseType *)ptr, NULL);
	case SOAP_TYPE__bes__TerminateActivities:
		return soap_out__bes__TerminateActivities(soap, "bes:TerminateActivities", id, (const struct bes__TerminateActivitiesType *)ptr, NULL);
	case SOAP_TYPE__bes__GetActivityStatusesResponse:
		return soap_out__bes__GetActivityStatusesResponse(soap, "bes:GetActivityStatusesResponse", id, (const struct bes__GetActivityStatusesResponseType *)ptr, NULL);
	case SOAP_TYPE__bes__GetActivityStatuses:
		return soap_out__bes__GetActivityStatuses(soap, "bes:GetActivityStatuses", id, (const struct bes__GetActivityStatusesType *)ptr, NULL);
	case SOAP_TYPE__bes__CreateActivityResponse:
		return soap_out__bes__CreateActivityResponse(soap, "bes:CreateActivityResponse", id, (const struct bes__CreateActivityResponseType *)ptr, NULL);
	case SOAP_TYPE__bes__CreateActivity:
		return soap_out__bes__CreateActivity(soap, "bes:CreateActivity", id, (const struct bes__CreateActivityType *)ptr, NULL);
	case SOAP_TYPE_posix__POSIXApplication_USCOREType:
		return soap_out_posix__POSIXApplication_USCOREType(soap, tag, id, (const struct posix__POSIXApplication_USCOREType *)ptr, "posix:POSIXApplication_Type");
	case SOAP_TYPE_posix__GroupName_USCOREType:
		return soap_out_posix__GroupName_USCOREType(soap, tag, id, (const struct posix__GroupName_USCOREType *)ptr, "posix:GroupName_Type");
	case SOAP_TYPE_posix__UserName_USCOREType:
		return soap_out_posix__UserName_USCOREType(soap, tag, id, (const struct posix__UserName_USCOREType *)ptr, "posix:UserName_Type");
	case SOAP_TYPE_posix__Limits_USCOREType:
		return soap_out_posix__Limits_USCOREType(soap, tag, id, (const struct posix__Limits_USCOREType *)ptr, "posix:Limits_Type");
	case SOAP_TYPE_posix__DirectoryName_USCOREType:
		return soap_out_posix__DirectoryName_USCOREType(soap, tag, id, (const struct posix__DirectoryName_USCOREType *)ptr, "posix:DirectoryName_Type");
	case SOAP_TYPE_posix__FileName_USCOREType:
		return soap_out_posix__FileName_USCOREType(soap, tag, id, (const struct posix__FileName_USCOREType *)ptr, "posix:FileName_Type");
	case SOAP_TYPE_posix__Argument_USCOREType:
		return soap_out_posix__Argument_USCOREType(soap, tag, id, (const struct posix__Argument_USCOREType *)ptr, "posix:Argument_Type");
	case SOAP_TYPE_posix__Environment_USCOREType:
		return soap_out_posix__Environment_USCOREType(soap, tag, id, (const struct posix__Environment_USCOREType *)ptr, "posix:Environment_Type");
	case SOAP_TYPE_app__HPCProfileApplication_USCOREType:
		return soap_out_app__HPCProfileApplication_USCOREType(soap, tag, id, (const struct app__HPCProfileApplication_USCOREType *)ptr, "app:HPCProfileApplication_Type");
	case SOAP_TYPE_app__UserName_USCOREType:
		return soap_out_app__UserName_USCOREType(soap, tag, id, (const struct app__UserName_USCOREType *)ptr, "app:UserName_Type");
	case SOAP_TYPE_app__DirectoryName_USCOREType:
		return soap_out_app__DirectoryName_USCOREType(soap, tag, id, (const struct app__DirectoryName_USCOREType *)ptr, "app:DirectoryName_Type");
	case SOAP_TYPE_app__FileName_USCOREType:
		return soap_out_app__FileName_USCOREType(soap, tag, id, (const struct app__FileName_USCOREType *)ptr, "app:FileName_Type");
	case SOAP_TYPE_app__Argument_USCOREType:
		return soap_out_app__Argument_USCOREType(soap, tag, id, (const struct app__Argument_USCOREType *)ptr, "app:Argument_Type");
	case SOAP_TYPE_app__Environment_USCOREType:
		return soap_out_app__Environment_USCOREType(soap, tag, id, (const struct app__Environment_USCOREType *)ptr, "app:Environment_Type");
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		return soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, (const struct jsdl__SourceTarget_USCOREType *)ptr, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		return soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, (const struct jsdl__DataStaging_USCOREType *)ptr, "jsdl:DataStaging_Type");
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		return soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, (const struct jsdl__OperatingSystemType_USCOREType *)ptr, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		return soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, (const struct jsdl__OperatingSystem_USCOREType *)ptr, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		return soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, (const struct jsdl__FileSystem_USCOREType *)ptr, "jsdl:FileSystem_Type");
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		return soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, (const struct jsdl__CPUArchitecture_USCOREType *)ptr, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		return soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, (const struct jsdl__CandidateHosts_USCOREType *)ptr, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		return soap_out_jsdl__Resources_USCOREType(soap, tag, id, (const struct jsdl__Resources_USCOREType *)ptr, "jsdl:Resources_Type");
	case SOAP_TYPE_jsdl__Application_USCOREType:
		return soap_out_jsdl__Application_USCOREType(soap, tag, id, (const struct jsdl__Application_USCOREType *)ptr, "jsdl:Application_Type");
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		return soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, (const struct jsdl__JobIdentification_USCOREType *)ptr, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		return soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, (const struct jsdl__JobDescription_USCOREType *)ptr, "jsdl:JobDescription_Type");
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		return soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, (const struct jsdl__JobDefinition_USCOREType *)ptr, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		return soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, (const struct jsdl__RangeValue_USCOREType *)ptr, "jsdl:RangeValue_Type");
	case SOAP_TYPE_jsdl__Range_USCOREType:
		return soap_out_jsdl__Range_USCOREType(soap, tag, id, (const struct jsdl__Range_USCOREType *)ptr, "jsdl:Range_Type");
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		return soap_out_jsdl__Exact_USCOREType(soap, tag, id, (const struct jsdl__Exact_USCOREType *)ptr, "jsdl:Exact_Type");
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		return soap_out_jsdl__Boundary_USCOREType(soap, tag, id, (const struct jsdl__Boundary_USCOREType *)ptr, "jsdl:Boundary_Type");
	case SOAP_TYPE_wsa__ProblemActionType:
		return soap_out_wsa__ProblemActionType(soap, tag, id, (const struct wsa__ProblemActionType *)ptr, "wsa:ProblemActionType");
	case SOAP_TYPE_wsa__AttributedQNameType:
		return soap_out_wsa__AttributedQNameType(soap, tag, id, (const struct wsa__AttributedQNameType *)ptr, "wsa:AttributedQNameType");
	case SOAP_TYPE_wsa__AttributedUnsignedLongType:
		return soap_out_wsa__AttributedUnsignedLongType(soap, tag, id, (const struct wsa__AttributedUnsignedLongType *)ptr, "wsa:AttributedUnsignedLongType");
	case SOAP_TYPE_wsa__AttributedURIType:
		return soap_out_wsa__AttributedURIType(soap, tag, id, (const struct wsa__AttributedURIType *)ptr, "wsa:AttributedURIType");
	case SOAP_TYPE_wsa__RelatesToType:
		return soap_out_wsa__RelatesToType(soap, tag, id, (const struct wsa__RelatesToType *)ptr, "wsa:RelatesToType");
	case SOAP_TYPE_wsa__MetadataType:
		return soap_out_wsa__MetadataType(soap, tag, id, (const struct wsa__MetadataType *)ptr, "wsa:MetadataType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_out_wsa__ReferenceParametersType(soap, tag, id, (const struct wsa__ReferenceParametersType *)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_out_wsa__EndpointReferenceType(soap, tag, id, (const struct wsa__EndpointReferenceType *)ptr, "wsa:EndpointReferenceType");
	case SOAP_TYPE_bes__TerminateActivityResponseType:
		return soap_out_bes__TerminateActivityResponseType(soap, tag, id, (const struct bes__TerminateActivityResponseType *)ptr, "bes:TerminateActivityResponseType");
	case SOAP_TYPE_bes__GetActivityDocumentResponseType:
		return soap_out_bes__GetActivityDocumentResponseType(soap, tag, id, (const struct bes__GetActivityDocumentResponseType *)ptr, "bes:GetActivityDocumentResponseType");
	case SOAP_TYPE_bes__GetActivityStatusResponseType:
		return soap_out_bes__GetActivityStatusResponseType(soap, tag, id, (const struct bes__GetActivityStatusResponseType *)ptr, "bes:GetActivityStatusResponseType");
	case SOAP_TYPE_bes__ActivityStatusType:
		return soap_out_bes__ActivityStatusType(soap, tag, id, (const struct bes__ActivityStatusType *)ptr, "bes:ActivityStatusType");
	case SOAP_TYPE_bes__ActivityDocumentType:
		return soap_out_bes__ActivityDocumentType(soap, tag, id, (const struct bes__ActivityDocumentType *)ptr, "bes:ActivityDocumentType");
	case SOAP_TYPE_bes__FactoryResourceAttributesDocumentType:
		return soap_out_bes__FactoryResourceAttributesDocumentType(soap, tag, id, (const struct bes__FactoryResourceAttributesDocumentType *)ptr, "bes:FactoryResourceAttributesDocumentType");
	case SOAP_TYPE_bes__BasicResourceAttributesDocumentType:
		return soap_out_bes__BasicResourceAttributesDocumentType(soap, tag, id, (const struct bes__BasicResourceAttributesDocumentType *)ptr, "bes:BasicResourceAttributesDocumentType");
	case SOAP_TYPE_bes__InvalidRequestMessageFaultType:
		return soap_out_bes__InvalidRequestMessageFaultType(soap, tag, id, (const struct bes__InvalidRequestMessageFaultType *)ptr, "bes:InvalidRequestMessageFaultType");
	case SOAP_TYPE_bes__InvalidActivityIdentifierFaultType:
		return soap_out_bes__InvalidActivityIdentifierFaultType(soap, tag, id, (const struct bes__InvalidActivityIdentifierFaultType *)ptr, "bes:InvalidActivityIdentifierFaultType");
	case SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType:
		return soap_out_bes__OperationWillBeAppliedEventuallyFaultType(soap, tag, id, (const struct bes__OperationWillBeAppliedEventuallyFaultType *)ptr, "bes:OperationWillBeAppliedEventuallyFaultType");
	case SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType:
		return soap_out_bes__CantApplyOperationToCurrentStateFaultType(soap, tag, id, (const struct bes__CantApplyOperationToCurrentStateFaultType *)ptr, "bes:CantApplyOperationToCurrentStateFaultType");
	case SOAP_TYPE_bes__UnsupportedFeatureFaultType:
		return soap_out_bes__UnsupportedFeatureFaultType(soap, tag, id, (const struct bes__UnsupportedFeatureFaultType *)ptr, "bes:UnsupportedFeatureFaultType");
	case SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType:
		return soap_out_bes__NotAcceptingNewActivitiesFaultType(soap, tag, id, (const struct bes__NotAcceptingNewActivitiesFaultType *)ptr, "bes:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_bes__NotAuthorizedFaultType:
		return soap_out_bes__NotAuthorizedFaultType(soap, tag, id, (const struct bes__NotAuthorizedFaultType *)ptr, "bes:NotAuthorizedFaultType");
	case SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType:
		return soap_out_bes__GetFactoryAttributesDocumentResponseType(soap, tag, id, (const struct bes__GetFactoryAttributesDocumentResponseType *)ptr, "bes:GetFactoryAttributesDocumentResponseType");
	case SOAP_TYPE_bes__GetFactoryAttributesDocumentType:
		return soap_out_bes__GetFactoryAttributesDocumentType(soap, tag, id, (const struct bes__GetFactoryAttributesDocumentType *)ptr, "bes:GetFactoryAttributesDocumentType");
	case SOAP_TYPE_bes__GetActivityDocumentsResponseType:
		return soap_out_bes__GetActivityDocumentsResponseType(soap, tag, id, (const struct bes__GetActivityDocumentsResponseType *)ptr, "bes:GetActivityDocumentsResponseType");
	case SOAP_TYPE_bes__GetActivityDocumentsType:
		return soap_out_bes__GetActivityDocumentsType(soap, tag, id, (const struct bes__GetActivityDocumentsType *)ptr, "bes:GetActivityDocumentsType");
	case SOAP_TYPE_bes__TerminateActivitiesResponseType:
		return soap_out_bes__TerminateActivitiesResponseType(soap, tag, id, (const struct bes__TerminateActivitiesResponseType *)ptr, "bes:TerminateActivitiesResponseType");
	case SOAP_TYPE_bes__TerminateActivitiesType:
		return soap_out_bes__TerminateActivitiesType(soap, tag, id, (const struct bes__TerminateActivitiesType *)ptr, "bes:TerminateActivitiesType");
	case SOAP_TYPE_bes__GetActivityStatusesResponseType:
		return soap_out_bes__GetActivityStatusesResponseType(soap, tag, id, (const struct bes__GetActivityStatusesResponseType *)ptr, "bes:GetActivityStatusesResponseType");
	case SOAP_TYPE_bes__GetActivityStatusesType:
		return soap_out_bes__GetActivityStatusesType(soap, tag, id, (const struct bes__GetActivityStatusesType *)ptr, "bes:GetActivityStatusesType");
	case SOAP_TYPE_bes__CreateActivityResponseType:
		return soap_out_bes__CreateActivityResponseType(soap, tag, id, (const struct bes__CreateActivityResponseType *)ptr, "bes:CreateActivityResponseType");
	case SOAP_TYPE_bes__CreateActivityType:
		return soap_out_bes__CreateActivityType(soap, tag, id, (const struct bes__CreateActivityType *)ptr, "bes:CreateActivityType");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_out_xsd__anyAttribute(soap, tag, id, (const struct soap_dom_attribute *)ptr, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_out_xsd__anyType(soap, tag, id, (const struct soap_dom_element *)ptr, "xsd:anyType");
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
	case SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentResponseType:
		return soap_out_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, tag, id, (struct bes__GetFactoryAttributesDocumentResponseType *const*)ptr, "bes:GetFactoryAttributesDocumentResponseType");
	case SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentType:
		return soap_out_PointerTobes__GetFactoryAttributesDocumentType(soap, tag, id, (struct bes__GetFactoryAttributesDocumentType *const*)ptr, "bes:GetFactoryAttributesDocumentType");
	case SOAP_TYPE_PointerTobes__GetActivityDocumentsResponseType:
		return soap_out_PointerTobes__GetActivityDocumentsResponseType(soap, tag, id, (struct bes__GetActivityDocumentsResponseType *const*)ptr, "bes:GetActivityDocumentsResponseType");
	case SOAP_TYPE_PointerTobes__TerminateActivitiesResponseType:
		return soap_out_PointerTobes__TerminateActivitiesResponseType(soap, tag, id, (struct bes__TerminateActivitiesResponseType *const*)ptr, "bes:TerminateActivitiesResponseType");
	case SOAP_TYPE_PointerTobes__GetActivityStatusesResponseType:
		return soap_out_PointerTobes__GetActivityStatusesResponseType(soap, tag, id, (struct bes__GetActivityStatusesResponseType *const*)ptr, "bes:GetActivityStatusesResponseType");
	case SOAP_TYPE_PointerTobes__CreateActivityResponseType:
		return soap_out_PointerTobes__CreateActivityResponseType(soap, tag, id, (struct bes__CreateActivityResponseType *const*)ptr, "bes:CreateActivityResponseType");
	case SOAP_TYPE_PointerTobes__CreateActivityType:
		return soap_out_PointerTobes__CreateActivityType(soap, tag, id, (struct bes__CreateActivityType *const*)ptr, "bes:CreateActivityType");
	case SOAP_TYPE_PointerTobes__UnsupportedFeatureFaultType:
		return soap_out_PointerTobes__UnsupportedFeatureFaultType(soap, tag, id, (struct bes__UnsupportedFeatureFaultType *const*)ptr, "bes:UnsupportedFeatureFaultType");
	case SOAP_TYPE_PointerTobes__NotAuthorizedFaultType:
		return soap_out_PointerTobes__NotAuthorizedFaultType(soap, tag, id, (struct bes__NotAuthorizedFaultType *const*)ptr, "bes:NotAuthorizedFaultType");
	case SOAP_TYPE_PointerTobes__NotAcceptingNewActivitiesFaultType:
		return soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, tag, id, (struct bes__NotAcceptingNewActivitiesFaultType *const*)ptr, "bes:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_PointerTobes__InvalidRequestMessageFaultType:
		return soap_out_PointerTobes__InvalidRequestMessageFaultType(soap, tag, id, (struct bes__InvalidRequestMessageFaultType *const*)ptr, "bes:InvalidRequestMessageFaultType");
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_out_PointerTo_wsa__FaultTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_out_PointerTo_wsa__From(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, (struct wsa__RelatesToType *const*)ptr, "wsa:RelatesTo");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE__jsdl__URI:
		return soap_out_string(soap, "jsdl:URI", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__FilesystemName:
		return soap_out_string(soap, "jsdl:FilesystemName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__FileName:
		return soap_out_string(soap, "jsdl:FileName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__MountPoint:
		return soap_out_string(soap, "jsdl:MountPoint", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__OperatingSystemVersion:
		return soap_out_string(soap, "jsdl:OperatingSystemVersion", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__HostName:
		return soap_out_string(soap, "jsdl:HostName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__ApplicationVersion:
		return soap_out_string(soap, "jsdl:ApplicationVersion", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__ApplicationName:
		return soap_out_string(soap, "jsdl:ApplicationName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__JobProject:
		return soap_out_string(soap, "jsdl:JobProject", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__JobAnnotation:
		return soap_out_string(soap, "jsdl:JobAnnotation", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__Description:
		return soap_out_string(soap, "jsdl:Description", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__jsdl__JobName:
		return soap_out_string(soap, "jsdl:JobName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_PointerToposix__GroupName_USCOREType:
		return soap_out_PointerToposix__GroupName_USCOREType(soap, tag, id, (struct posix__GroupName_USCOREType *const*)ptr, "posix:GroupName_Type");
	case SOAP_TYPE_PointerToposix__UserName_USCOREType:
		return soap_out_PointerToposix__UserName_USCOREType(soap, tag, id, (struct posix__UserName_USCOREType *const*)ptr, "posix:UserName_Type");
	case SOAP_TYPE_PointerToposix__Limits_USCOREType:
		return soap_out_PointerToposix__Limits_USCOREType(soap, tag, id, (struct posix__Limits_USCOREType *const*)ptr, "posix:Limits_Type");
	case SOAP_TYPE_PointerToposix__Environment_USCOREType:
		return soap_out_PointerToposix__Environment_USCOREType(soap, tag, id, (struct posix__Environment_USCOREType *const*)ptr, "posix:Environment_Type");
	case SOAP_TYPE_PointerToposix__DirectoryName_USCOREType:
		return soap_out_PointerToposix__DirectoryName_USCOREType(soap, tag, id, (struct posix__DirectoryName_USCOREType *const*)ptr, "posix:DirectoryName_Type");
	case SOAP_TYPE_PointerToposix__Argument_USCOREType:
		return soap_out_PointerToposix__Argument_USCOREType(soap, tag, id, (struct posix__Argument_USCOREType *const*)ptr, "posix:Argument_Type");
	case SOAP_TYPE_PointerToposix__FileName_USCOREType:
		return soap_out_PointerToposix__FileName_USCOREType(soap, tag, id, (struct posix__FileName_USCOREType *const*)ptr, "posix:FileName_Type");
	case SOAP_TYPE_PointerToapp__UserName_USCOREType:
		return soap_out_PointerToapp__UserName_USCOREType(soap, tag, id, (struct app__UserName_USCOREType *const*)ptr, "app:UserName_Type");
	case SOAP_TYPE_PointerToapp__Environment_USCOREType:
		return soap_out_PointerToapp__Environment_USCOREType(soap, tag, id, (struct app__Environment_USCOREType *const*)ptr, "app:Environment_Type");
	case SOAP_TYPE_PointerToapp__DirectoryName_USCOREType:
		return soap_out_PointerToapp__DirectoryName_USCOREType(soap, tag, id, (struct app__DirectoryName_USCOREType *const*)ptr, "app:DirectoryName_Type");
	case SOAP_TYPE_PointerToapp__Argument_USCOREType:
		return soap_out_PointerToapp__Argument_USCOREType(soap, tag, id, (struct app__Argument_USCOREType *const*)ptr, "app:Argument_Type");
	case SOAP_TYPE_PointerToapp__FileName_USCOREType:
		return soap_out_PointerToapp__FileName_USCOREType(soap, tag, id, (struct app__FileName_USCOREType *const*)ptr, "app:FileName_Type");
	case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
		return soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, (struct jsdl__SourceTarget_USCOREType *const*)ptr, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, (struct jsdl__OperatingSystemType_USCOREType *const*)ptr, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, (enum jsdl__FileSystemTypeEnumeration *const*)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
		return soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, (struct jsdl__RangeValue_USCOREType *const*)ptr, "jsdl:RangeValue_Type");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
		return soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, (struct jsdl__FileSystem_USCOREType *const*)ptr, "jsdl:FileSystem_Type");
	case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, (struct jsdl__CandidateHosts_USCOREType *const*)ptr, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
		return soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, (struct jsdl__DataStaging_USCOREType *const*)ptr, "jsdl:DataStaging_Type");
	case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
		return soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, (struct jsdl__Resources_USCOREType *const*)ptr, "jsdl:Resources_Type");
	case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
		return soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, (struct jsdl__Application_USCOREType *const*)ptr, "jsdl:Application_Type");
	case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
		return soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, (struct jsdl__JobIdentification_USCOREType *const*)ptr, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
		return soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, (struct jsdl__JobDescription_USCOREType *const*)ptr, "jsdl:JobDescription_Type");
	case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
		return soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, (struct jsdl__Range_USCOREType *const*)ptr, "jsdl:Range_Type");
	case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
		return soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, (struct jsdl__Exact_USCOREType *const*)ptr, "jsdl:Exact_Type");
	case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
		return soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, (struct jsdl__Boundary_USCOREType *const*)ptr, "jsdl:Boundary_Type");
	case SOAP_TYPE_PointerTowsa__MetadataType:
		return soap_out_PointerTowsa__MetadataType(soap, tag, id, (struct wsa__MetadataType *const*)ptr, "wsa:MetadataType");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, (struct wsa__ReferenceParametersType *const*)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__AttributedURIType:
		return soap_out_PointerTowsa__AttributedURIType(soap, tag, id, (struct wsa__AttributedURIType *const*)ptr, "wsa:AttributedURIType");
	case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
		return soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, (struct jsdl__JobDefinition_USCOREType *const*)ptr, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (char **const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTowsa__EndpointReferenceType:
		return soap_out_PointerTowsa__EndpointReferenceType(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTobes__BasicResourceAttributesDocumentType:
		return soap_out_PointerTobes__BasicResourceAttributesDocumentType(soap, tag, id, (struct bes__BasicResourceAttributesDocumentType *const*)ptr, "bes:BasicResourceAttributesDocumentType");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, (struct jsdl__CPUArchitecture_USCOREType *const*)ptr, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, (struct jsdl__OperatingSystem_USCOREType *const*)ptr, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_PointerTobes__ActivityStatusType:
		return soap_out_PointerTobes__ActivityStatusType(soap, tag, id, (struct bes__ActivityStatusType *const*)ptr, "bes:ActivityStatusType");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTobes__TerminateActivityResponseType:
		return soap_out_PointerTobes__TerminateActivityResponseType(soap, tag, id, (struct bes__TerminateActivityResponseType *const*)ptr, "bes:TerminateActivityResponseType");
	case SOAP_TYPE_jsdl__Description_USCOREType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "jsdl:Description_Type");
	case SOAP_TYPE_wsa__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa:RelationshipTypeOpenEnum");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (struct soap_dom_element *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_xsd__normalizedString:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:normalizedString");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__ID:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:ID");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___bes__GetFactoryAttributesDocument:
		soap_serialize___bes__GetFactoryAttributesDocument(soap, (const struct __bes__GetFactoryAttributesDocument *)ptr);
		break;
	case SOAP_TYPE___bes__GetActivityDocuments:
		soap_serialize___bes__GetActivityDocuments(soap, (const struct __bes__GetActivityDocuments *)ptr);
		break;
	case SOAP_TYPE___bes__TerminateActivities:
		soap_serialize___bes__TerminateActivities(soap, (const struct __bes__TerminateActivities *)ptr);
		break;
	case SOAP_TYPE___bes__GetActivityStatuses:
		soap_serialize___bes__GetActivityStatuses(soap, (const struct __bes__GetActivityStatuses *)ptr);
		break;
	case SOAP_TYPE___bes__CreateActivity:
		soap_serialize___bes__CreateActivity(soap, (const struct __bes__CreateActivity *)ptr);
		break;
	case SOAP_TYPE__posix__GroupName:
		soap_serialize__posix__GroupName(soap, (const struct posix__GroupName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__UserName:
		soap_serialize__posix__UserName(soap, (const struct posix__UserName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__ThreadCountLimit:
		soap_serialize__posix__ThreadCountLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__VirtualMemoryLimit:
		soap_serialize__posix__VirtualMemoryLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__ProcessCountLimit:
		soap_serialize__posix__ProcessCountLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__CPUTimeLimit:
		soap_serialize__posix__CPUTimeLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__StackSizeLimit:
		soap_serialize__posix__StackSizeLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__PipeSizeLimit:
		soap_serialize__posix__PipeSizeLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__OpenDescriptorsLimit:
		soap_serialize__posix__OpenDescriptorsLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__MemoryLimit:
		soap_serialize__posix__MemoryLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__LockedMemoryLimit:
		soap_serialize__posix__LockedMemoryLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__DataSegmentLimit:
		soap_serialize__posix__DataSegmentLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__CoreDumpLimit:
		soap_serialize__posix__CoreDumpLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__FileSizeLimit:
		soap_serialize__posix__FileSizeLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__WallTimeLimit:
		soap_serialize__posix__WallTimeLimit(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__Environment:
		soap_serialize__posix__Environment(soap, (const struct posix__Environment_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__WorkingDirectory:
		soap_serialize__posix__WorkingDirectory(soap, (const struct posix__DirectoryName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__Error:
		soap_serialize__posix__Error(soap, (const struct posix__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__Output:
		soap_serialize__posix__Output(soap, (const struct posix__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__Input:
		soap_serialize__posix__Input(soap, (const struct posix__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__Argument:
		soap_serialize__posix__Argument(soap, (const struct posix__Argument_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__Executable:
		soap_serialize__posix__Executable(soap, (const struct posix__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__posix__POSIXApplication:
		soap_serialize__posix__POSIXApplication(soap, (const struct posix__POSIXApplication_USCOREType *)ptr);
		break;
	case SOAP_TYPE__app__UserName:
		soap_serialize__app__UserName(soap, (const struct app__UserName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__app__Environment:
		soap_serialize__app__Environment(soap, (const struct app__Environment_USCOREType *)ptr);
		break;
	case SOAP_TYPE__app__WorkingDirectory:
		soap_serialize__app__WorkingDirectory(soap, (const struct app__DirectoryName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__app__Error:
		soap_serialize__app__Error(soap, (const struct app__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__app__Output:
		soap_serialize__app__Output(soap, (const struct app__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__app__Input:
		soap_serialize__app__Input(soap, (const struct app__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__app__Argument:
		soap_serialize__app__Argument(soap, (const struct app__Argument_USCOREType *)ptr);
		break;
	case SOAP_TYPE__app__Executable:
		soap_serialize__app__Executable(soap, (const struct app__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE__app__HPCProfileApplication:
		soap_serialize__app__HPCProfileApplication(soap, (const struct app__HPCProfileApplication_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__Target:
		soap_serialize__jsdl__Target(soap, (const struct jsdl__SourceTarget_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__Source:
		soap_serialize__jsdl__Source(soap, (const struct jsdl__SourceTarget_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__DataStaging:
		soap_serialize__jsdl__DataStaging(soap, (const struct jsdl__DataStaging_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__TotalResourceCount:
		soap_serialize__jsdl__TotalResourceCount(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__TotalDiskSpace:
		soap_serialize__jsdl__TotalDiskSpace(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__TotalVirtualMemory:
		soap_serialize__jsdl__TotalVirtualMemory(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__TotalPhysicalMemory:
		soap_serialize__jsdl__TotalPhysicalMemory(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__TotalCPUCount:
		soap_serialize__jsdl__TotalCPUCount(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__TotalCPUTime:
		soap_serialize__jsdl__TotalCPUTime(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__IndividualDiskSpace:
		soap_serialize__jsdl__IndividualDiskSpace(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__IndividualNetworkBandwidth:
		soap_serialize__jsdl__IndividualNetworkBandwidth(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__IndividualVirtualMemory:
		soap_serialize__jsdl__IndividualVirtualMemory(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__IndividualPhysicalMemory:
		soap_serialize__jsdl__IndividualPhysicalMemory(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__IndividualCPUCount:
		soap_serialize__jsdl__IndividualCPUCount(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__IndividualCPUSpeed:
		soap_serialize__jsdl__IndividualCPUSpeed(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__IndividualCPUTime:
		soap_serialize__jsdl__IndividualCPUTime(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__DiskSpace:
		soap_serialize__jsdl__DiskSpace(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__FileSystem:
		soap_serialize__jsdl__FileSystem(soap, (const struct jsdl__FileSystem_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__CPUArchitecture:
		soap_serialize__jsdl__CPUArchitecture(soap, (const struct jsdl__CPUArchitecture_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__OperatingSystemType:
		soap_serialize__jsdl__OperatingSystemType(soap, (const struct jsdl__OperatingSystemType_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__OperatingSystem:
		soap_serialize__jsdl__OperatingSystem(soap, (const struct jsdl__OperatingSystem_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__CandidateHosts:
		soap_serialize__jsdl__CandidateHosts(soap, (const struct jsdl__CandidateHosts_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__Resources:
		soap_serialize__jsdl__Resources(soap, (const struct jsdl__Resources_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__Application:
		soap_serialize__jsdl__Application(soap, (const struct jsdl__Application_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__JobIdentification:
		soap_serialize__jsdl__JobIdentification(soap, (const struct jsdl__JobIdentification_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__JobDescription:
		soap_serialize__jsdl__JobDescription(soap, (const struct jsdl__JobDescription_USCOREType *)ptr);
		break;
	case SOAP_TYPE__jsdl__JobDefinition:
		soap_serialize__jsdl__JobDefinition(soap, (const struct jsdl__JobDefinition_USCOREType *)ptr);
		break;
	case SOAP_TYPE__wsa__ProblemAction:
		soap_serialize__wsa__ProblemAction(soap, (const struct wsa__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa__ProblemIRI:
		soap_serialize__wsa__ProblemIRI(soap, (const struct wsa__AttributedURIType *)ptr);
		break;
	case SOAP_TYPE__wsa__ProblemHeaderQName:
		soap_serialize__wsa__ProblemHeaderQName(soap, (const struct wsa__AttributedQNameType *)ptr);
		break;
	case SOAP_TYPE__wsa__RetryAfter:
		soap_serialize__wsa__RetryAfter(soap, (const struct wsa__AttributedUnsignedLongType *)ptr);
		break;
	case SOAP_TYPE__wsa__Action:
		soap_serialize__wsa__Action(soap, (const struct wsa__AttributedURIType *)ptr);
		break;
	case SOAP_TYPE__wsa__To:
		soap_serialize__wsa__To(soap, (const struct wsa__AttributedURIType *)ptr);
		break;
	case SOAP_TYPE__wsa__FaultTo:
		soap_serialize__wsa__FaultTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__From:
		soap_serialize__wsa__From(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__ReplyTo:
		soap_serialize__wsa__ReplyTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__RelatesTo:
		soap_serialize__wsa__RelatesTo(soap, (const struct wsa__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa__MessageID:
		soap_serialize__wsa__MessageID(soap, (const struct wsa__AttributedURIType *)ptr);
		break;
	case SOAP_TYPE__wsa__Metadata:
		soap_serialize__wsa__Metadata(soap, (const struct wsa__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa__ReferenceParameters:
		soap_serialize__wsa__ReferenceParameters(soap, (const struct wsa__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa__EndpointReference:
		soap_serialize__wsa__EndpointReference(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__bes__ActivityStatus:
		soap_serialize__bes__ActivityStatus(soap, (const struct bes__ActivityStatusType *)ptr);
		break;
	case SOAP_TYPE__bes__ActivityDocument:
		soap_serialize__bes__ActivityDocument(soap, (const struct bes__ActivityDocumentType *)ptr);
		break;
	case SOAP_TYPE__bes__FactoryResourceAttributesDocument:
		soap_serialize__bes__FactoryResourceAttributesDocument(soap, (const struct bes__FactoryResourceAttributesDocumentType *)ptr);
		break;
	case SOAP_TYPE__bes__BasicResourceAttributesDocument:
		soap_serialize__bes__BasicResourceAttributesDocument(soap, (const struct bes__BasicResourceAttributesDocumentType *)ptr);
		break;
	case SOAP_TYPE__bes__InvalidRequestMessageFault:
		soap_serialize__bes__InvalidRequestMessageFault(soap, (const struct bes__InvalidRequestMessageFaultType *)ptr);
		break;
	case SOAP_TYPE__bes__InvalidActivityIdentifierFault:
		soap_serialize__bes__InvalidActivityIdentifierFault(soap, (const struct bes__InvalidActivityIdentifierFaultType *)ptr);
		break;
	case SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault:
		soap_serialize__bes__OperationWillBeAppliedEventuallyFault(soap, (const struct bes__OperationWillBeAppliedEventuallyFaultType *)ptr);
		break;
	case SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault:
		soap_serialize__bes__CantApplyOperationToCurrentStateFault(soap, (const struct bes__CantApplyOperationToCurrentStateFaultType *)ptr);
		break;
	case SOAP_TYPE__bes__UnsupportedFeatureFault:
		soap_serialize__bes__UnsupportedFeatureFault(soap, (const struct bes__UnsupportedFeatureFaultType *)ptr);
		break;
	case SOAP_TYPE__bes__NotAcceptingNewActivitiesFault:
		soap_serialize__bes__NotAcceptingNewActivitiesFault(soap, (const struct bes__NotAcceptingNewActivitiesFaultType *)ptr);
		break;
	case SOAP_TYPE__bes__NotAuthorizedFault:
		soap_serialize__bes__NotAuthorizedFault(soap, (const struct bes__NotAuthorizedFaultType *)ptr);
		break;
	case SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse:
		soap_serialize__bes__GetFactoryAttributesDocumentResponse(soap, (const struct bes__GetFactoryAttributesDocumentResponseType *)ptr);
		break;
	case SOAP_TYPE__bes__GetFactoryAttributesDocument:
		soap_serialize__bes__GetFactoryAttributesDocument(soap, (const struct bes__GetFactoryAttributesDocumentType *)ptr);
		break;
	case SOAP_TYPE__bes__GetActivityDocumentsResponse:
		soap_serialize__bes__GetActivityDocumentsResponse(soap, (const struct bes__GetActivityDocumentsResponseType *)ptr);
		break;
	case SOAP_TYPE__bes__GetActivityDocuments:
		soap_serialize__bes__GetActivityDocuments(soap, (const struct bes__GetActivityDocumentsType *)ptr);
		break;
	case SOAP_TYPE__bes__TerminateActivitiesResponse:
		soap_serialize__bes__TerminateActivitiesResponse(soap, (const struct bes__TerminateActivitiesResponseType *)ptr);
		break;
	case SOAP_TYPE__bes__TerminateActivities:
		soap_serialize__bes__TerminateActivities(soap, (const struct bes__TerminateActivitiesType *)ptr);
		break;
	case SOAP_TYPE__bes__GetActivityStatusesResponse:
		soap_serialize__bes__GetActivityStatusesResponse(soap, (const struct bes__GetActivityStatusesResponseType *)ptr);
		break;
	case SOAP_TYPE__bes__GetActivityStatuses:
		soap_serialize__bes__GetActivityStatuses(soap, (const struct bes__GetActivityStatusesType *)ptr);
		break;
	case SOAP_TYPE__bes__CreateActivityResponse:
		soap_serialize__bes__CreateActivityResponse(soap, (const struct bes__CreateActivityResponseType *)ptr);
		break;
	case SOAP_TYPE__bes__CreateActivity:
		soap_serialize__bes__CreateActivity(soap, (const struct bes__CreateActivityType *)ptr);
		break;
	case SOAP_TYPE_posix__POSIXApplication_USCOREType:
		soap_serialize_posix__POSIXApplication_USCOREType(soap, (const struct posix__POSIXApplication_USCOREType *)ptr);
		break;
	case SOAP_TYPE_posix__GroupName_USCOREType:
		soap_serialize_posix__GroupName_USCOREType(soap, (const struct posix__GroupName_USCOREType *)ptr);
		break;
	case SOAP_TYPE_posix__UserName_USCOREType:
		soap_serialize_posix__UserName_USCOREType(soap, (const struct posix__UserName_USCOREType *)ptr);
		break;
	case SOAP_TYPE_posix__Limits_USCOREType:
		soap_serialize_posix__Limits_USCOREType(soap, (const struct posix__Limits_USCOREType *)ptr);
		break;
	case SOAP_TYPE_posix__DirectoryName_USCOREType:
		soap_serialize_posix__DirectoryName_USCOREType(soap, (const struct posix__DirectoryName_USCOREType *)ptr);
		break;
	case SOAP_TYPE_posix__FileName_USCOREType:
		soap_serialize_posix__FileName_USCOREType(soap, (const struct posix__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE_posix__Argument_USCOREType:
		soap_serialize_posix__Argument_USCOREType(soap, (const struct posix__Argument_USCOREType *)ptr);
		break;
	case SOAP_TYPE_posix__Environment_USCOREType:
		soap_serialize_posix__Environment_USCOREType(soap, (const struct posix__Environment_USCOREType *)ptr);
		break;
	case SOAP_TYPE_app__HPCProfileApplication_USCOREType:
		soap_serialize_app__HPCProfileApplication_USCOREType(soap, (const struct app__HPCProfileApplication_USCOREType *)ptr);
		break;
	case SOAP_TYPE_app__UserName_USCOREType:
		soap_serialize_app__UserName_USCOREType(soap, (const struct app__UserName_USCOREType *)ptr);
		break;
	case SOAP_TYPE_app__DirectoryName_USCOREType:
		soap_serialize_app__DirectoryName_USCOREType(soap, (const struct app__DirectoryName_USCOREType *)ptr);
		break;
	case SOAP_TYPE_app__FileName_USCOREType:
		soap_serialize_app__FileName_USCOREType(soap, (const struct app__FileName_USCOREType *)ptr);
		break;
	case SOAP_TYPE_app__Argument_USCOREType:
		soap_serialize_app__Argument_USCOREType(soap, (const struct app__Argument_USCOREType *)ptr);
		break;
	case SOAP_TYPE_app__Environment_USCOREType:
		soap_serialize_app__Environment_USCOREType(soap, (const struct app__Environment_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		soap_serialize_jsdl__SourceTarget_USCOREType(soap, (const struct jsdl__SourceTarget_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		soap_serialize_jsdl__DataStaging_USCOREType(soap, (const struct jsdl__DataStaging_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		soap_serialize_jsdl__OperatingSystemType_USCOREType(soap, (const struct jsdl__OperatingSystemType_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		soap_serialize_jsdl__OperatingSystem_USCOREType(soap, (const struct jsdl__OperatingSystem_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		soap_serialize_jsdl__FileSystem_USCOREType(soap, (const struct jsdl__FileSystem_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		soap_serialize_jsdl__CPUArchitecture_USCOREType(soap, (const struct jsdl__CPUArchitecture_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		soap_serialize_jsdl__CandidateHosts_USCOREType(soap, (const struct jsdl__CandidateHosts_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		soap_serialize_jsdl__Resources_USCOREType(soap, (const struct jsdl__Resources_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__Application_USCOREType:
		soap_serialize_jsdl__Application_USCOREType(soap, (const struct jsdl__Application_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		soap_serialize_jsdl__JobIdentification_USCOREType(soap, (const struct jsdl__JobIdentification_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		soap_serialize_jsdl__JobDescription_USCOREType(soap, (const struct jsdl__JobDescription_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		soap_serialize_jsdl__JobDefinition_USCOREType(soap, (const struct jsdl__JobDefinition_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		soap_serialize_jsdl__RangeValue_USCOREType(soap, (const struct jsdl__RangeValue_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__Range_USCOREType:
		soap_serialize_jsdl__Range_USCOREType(soap, (const struct jsdl__Range_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		soap_serialize_jsdl__Exact_USCOREType(soap, (const struct jsdl__Exact_USCOREType *)ptr);
		break;
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		soap_serialize_jsdl__Boundary_USCOREType(soap, (const struct jsdl__Boundary_USCOREType *)ptr);
		break;
	case SOAP_TYPE_wsa__ProblemActionType:
		soap_serialize_wsa__ProblemActionType(soap, (const struct wsa__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa__AttributedQNameType:
		soap_serialize_wsa__AttributedQNameType(soap, (const struct wsa__AttributedQNameType *)ptr);
		break;
	case SOAP_TYPE_wsa__AttributedUnsignedLongType:
		soap_serialize_wsa__AttributedUnsignedLongType(soap, (const struct wsa__AttributedUnsignedLongType *)ptr);
		break;
	case SOAP_TYPE_wsa__AttributedURIType:
		soap_serialize_wsa__AttributedURIType(soap, (const struct wsa__AttributedURIType *)ptr);
		break;
	case SOAP_TYPE_wsa__RelatesToType:
		soap_serialize_wsa__RelatesToType(soap, (const struct wsa__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa__MetadataType:
		soap_serialize_wsa__MetadataType(soap, (const struct wsa__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferenceParametersType:
		soap_serialize_wsa__ReferenceParametersType(soap, (const struct wsa__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		soap_serialize_wsa__EndpointReferenceType(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_bes__TerminateActivityResponseType:
		soap_serialize_bes__TerminateActivityResponseType(soap, (const struct bes__TerminateActivityResponseType *)ptr);
		break;
	case SOAP_TYPE_bes__GetActivityDocumentResponseType:
		soap_serialize_bes__GetActivityDocumentResponseType(soap, (const struct bes__GetActivityDocumentResponseType *)ptr);
		break;
	case SOAP_TYPE_bes__GetActivityStatusResponseType:
		soap_serialize_bes__GetActivityStatusResponseType(soap, (const struct bes__GetActivityStatusResponseType *)ptr);
		break;
	case SOAP_TYPE_bes__ActivityStatusType:
		soap_serialize_bes__ActivityStatusType(soap, (const struct bes__ActivityStatusType *)ptr);
		break;
	case SOAP_TYPE_bes__ActivityDocumentType:
		soap_serialize_bes__ActivityDocumentType(soap, (const struct bes__ActivityDocumentType *)ptr);
		break;
	case SOAP_TYPE_bes__FactoryResourceAttributesDocumentType:
		soap_serialize_bes__FactoryResourceAttributesDocumentType(soap, (const struct bes__FactoryResourceAttributesDocumentType *)ptr);
		break;
	case SOAP_TYPE_bes__BasicResourceAttributesDocumentType:
		soap_serialize_bes__BasicResourceAttributesDocumentType(soap, (const struct bes__BasicResourceAttributesDocumentType *)ptr);
		break;
	case SOAP_TYPE_bes__InvalidRequestMessageFaultType:
		soap_serialize_bes__InvalidRequestMessageFaultType(soap, (const struct bes__InvalidRequestMessageFaultType *)ptr);
		break;
	case SOAP_TYPE_bes__InvalidActivityIdentifierFaultType:
		soap_serialize_bes__InvalidActivityIdentifierFaultType(soap, (const struct bes__InvalidActivityIdentifierFaultType *)ptr);
		break;
	case SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType:
		soap_serialize_bes__OperationWillBeAppliedEventuallyFaultType(soap, (const struct bes__OperationWillBeAppliedEventuallyFaultType *)ptr);
		break;
	case SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType:
		soap_serialize_bes__CantApplyOperationToCurrentStateFaultType(soap, (const struct bes__CantApplyOperationToCurrentStateFaultType *)ptr);
		break;
	case SOAP_TYPE_bes__UnsupportedFeatureFaultType:
		soap_serialize_bes__UnsupportedFeatureFaultType(soap, (const struct bes__UnsupportedFeatureFaultType *)ptr);
		break;
	case SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType:
		soap_serialize_bes__NotAcceptingNewActivitiesFaultType(soap, (const struct bes__NotAcceptingNewActivitiesFaultType *)ptr);
		break;
	case SOAP_TYPE_bes__NotAuthorizedFaultType:
		soap_serialize_bes__NotAuthorizedFaultType(soap, (const struct bes__NotAuthorizedFaultType *)ptr);
		break;
	case SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType:
		soap_serialize_bes__GetFactoryAttributesDocumentResponseType(soap, (const struct bes__GetFactoryAttributesDocumentResponseType *)ptr);
		break;
	case SOAP_TYPE_bes__GetFactoryAttributesDocumentType:
		soap_serialize_bes__GetFactoryAttributesDocumentType(soap, (const struct bes__GetFactoryAttributesDocumentType *)ptr);
		break;
	case SOAP_TYPE_bes__GetActivityDocumentsResponseType:
		soap_serialize_bes__GetActivityDocumentsResponseType(soap, (const struct bes__GetActivityDocumentsResponseType *)ptr);
		break;
	case SOAP_TYPE_bes__GetActivityDocumentsType:
		soap_serialize_bes__GetActivityDocumentsType(soap, (const struct bes__GetActivityDocumentsType *)ptr);
		break;
	case SOAP_TYPE_bes__TerminateActivitiesResponseType:
		soap_serialize_bes__TerminateActivitiesResponseType(soap, (const struct bes__TerminateActivitiesResponseType *)ptr);
		break;
	case SOAP_TYPE_bes__TerminateActivitiesType:
		soap_serialize_bes__TerminateActivitiesType(soap, (const struct bes__TerminateActivitiesType *)ptr);
		break;
	case SOAP_TYPE_bes__GetActivityStatusesResponseType:
		soap_serialize_bes__GetActivityStatusesResponseType(soap, (const struct bes__GetActivityStatusesResponseType *)ptr);
		break;
	case SOAP_TYPE_bes__GetActivityStatusesType:
		soap_serialize_bes__GetActivityStatusesType(soap, (const struct bes__GetActivityStatusesType *)ptr);
		break;
	case SOAP_TYPE_bes__CreateActivityResponseType:
		soap_serialize_bes__CreateActivityResponseType(soap, (const struct bes__CreateActivityResponseType *)ptr);
		break;
	case SOAP_TYPE_bes__CreateActivityType:
		soap_serialize_bes__CreateActivityType(soap, (const struct bes__CreateActivityType *)ptr);
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		soap_serialize_xsd__anyAttribute(soap, (const struct soap_dom_attribute *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		soap_serialize_xsd__anyType(soap, (const struct soap_dom_element *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentResponseType:
		soap_serialize_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, (struct bes__GetFactoryAttributesDocumentResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentType:
		soap_serialize_PointerTobes__GetFactoryAttributesDocumentType(soap, (struct bes__GetFactoryAttributesDocumentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__GetActivityDocumentsResponseType:
		soap_serialize_PointerTobes__GetActivityDocumentsResponseType(soap, (struct bes__GetActivityDocumentsResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__TerminateActivitiesResponseType:
		soap_serialize_PointerTobes__TerminateActivitiesResponseType(soap, (struct bes__TerminateActivitiesResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__GetActivityStatusesResponseType:
		soap_serialize_PointerTobes__GetActivityStatusesResponseType(soap, (struct bes__GetActivityStatusesResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__CreateActivityResponseType:
		soap_serialize_PointerTobes__CreateActivityResponseType(soap, (struct bes__CreateActivityResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__CreateActivityType:
		soap_serialize_PointerTobes__CreateActivityType(soap, (struct bes__CreateActivityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__UnsupportedFeatureFaultType:
		soap_serialize_PointerTobes__UnsupportedFeatureFaultType(soap, (struct bes__UnsupportedFeatureFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__NotAuthorizedFaultType:
		soap_serialize_PointerTobes__NotAuthorizedFaultType(soap, (struct bes__NotAuthorizedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__NotAcceptingNewActivitiesFaultType:
		soap_serialize_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, (struct bes__NotAcceptingNewActivitiesFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__InvalidRequestMessageFaultType:
		soap_serialize_PointerTobes__InvalidRequestMessageFaultType(soap, (struct bes__InvalidRequestMessageFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		soap_serialize_PointerTo_wsa__FaultTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		soap_serialize_PointerTo_wsa__ReplyTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__From:
		soap_serialize_PointerTo_wsa__From(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		soap_serialize_PointerTo_wsa__RelatesTo(soap, (struct wsa__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE__jsdl__URI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__FilesystemName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__FileName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__MountPoint:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__OperatingSystemVersion:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__HostName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__ApplicationVersion:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__ApplicationName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__JobProject:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__JobAnnotation:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__Description:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__jsdl__JobName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerToposix__GroupName_USCOREType:
		soap_serialize_PointerToposix__GroupName_USCOREType(soap, (struct posix__GroupName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToposix__UserName_USCOREType:
		soap_serialize_PointerToposix__UserName_USCOREType(soap, (struct posix__UserName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToposix__Limits_USCOREType:
		soap_serialize_PointerToposix__Limits_USCOREType(soap, (struct posix__Limits_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToposix__Environment_USCOREType:
		soap_serialize_PointerToposix__Environment_USCOREType(soap, (struct posix__Environment_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToposix__DirectoryName_USCOREType:
		soap_serialize_PointerToposix__DirectoryName_USCOREType(soap, (struct posix__DirectoryName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToposix__Argument_USCOREType:
		soap_serialize_PointerToposix__Argument_USCOREType(soap, (struct posix__Argument_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToposix__FileName_USCOREType:
		soap_serialize_PointerToposix__FileName_USCOREType(soap, (struct posix__FileName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapp__UserName_USCOREType:
		soap_serialize_PointerToapp__UserName_USCOREType(soap, (struct app__UserName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapp__Environment_USCOREType:
		soap_serialize_PointerToapp__Environment_USCOREType(soap, (struct app__Environment_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapp__DirectoryName_USCOREType:
		soap_serialize_PointerToapp__DirectoryName_USCOREType(soap, (struct app__DirectoryName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapp__Argument_USCOREType:
		soap_serialize_PointerToapp__Argument_USCOREType(soap, (struct app__Argument_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToapp__FileName_USCOREType:
		soap_serialize_PointerToapp__FileName_USCOREType(soap, (struct app__FileName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
		soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, (struct jsdl__SourceTarget_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, (struct jsdl__OperatingSystemType_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
		soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, (enum jsdl__FileSystemTypeEnumeration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
		soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, (struct jsdl__RangeValue_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
		soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, (struct jsdl__FileSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
		soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, (struct jsdl__CandidateHosts_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
		soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, (struct jsdl__DataStaging_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
		soap_serialize_PointerTojsdl__Resources_USCOREType(soap, (struct jsdl__Resources_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
		soap_serialize_PointerTojsdl__Application_USCOREType(soap, (struct jsdl__Application_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
		soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, (struct jsdl__JobIdentification_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
		soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, (struct jsdl__JobDescription_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
		soap_serialize_PointerTojsdl__Range_USCOREType(soap, (struct jsdl__Range_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
		soap_serialize_PointerTojsdl__Exact_USCOREType(soap, (struct jsdl__Exact_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
		soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, (struct jsdl__Boundary_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__MetadataType:
		soap_serialize_PointerTowsa__MetadataType(soap, (struct wsa__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		soap_serialize_PointerTowsa__ReferenceParametersType(soap, (struct wsa__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__AttributedURIType:
		soap_serialize_PointerTowsa__AttributedURIType(soap, (struct wsa__AttributedURIType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
		soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, (struct jsdl__JobDefinition_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__EndpointReferenceType:
		soap_serialize_PointerTowsa__EndpointReferenceType(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__BasicResourceAttributesDocumentType:
		soap_serialize_PointerTobes__BasicResourceAttributesDocumentType(soap, (struct bes__BasicResourceAttributesDocumentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
		soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, (struct jsdl__CPUArchitecture_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, (struct jsdl__OperatingSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__ActivityStatusType:
		soap_serialize_PointerTobes__ActivityStatusType(soap, (struct bes__ActivityStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobes__TerminateActivityResponseType:
		soap_serialize_PointerTobes__TerminateActivityResponseType(soap, (struct bes__TerminateActivityResponseType *const*)ptr);
		break;
	case SOAP_TYPE_jsdl__Description_USCOREType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_wsa__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_wsa__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (struct soap_dom_element *const*)ptr);
		break;
	case SOAP_TYPE_xsd__normalizedString:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__DeleteOnTermination(struct soap *soap, enum xsd__boolean *a)
{	soap_default_xsd__boolean(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__DeleteOnTermination(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__DeleteOnTermination);
	if (soap_out__jsdl__DeleteOnTermination(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__jsdl__DeleteOnTermination2s(struct soap *soap, enum xsd__boolean n)
{	return soap_xsd__boolean2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__DeleteOnTermination(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__DeleteOnTermination), type) || soap_send(soap, soap__jsdl__DeleteOnTermination2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get__jsdl__DeleteOnTermination(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__DeleteOnTermination(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_jsdl__DeleteOnTermination(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	return soap_s2xsd__boolean(soap, s, a);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in__jsdl__DeleteOnTermination(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__DeleteOnTermination, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_jsdl__DeleteOnTermination(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__DeleteOnTermination, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__CreationFlag(struct soap *soap, enum jsdl__CreationFlagEnumeration *a)
{	soap_default_jsdl__CreationFlagEnumeration(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__CreationFlag(struct soap *soap, const enum jsdl__CreationFlagEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__CreationFlag);
	if (soap_out__jsdl__CreationFlag(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__jsdl__CreationFlag2s(struct soap *soap, enum jsdl__CreationFlagEnumeration n)
{	return soap_jsdl__CreationFlagEnumeration2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__CreationFlag(struct soap *soap, const char *tag, int id, const enum jsdl__CreationFlagEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__CreationFlag), type) || soap_send(soap, soap__jsdl__CreationFlag2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_get__jsdl__CreationFlag(struct soap *soap, enum jsdl__CreationFlagEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__CreationFlag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_jsdl__CreationFlag(struct soap *soap, const char *s, enum jsdl__CreationFlagEnumeration *a)
{
	return soap_s2jsdl__CreationFlagEnumeration(soap, s, a);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_in__jsdl__CreationFlag(struct soap *soap, const char *tag, enum jsdl__CreationFlagEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "jsdl:CreationFlagEnumeration"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum jsdl__CreationFlagEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__CreationFlag, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_jsdl__CreationFlag(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__CreationFlagEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__CreationFlag, 0, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__FileSystemType(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *a)
{	soap_default_jsdl__FileSystemTypeEnumeration(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__FileSystemType(struct soap *soap, const enum jsdl__FileSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__FileSystemType);
	if (soap_out__jsdl__FileSystemType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__jsdl__FileSystemType2s(struct soap *soap, enum jsdl__FileSystemTypeEnumeration n)
{	return soap_jsdl__FileSystemTypeEnumeration2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__FileSystemType(struct soap *soap, const char *tag, int id, const enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__FileSystemType), type) || soap_send(soap, soap__jsdl__FileSystemType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_get__jsdl__FileSystemType(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__FileSystemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_jsdl__FileSystemType(struct soap *soap, const char *s, enum jsdl__FileSystemTypeEnumeration *a)
{
	return soap_s2jsdl__FileSystemTypeEnumeration(soap, s, a);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_in__jsdl__FileSystemType(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "jsdl:FileSystemTypeEnumeration"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__FileSystemType, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_jsdl__FileSystemType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__FileSystemType, 0, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__CPUArchitectureName(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *a)
{	soap_default_jsdl__ProcessorArchitectureEnumeration(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__CPUArchitectureName(struct soap *soap, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__CPUArchitectureName);
	if (soap_out__jsdl__CPUArchitectureName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__jsdl__CPUArchitectureName2s(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration n)
{	return soap_jsdl__ProcessorArchitectureEnumeration2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__CPUArchitectureName(struct soap *soap, const char *tag, int id, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__CPUArchitectureName), type) || soap_send(soap, soap__jsdl__CPUArchitectureName2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_get__jsdl__CPUArchitectureName(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__CPUArchitectureName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_jsdl__CPUArchitectureName(struct soap *soap, const char *s, enum jsdl__ProcessorArchitectureEnumeration *a)
{
	return soap_s2jsdl__ProcessorArchitectureEnumeration(soap, s, a);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_in__jsdl__CPUArchitectureName(struct soap *soap, const char *tag, enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "jsdl:ProcessorArchitectureEnumeration"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__CPUArchitectureName, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_jsdl__CPUArchitectureName(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__CPUArchitectureName, 0, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__ExclusiveExecution(struct soap *soap, enum xsd__boolean *a)
{	soap_default_xsd__boolean(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__ExclusiveExecution(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__ExclusiveExecution);
	if (soap_out__jsdl__ExclusiveExecution(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__jsdl__ExclusiveExecution2s(struct soap *soap, enum xsd__boolean n)
{	return soap_xsd__boolean2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__ExclusiveExecution(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__ExclusiveExecution), type) || soap_send(soap, soap__jsdl__ExclusiveExecution2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get__jsdl__ExclusiveExecution(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__ExclusiveExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_jsdl__ExclusiveExecution(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	return soap_s2xsd__boolean(soap, s, a);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in__jsdl__ExclusiveExecution(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__ExclusiveExecution, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_jsdl__ExclusiveExecution(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__ExclusiveExecution, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__OperatingSystemName(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *a)
{	soap_default_jsdl__OperatingSystemTypeEnumeration(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__OperatingSystemName(struct soap *soap, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__OperatingSystemName);
	if (soap_out__jsdl__OperatingSystemName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__jsdl__OperatingSystemName2s(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration n)
{	return soap_jsdl__OperatingSystemTypeEnumeration2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__OperatingSystemName(struct soap *soap, const char *tag, int id, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__OperatingSystemName), type) || soap_send(soap, soap__jsdl__OperatingSystemName2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_get__jsdl__OperatingSystemName(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__OperatingSystemName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_jsdl__OperatingSystemName(struct soap *soap, const char *s, enum jsdl__OperatingSystemTypeEnumeration *a)
{
	return soap_s2jsdl__OperatingSystemTypeEnumeration(soap, s, a);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_in__jsdl__OperatingSystemName(struct soap *soap, const char *tag, enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, "jsdl:OperatingSystemTypeEnumeration"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__OperatingSystemName, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_jsdl__OperatingSystemName(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__OperatingSystemName, 0, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__IsReferenceParameter(struct soap *soap, enum xsd__boolean *a)
{	soap_default_xsd__boolean(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__IsReferenceParameter(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__IsReferenceParameter);
	if (soap_out__wsa__IsReferenceParameter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa__IsReferenceParameter2s(struct soap *soap, enum xsd__boolean n)
{	return soap_xsd__boolean2s(soap, n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__IsReferenceParameter), type) || soap_send(soap, soap__wsa__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get__wsa__IsReferenceParameter(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa__IsReferenceParameter(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	return soap_s2xsd__boolean(soap, s, a);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in__wsa__IsReferenceParameter(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__IsReferenceParameter, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_wsa__IsReferenceParameter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__IsReferenceParameter, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__CreationFlagEnumeration
	*a = SOAP_DEFAULT_jsdl__CreationFlagEnumeration;
#else
	*a = (enum jsdl__CreationFlagEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__CreationFlagEnumeration(struct soap *soap, const enum jsdl__CreationFlagEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__CreationFlagEnumeration);
	if (soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__CreationFlagEnumeration[] =
{	{ (long)overwrite, "overwrite" },
	{ (long)append, "append" },
	{ (long)dontOverwrite, "dontOverwrite" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__CreationFlagEnumeration2s(struct soap *soap, enum jsdl__CreationFlagEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__CreationFlagEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__CreationFlagEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CreationFlagEnumeration), type) || soap_send(soap, soap_jsdl__CreationFlagEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_get_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CreationFlagEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__CreationFlagEnumeration(struct soap *soap, const char *s, enum jsdl__CreationFlagEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__CreationFlagEnumeration, s);
	if (map)
		*a = (enum jsdl__CreationFlagEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__CreationFlagEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_in_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, enum jsdl__CreationFlagEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__CreationFlagEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CreationFlagEnumeration, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__CreationFlagEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__CreationFlagEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CreationFlagEnumeration, 0, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration;
#else
	*a = (enum jsdl__FileSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__FileSystemTypeEnumeration(struct soap *soap, const enum jsdl__FileSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
	if (soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__FileSystemTypeEnumeration[] =
{	{ (long)swap, "swap" },
	{ (long)temporary, "temporary" },
	{ (long)spool, "spool" },
	{ (long)normal, "normal" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__FileSystemTypeEnumeration2s(struct soap *soap, enum jsdl__FileSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__FileSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__FileSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__FileSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__FileSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__FileSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__FileSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__FileSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, 0, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration;
#else
	*a = (enum jsdl__OperatingSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration);
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__OperatingSystemTypeEnumeration[] =
{	{ (long)Unknown, "Unknown" },
	{ (long)MACOS, "MACOS" },
	{ (long)ATTUNIX, "ATTUNIX" },
	{ (long)DGUX, "DGUX" },
	{ (long)DECNT, "DECNT" },
	{ (long)Tru64_USCOREUNIX, "Tru64_UNIX" },
	{ (long)OpenVMS, "OpenVMS" },
	{ (long)HPUX, "HPUX" },
	{ (long)AIX, "AIX" },
	{ (long)MVS, "MVS" },
	{ (long)OS400, "OS400" },
	{ (long)OS_USCORE2, "OS_2" },
	{ (long)JavaVM, "JavaVM" },
	{ (long)MSDOS, "MSDOS" },
	{ (long)WIN3x, "WIN3x" },
	{ (long)WIN95, "WIN95" },
	{ (long)WIN98, "WIN98" },
	{ (long)WINNT, "WINNT" },
	{ (long)WINCE, "WINCE" },
	{ (long)NCR3000, "NCR3000" },
	{ (long)NetWare, "NetWare" },
	{ (long)OSF, "OSF" },
	{ (long)DC_USCOREOS, "DC_OS" },
	{ (long)Reliant_USCOREUNIX, "Reliant_UNIX" },
	{ (long)SCO_USCOREUnixWare, "SCO_UnixWare" },
	{ (long)SCO_USCOREOpenServer, "SCO_OpenServer" },
	{ (long)Sequent, "Sequent" },
	{ (long)IRIX, "IRIX" },
	{ (long)Solaris, "Solaris" },
	{ (long)SunOS, "SunOS" },
	{ (long)U6000, "U6000" },
	{ (long)ASERIES, "ASERIES" },
	{ (long)TandemNSK, "TandemNSK" },
	{ (long)TandemNT, "TandemNT" },
	{ (long)BS2000, "BS2000" },
	{ (long)LINUX, "LINUX" },
	{ (long)Lynx, "Lynx" },
	{ (long)XENIX, "XENIX" },
	{ (long)VM, "VM" },
	{ (long)Interactive_USCOREUNIX, "Interactive_UNIX" },
	{ (long)BSDUNIX, "BSDUNIX" },
	{ (long)FreeBSD, "FreeBSD" },
	{ (long)NetBSD, "NetBSD" },
	{ (long)GNU_USCOREHurd, "GNU_Hurd" },
	{ (long)OS9, "OS9" },
	{ (long)MACH_USCOREKernel, "MACH_Kernel" },
	{ (long)Inferno, "Inferno" },
	{ (long)QNX, "QNX" },
	{ (long)EPOC, "EPOC" },
	{ (long)IxWorks, "IxWorks" },
	{ (long)VxWorks, "VxWorks" },
	{ (long)MiNT, "MiNT" },
	{ (long)BeOS, "BeOS" },
	{ (long)HP_USCOREMPE, "HP_MPE" },
	{ (long)NextStep, "NextStep" },
	{ (long)PalmPilot, "PalmPilot" },
	{ (long)Rhapsody, "Rhapsody" },
	{ (long)Windows_USCORE2000, "Windows_2000" },
	{ (long)Dedicated, "Dedicated" },
	{ (long)OS_USCORE390, "OS_390" },
	{ (long)VSE, "VSE" },
	{ (long)TPF, "TPF" },
	{ (long)Windows_USCORER_USCOREMe, "Windows_R_Me" },
	{ (long)Caldera_USCOREOpen_USCOREUNIX, "Caldera_Open_UNIX" },
	{ (long)OpenBSD, "OpenBSD" },
	{ (long)Not_USCOREApplicable, "Not_Applicable" },
	{ (long)Windows_USCOREXP, "Windows_XP" },
	{ (long)z_USCOREOS, "z_OS" },
	{ (long)other_, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__OperatingSystemTypeEnumeration2s(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__OperatingSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__OperatingSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__OperatingSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__OperatingSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__OperatingSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 68)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__OperatingSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__OperatingSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration, 0, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration
	*a = SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration;
#else
	*a = (enum jsdl__ProcessorArchitectureEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration);
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__ProcessorArchitectureEnumeration[] =
{	{ (long)sparc, "sparc" },
	{ (long)powerpc, "powerpc" },
	{ (long)x86, "x86" },
	{ (long)x86_USCORE32, "x86_32" },
	{ (long)x86_USCORE64, "x86_64" },
	{ (long)parisc, "parisc" },
	{ (long)mips, "mips" },
	{ (long)ia64, "ia64" },
	{ (long)arm, "arm" },
	{ (long)other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__ProcessorArchitectureEnumeration2s(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__ProcessorArchitectureEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration), type) || soap_send(soap, soap_jsdl__ProcessorArchitectureEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_get_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__ProcessorArchitectureEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *s, enum jsdl__ProcessorArchitectureEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__ProcessorArchitectureEnumeration, s);
	if (map)
		*a = (enum jsdl__ProcessorArchitectureEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__ProcessorArchitectureEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_in_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__ProcessorArchitectureEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration, 0, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__FaultCodesType(struct soap *soap, enum wsa__FaultCodesType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa__FaultCodesType
	*a = SOAP_DEFAULT_wsa__FaultCodesType;
#else
	*a = (enum wsa__FaultCodesType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__FaultCodesType(struct soap *soap, const enum wsa__FaultCodesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__FaultCodesType);
	if (soap_out_wsa__FaultCodesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsa__FaultCodesType[] =
{	{ (long)wsa__InvalidAddressingHeader, "wsa:InvalidAddressingHeader" },
	{ (long)wsa__InvalidAddress, "wsa:InvalidAddress" },
	{ (long)wsa__InvalidEPR, "wsa:InvalidEPR" },
	{ (long)wsa__InvalidCardinality, "wsa:InvalidCardinality" },
	{ (long)wsa__MissingAddressInEPR, "wsa:MissingAddressInEPR" },
	{ (long)wsa__DuplicateMessageID, "wsa:DuplicateMessageID" },
	{ (long)wsa__ActionMismatch, "wsa:ActionMismatch" },
	{ (long)wsa__MessageAddressingHeaderRequired, "wsa:MessageAddressingHeaderRequired" },
	{ (long)wsa__DestinationUnreachable, "wsa:DestinationUnreachable" },
	{ (long)wsa__ActionNotSupported, "wsa:ActionNotSupported" },
	{ (long)wsa__EndpointUnavailable, "wsa:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__FaultCodesType2s(struct soap *soap, enum wsa__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_wsa__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa__FaultCodesType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__FaultCodesType), type) || soap_send(soap, soap_wsa__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsa__FaultCodesType * SOAP_FMAC4 soap_get_wsa__FaultCodesType(struct soap *soap, enum wsa__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__FaultCodesType(struct soap *soap, const char *s, enum wsa__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsa__FaultCodesType, t);
	if (map)
		*a = (enum wsa__FaultCodesType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__FaultCodesType * SOAP_FMAC4 soap_in_wsa__FaultCodesType(struct soap *soap, const char *tag, enum wsa__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultCodesType, sizeof(enum wsa__FaultCodesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa__FaultCodesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultCodesType, 0, sizeof(enum wsa__FaultCodesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__RelationshipType(struct soap *soap, enum wsa__RelationshipType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa__RelationshipType
	*a = SOAP_DEFAULT_wsa__RelationshipType;
#else
	*a = (enum wsa__RelationshipType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelationshipType(struct soap *soap, const enum wsa__RelationshipType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__RelationshipType);
	if (soap_out_wsa__RelationshipType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsa__RelationshipType[] =
{	{ (long)http___x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__RelationshipType2s(struct soap *soap, enum wsa__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_wsa__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa__RelationshipType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__RelationshipType), type) || soap_send(soap, soap_wsa__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsa__RelationshipType * SOAP_FMAC4 soap_get_wsa__RelationshipType(struct soap *soap, enum wsa__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__RelationshipType(struct soap *soap, const char *s, enum wsa__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_wsa__RelationshipType, s);
	if (map)
		*a = (enum wsa__RelationshipType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__RelationshipType * SOAP_FMAC4 soap_in_wsa__RelationshipType(struct soap *soap, const char *tag, enum wsa__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipType, sizeof(enum wsa__RelationshipType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipType, 0, sizeof(enum wsa__RelationshipType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__ActivityStateEnumeration(struct soap *soap, enum bes__ActivityStateEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bes__ActivityStateEnumeration
	*a = SOAP_DEFAULT_bes__ActivityStateEnumeration;
#else
	*a = (enum bes__ActivityStateEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__ActivityStateEnumeration(struct soap *soap, const enum bes__ActivityStateEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__ActivityStateEnumeration);
	if (soap_out_bes__ActivityStateEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bes__ActivityStateEnumeration[] =
{	{ (long)Pending, "Pending" },
	{ (long)Running, "Running" },
	{ (long)Cancelled, "Cancelled" },
	{ (long)Failed, "Failed" },
	{ (long)Finished, "Finished" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bes__ActivityStateEnumeration2s(struct soap *soap, enum bes__ActivityStateEnumeration n)
{	const char *s = soap_code_str(soap_codes_bes__ActivityStateEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__ActivityStateEnumeration(struct soap *soap, const char *tag, int id, const enum bes__ActivityStateEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__ActivityStateEnumeration), type) || soap_send(soap, soap_bes__ActivityStateEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum bes__ActivityStateEnumeration * SOAP_FMAC4 soap_get_bes__ActivityStateEnumeration(struct soap *soap, enum bes__ActivityStateEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__ActivityStateEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bes__ActivityStateEnumeration(struct soap *soap, const char *s, enum bes__ActivityStateEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bes__ActivityStateEnumeration, s);
	if (map)
		*a = (enum bes__ActivityStateEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum bes__ActivityStateEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum bes__ActivityStateEnumeration * SOAP_FMAC4 soap_in_bes__ActivityStateEnumeration(struct soap *soap, const char *tag, enum bes__ActivityStateEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum bes__ActivityStateEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__ActivityStateEnumeration, sizeof(enum bes__ActivityStateEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bes__ActivityStateEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum bes__ActivityStateEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__ActivityStateEnumeration, 0, sizeof(enum bes__ActivityStateEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)false_, "false" },
	{ (long)true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{	return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
	*a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
	*a = (enum wsse__FaultcodeEnum)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsse__FaultcodeEnum);
	if (soap_out_wsse__FaultcodeEnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (long)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (long)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (long)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (long)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (long)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (long)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (long)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, 0, sizeof(enum wsse__FaultcodeEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
	*a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
	*a = (enum wsu__tTimestampFault)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsu__tTimestampFault);
	if (soap_out_wsu__tTimestampFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (long)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, 0, sizeof(enum wsu__tTimestampFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__GetFactoryAttributesDocument(struct soap *soap, struct __bes__GetFactoryAttributesDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__GetFactoryAttributesDocument = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__GetFactoryAttributesDocument(struct soap *soap, const struct __bes__GetFactoryAttributesDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__GetFactoryAttributesDocumentType(soap, &a->bes__GetFactoryAttributesDocument);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__GetFactoryAttributesDocument(struct soap *soap, const struct __bes__GetFactoryAttributesDocument *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__GetFactoryAttributesDocument(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__GetFactoryAttributesDocument(struct soap *soap, const char *tag, int id, const struct __bes__GetFactoryAttributesDocument *a, const char *type)
{
	if (soap_out_PointerTobes__GetFactoryAttributesDocumentType(soap, "bes:GetFactoryAttributesDocument", -1, &a->bes__GetFactoryAttributesDocument, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__GetFactoryAttributesDocument * SOAP_FMAC4 soap_get___bes__GetFactoryAttributesDocument(struct soap *soap, struct __bes__GetFactoryAttributesDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__GetFactoryAttributesDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__GetFactoryAttributesDocument * SOAP_FMAC4 soap_in___bes__GetFactoryAttributesDocument(struct soap *soap, const char *tag, struct __bes__GetFactoryAttributesDocument *a, const char *type)
{
	short soap_flag_bes__GetFactoryAttributesDocument = 1;
	short soap_flag;
	a = (struct __bes__GetFactoryAttributesDocument *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__GetFactoryAttributesDocument, sizeof(struct __bes__GetFactoryAttributesDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__GetFactoryAttributesDocument(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__GetFactoryAttributesDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__GetFactoryAttributesDocumentType(soap, "bes:GetFactoryAttributesDocument", &a->bes__GetFactoryAttributesDocument, "bes:GetFactoryAttributesDocumentType"))
				{	soap_flag_bes__GetFactoryAttributesDocument--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__GetActivityDocuments(struct soap *soap, struct __bes__GetActivityDocuments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bes__GetActivityDocumentsType(soap, &a->bes__GetActivityDocuments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__GetActivityDocuments(struct soap *soap, const struct __bes__GetActivityDocuments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_bes__GetActivityDocumentsType(soap, &a->bes__GetActivityDocuments);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__GetActivityDocuments(struct soap *soap, const struct __bes__GetActivityDocuments *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__GetActivityDocuments(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__GetActivityDocuments(struct soap *soap, const char *tag, int id, const struct __bes__GetActivityDocuments *a, const char *type)
{
	if (soap_out_bes__GetActivityDocumentsType(soap, "bes:GetActivityDocuments", -1, &a->bes__GetActivityDocuments, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__GetActivityDocuments * SOAP_FMAC4 soap_get___bes__GetActivityDocuments(struct soap *soap, struct __bes__GetActivityDocuments *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__GetActivityDocuments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__GetActivityDocuments * SOAP_FMAC4 soap_in___bes__GetActivityDocuments(struct soap *soap, const char *tag, struct __bes__GetActivityDocuments *a, const char *type)
{
	short soap_flag_bes__GetActivityDocuments = 1;
	short soap_flag;
	a = (struct __bes__GetActivityDocuments *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__GetActivityDocuments, sizeof(struct __bes__GetActivityDocuments), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__GetActivityDocuments(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__GetActivityDocuments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bes__GetActivityDocumentsType(soap, "bes:GetActivityDocuments", &a->bes__GetActivityDocuments, "bes:GetActivityDocumentsType"))
				{	soap_flag_bes__GetActivityDocuments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__GetActivityDocuments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__TerminateActivities(struct soap *soap, struct __bes__TerminateActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bes__TerminateActivitiesType(soap, &a->bes__TerminateActivities);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__TerminateActivities(struct soap *soap, const struct __bes__TerminateActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_bes__TerminateActivitiesType(soap, &a->bes__TerminateActivities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__TerminateActivities(struct soap *soap, const struct __bes__TerminateActivities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__TerminateActivities(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__TerminateActivities(struct soap *soap, const char *tag, int id, const struct __bes__TerminateActivities *a, const char *type)
{
	if (soap_out_bes__TerminateActivitiesType(soap, "bes:TerminateActivities", -1, &a->bes__TerminateActivities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__TerminateActivities * SOAP_FMAC4 soap_get___bes__TerminateActivities(struct soap *soap, struct __bes__TerminateActivities *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__TerminateActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__TerminateActivities * SOAP_FMAC4 soap_in___bes__TerminateActivities(struct soap *soap, const char *tag, struct __bes__TerminateActivities *a, const char *type)
{
	short soap_flag_bes__TerminateActivities = 1;
	short soap_flag;
	a = (struct __bes__TerminateActivities *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__TerminateActivities, sizeof(struct __bes__TerminateActivities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__TerminateActivities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__TerminateActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bes__TerminateActivitiesType(soap, "bes:TerminateActivities", &a->bes__TerminateActivities, "bes:TerminateActivitiesType"))
				{	soap_flag_bes__TerminateActivities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__TerminateActivities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__GetActivityStatuses(struct soap *soap, struct __bes__GetActivityStatuses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bes__GetActivityStatusesType(soap, &a->bes__GetActivityStatuses);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__GetActivityStatuses(struct soap *soap, const struct __bes__GetActivityStatuses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_bes__GetActivityStatusesType(soap, &a->bes__GetActivityStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__GetActivityStatuses(struct soap *soap, const struct __bes__GetActivityStatuses *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__GetActivityStatuses(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__GetActivityStatuses(struct soap *soap, const char *tag, int id, const struct __bes__GetActivityStatuses *a, const char *type)
{
	if (soap_out_bes__GetActivityStatusesType(soap, "bes:GetActivityStatuses", -1, &a->bes__GetActivityStatuses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__GetActivityStatuses * SOAP_FMAC4 soap_get___bes__GetActivityStatuses(struct soap *soap, struct __bes__GetActivityStatuses *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__GetActivityStatuses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__GetActivityStatuses * SOAP_FMAC4 soap_in___bes__GetActivityStatuses(struct soap *soap, const char *tag, struct __bes__GetActivityStatuses *a, const char *type)
{
	short soap_flag_bes__GetActivityStatuses = 1;
	short soap_flag;
	a = (struct __bes__GetActivityStatuses *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__GetActivityStatuses, sizeof(struct __bes__GetActivityStatuses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__GetActivityStatuses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__GetActivityStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bes__GetActivityStatusesType(soap, "bes:GetActivityStatuses", &a->bes__GetActivityStatuses, "bes:GetActivityStatusesType"))
				{	soap_flag_bes__GetActivityStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__GetActivityStatuses > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__CreateActivity(struct soap *soap, struct __bes__CreateActivity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__CreateActivity = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__CreateActivity(struct soap *soap, const struct __bes__CreateActivity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__CreateActivityType(soap, &a->bes__CreateActivity);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__CreateActivity(struct soap *soap, const struct __bes__CreateActivity *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__CreateActivity(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__CreateActivity(struct soap *soap, const char *tag, int id, const struct __bes__CreateActivity *a, const char *type)
{
	if (soap_out_PointerTobes__CreateActivityType(soap, "bes:CreateActivity", -1, &a->bes__CreateActivity, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__CreateActivity * SOAP_FMAC4 soap_get___bes__CreateActivity(struct soap *soap, struct __bes__CreateActivity *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__CreateActivity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__CreateActivity * SOAP_FMAC4 soap_in___bes__CreateActivity(struct soap *soap, const char *tag, struct __bes__CreateActivity *a, const char *type)
{
	short soap_flag_bes__CreateActivity = 1;
	short soap_flag;
	a = (struct __bes__CreateActivity *)soap_id_enter(soap, "", a, SOAP_TYPE___bes__CreateActivity, sizeof(struct __bes__CreateActivity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__CreateActivity(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__CreateActivity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__CreateActivityType(soap, "bes:CreateActivity", &a->bes__CreateActivity, "bes:CreateActivityType"))
				{	soap_flag_bes__CreateActivity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__InvalidRequestMessageFault = NULL;
	a->bes__NotAcceptingNewActivitiesFault = NULL;
	a->bes__NotAuthorizedFault = NULL;
	a->bes__UnsupportedFeatureFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__InvalidRequestMessageFaultType(soap, &a->bes__InvalidRequestMessageFault);
	soap_serialize_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, &a->bes__NotAcceptingNewActivitiesFault);
	soap_serialize_PointerTobes__NotAuthorizedFaultType(soap, &a->bes__NotAuthorizedFault);
	soap_serialize_PointerTobes__UnsupportedFeatureFaultType(soap, &a->bes__UnsupportedFeatureFault);
	soap_markelement(soap, a->fault, a->__type);
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTobes__InvalidRequestMessageFaultType(soap, "bes:InvalidRequestMessageFault", -1, &a->bes__InvalidRequestMessageFault, ""))
		return soap->error;
	if (soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, "bes:NotAcceptingNewActivitiesFault", -1, &a->bes__NotAcceptingNewActivitiesFault, ""))
		return soap->error;
	if (soap_out_PointerTobes__NotAuthorizedFaultType(soap, "bes:NotAuthorizedFault", -1, &a->bes__NotAuthorizedFault, ""))
		return soap->error;
	if (soap_out_PointerTobes__UnsupportedFeatureFaultType(soap, "bes:UnsupportedFeatureFault", -1, &a->bes__UnsupportedFeatureFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_bes__InvalidRequestMessageFault = 1, soap_flag_bes__NotAcceptingNewActivitiesFault = 1, soap_flag_bes__NotAuthorizedFault = 1, soap_flag_bes__UnsupportedFeatureFault = 1, soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__InvalidRequestMessageFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__InvalidRequestMessageFaultType(soap, "bes:InvalidRequestMessageFault", &a->bes__InvalidRequestMessageFault, "bes:InvalidRequestMessageFaultType"))
				{	soap_flag_bes__InvalidRequestMessageFault--;
					continue;
				}
			if (soap_flag_bes__NotAcceptingNewActivitiesFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, "bes:NotAcceptingNewActivitiesFault", &a->bes__NotAcceptingNewActivitiesFault, "bes:NotAcceptingNewActivitiesFaultType"))
				{	soap_flag_bes__NotAcceptingNewActivitiesFault--;
					continue;
				}
			if (soap_flag_bes__NotAuthorizedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__NotAuthorizedFaultType(soap, "bes:NotAuthorizedFault", &a->bes__NotAuthorizedFault, "bes:NotAuthorizedFaultType"))
				{	soap_flag_bes__NotAuthorizedFault--;
					continue;
				}
			if (soap_flag_bes__UnsupportedFeatureFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__UnsupportedFeatureFaultType(soap, "bes:UnsupportedFeatureFault", &a->bes__UnsupportedFeatureFault, "bes:UnsupportedFeatureFaultType"))
				{	soap_flag_bes__UnsupportedFeatureFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1 || soap_flag___any > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
	soap_serialize__wsa__MessageID(soap, &a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, &a->wsa__To);
	soap_serialize__wsa__Action(soap, &a->wsa__Action);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, &a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	if (soap_out__wsa__To(soap, "wsa:To", -1, &a->wsa__To, ""))
		return soap->error;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, &a->wsa__Action, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	short soap_flag_wsse__Security = 1, soap_flag_wsa__MessageID = 1, soap_flag_wsa__RelatesTo = 1, soap_flag_wsa__From = 1, soap_flag_wsa__ReplyTo = 1, soap_flag_wsa__FaultTo = 1, soap_flag_wsa__To = 1, soap_flag_wsa__Action = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap_flag_wsa__MessageID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__MessageID(soap, "wsa:MessageID", &a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			if (soap_flag_wsa__To && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__To(soap, "wsa:To", &a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			if (soap_flag_wsa__Action && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__Action(soap, "wsa:Action", &a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__GroupName(struct soap *soap, struct posix__GroupName_USCOREType *a)
{	soap_default_posix__GroupName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__GroupName(struct soap *soap, struct posix__GroupName_USCOREType const*a)
{	soap_serialize_posix__GroupName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__GroupName(struct soap *soap, const struct posix__GroupName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__GroupName);
	if (soap_out__posix__GroupName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__GroupName(struct soap *soap, const char *tag, int id, const struct posix__GroupName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__GroupName_USCOREType * SOAP_FMAC4 soap_get__posix__GroupName(struct soap *soap, struct posix__GroupName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__GroupName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__GroupName_USCOREType * SOAP_FMAC4 soap_in__posix__GroupName(struct soap *soap, const char *tag, struct posix__GroupName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__GroupName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__GroupName, sizeof(struct posix__GroupName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__GroupName(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__UserName(struct soap *soap, struct posix__UserName_USCOREType *a)
{	soap_default_posix__UserName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__UserName(struct soap *soap, struct posix__UserName_USCOREType const*a)
{	soap_serialize_posix__UserName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__UserName(struct soap *soap, const struct posix__UserName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__UserName);
	if (soap_out__posix__UserName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__UserName(struct soap *soap, const char *tag, int id, const struct posix__UserName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__UserName_USCOREType * SOAP_FMAC4 soap_get__posix__UserName(struct soap *soap, struct posix__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__UserName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__UserName_USCOREType * SOAP_FMAC4 soap_in__posix__UserName(struct soap *soap, const char *tag, struct posix__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__UserName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__UserName, sizeof(struct posix__UserName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__UserName(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__ThreadCountLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__ThreadCountLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__ThreadCountLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__ThreadCountLimit);
	if (soap_out__posix__ThreadCountLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__ThreadCountLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__ThreadCountLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__ThreadCountLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__ThreadCountLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__ThreadCountLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__ThreadCountLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__VirtualMemoryLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__VirtualMemoryLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__VirtualMemoryLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__VirtualMemoryLimit);
	if (soap_out__posix__VirtualMemoryLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__VirtualMemoryLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__VirtualMemoryLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__VirtualMemoryLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__VirtualMemoryLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__VirtualMemoryLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__VirtualMemoryLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__ProcessCountLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__ProcessCountLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__ProcessCountLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__ProcessCountLimit);
	if (soap_out__posix__ProcessCountLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__ProcessCountLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__ProcessCountLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__ProcessCountLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__ProcessCountLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__ProcessCountLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__ProcessCountLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__CPUTimeLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__CPUTimeLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__CPUTimeLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__CPUTimeLimit);
	if (soap_out__posix__CPUTimeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__CPUTimeLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__CPUTimeLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__CPUTimeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__CPUTimeLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__CPUTimeLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__CPUTimeLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__StackSizeLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__StackSizeLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__StackSizeLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__StackSizeLimit);
	if (soap_out__posix__StackSizeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__StackSizeLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__StackSizeLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__StackSizeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__StackSizeLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__StackSizeLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__StackSizeLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__PipeSizeLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__PipeSizeLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__PipeSizeLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__PipeSizeLimit);
	if (soap_out__posix__PipeSizeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__PipeSizeLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__PipeSizeLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__PipeSizeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__PipeSizeLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__PipeSizeLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__PipeSizeLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__OpenDescriptorsLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__OpenDescriptorsLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__OpenDescriptorsLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__OpenDescriptorsLimit);
	if (soap_out__posix__OpenDescriptorsLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__OpenDescriptorsLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__OpenDescriptorsLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__OpenDescriptorsLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__OpenDescriptorsLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__OpenDescriptorsLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__OpenDescriptorsLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__MemoryLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__MemoryLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__MemoryLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__MemoryLimit);
	if (soap_out__posix__MemoryLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__MemoryLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__MemoryLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__MemoryLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__MemoryLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__MemoryLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__MemoryLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__LockedMemoryLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__LockedMemoryLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__LockedMemoryLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__LockedMemoryLimit);
	if (soap_out__posix__LockedMemoryLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__LockedMemoryLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__LockedMemoryLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__LockedMemoryLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__LockedMemoryLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__LockedMemoryLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__LockedMemoryLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__DataSegmentLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__DataSegmentLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__DataSegmentLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__DataSegmentLimit);
	if (soap_out__posix__DataSegmentLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__DataSegmentLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__DataSegmentLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__DataSegmentLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__DataSegmentLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__DataSegmentLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__DataSegmentLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__CoreDumpLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__CoreDumpLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__CoreDumpLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__CoreDumpLimit);
	if (soap_out__posix__CoreDumpLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__CoreDumpLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__CoreDumpLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__CoreDumpLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__CoreDumpLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__CoreDumpLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__CoreDumpLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__FileSizeLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__FileSizeLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__FileSizeLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__FileSizeLimit);
	if (soap_out__posix__FileSizeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__FileSizeLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__FileSizeLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__FileSizeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__FileSizeLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__FileSizeLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__FileSizeLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__WallTimeLimit(struct soap *soap, struct posix__Limits_USCOREType *a)
{	soap_default_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__WallTimeLimit(struct soap *soap, struct posix__Limits_USCOREType const*a)
{	soap_serialize_posix__Limits_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__WallTimeLimit(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__WallTimeLimit);
	if (soap_out__posix__WallTimeLimit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__WallTimeLimit(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get__posix__WallTimeLimit(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__WallTimeLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in__posix__WallTimeLimit(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__WallTimeLimit, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__WallTimeLimit(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__Environment(struct soap *soap, struct posix__Environment_USCOREType *a)
{	soap_default_posix__Environment_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__Environment(struct soap *soap, struct posix__Environment_USCOREType const*a)
{	soap_serialize_posix__Environment_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__Environment(struct soap *soap, const struct posix__Environment_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__Environment);
	if (soap_out__posix__Environment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__Environment(struct soap *soap, const char *tag, int id, const struct posix__Environment_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Environment_USCOREType * SOAP_FMAC4 soap_get__posix__Environment(struct soap *soap, struct posix__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__Environment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Environment_USCOREType * SOAP_FMAC4 soap_in__posix__Environment(struct soap *soap, const char *tag, struct posix__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Environment_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__Environment, sizeof(struct posix__Environment_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__Environment(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__WorkingDirectory(struct soap *soap, struct posix__DirectoryName_USCOREType *a)
{	soap_default_posix__DirectoryName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__WorkingDirectory(struct soap *soap, struct posix__DirectoryName_USCOREType const*a)
{	soap_serialize_posix__DirectoryName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__WorkingDirectory(struct soap *soap, const struct posix__DirectoryName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__WorkingDirectory);
	if (soap_out__posix__WorkingDirectory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__WorkingDirectory(struct soap *soap, const char *tag, int id, const struct posix__DirectoryName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__DirectoryName_USCOREType * SOAP_FMAC4 soap_get__posix__WorkingDirectory(struct soap *soap, struct posix__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__WorkingDirectory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__DirectoryName_USCOREType * SOAP_FMAC4 soap_in__posix__WorkingDirectory(struct soap *soap, const char *tag, struct posix__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__DirectoryName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__WorkingDirectory, sizeof(struct posix__DirectoryName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__WorkingDirectory(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__Error(struct soap *soap, struct posix__FileName_USCOREType *a)
{	soap_default_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__Error(struct soap *soap, struct posix__FileName_USCOREType const*a)
{	soap_serialize_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__Error(struct soap *soap, const struct posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__Error);
	if (soap_out__posix__Error(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__Error(struct soap *soap, const char *tag, int id, const struct posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_get__posix__Error(struct soap *soap, struct posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__Error(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_in__posix__Error(struct soap *soap, const char *tag, struct posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__Error, sizeof(struct posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__Error(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__Output(struct soap *soap, struct posix__FileName_USCOREType *a)
{	soap_default_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__Output(struct soap *soap, struct posix__FileName_USCOREType const*a)
{	soap_serialize_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__Output(struct soap *soap, const struct posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__Output);
	if (soap_out__posix__Output(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__Output(struct soap *soap, const char *tag, int id, const struct posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_get__posix__Output(struct soap *soap, struct posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__Output(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_in__posix__Output(struct soap *soap, const char *tag, struct posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__Output, sizeof(struct posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__Output(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__Input(struct soap *soap, struct posix__FileName_USCOREType *a)
{	soap_default_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__Input(struct soap *soap, struct posix__FileName_USCOREType const*a)
{	soap_serialize_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__Input(struct soap *soap, const struct posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__Input);
	if (soap_out__posix__Input(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__Input(struct soap *soap, const char *tag, int id, const struct posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_get__posix__Input(struct soap *soap, struct posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__Input(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_in__posix__Input(struct soap *soap, const char *tag, struct posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__Input, sizeof(struct posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__Input(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__Argument(struct soap *soap, struct posix__Argument_USCOREType *a)
{	soap_default_posix__Argument_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__Argument(struct soap *soap, struct posix__Argument_USCOREType const*a)
{	soap_serialize_posix__Argument_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__Argument(struct soap *soap, const struct posix__Argument_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__Argument);
	if (soap_out__posix__Argument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__Argument(struct soap *soap, const char *tag, int id, const struct posix__Argument_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__normalizedString(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Argument_USCOREType * SOAP_FMAC4 soap_get__posix__Argument(struct soap *soap, struct posix__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__Argument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Argument_USCOREType * SOAP_FMAC4 soap_in__posix__Argument(struct soap *soap, const char *tag, struct posix__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Argument_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__Argument, sizeof(struct posix__Argument_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__Argument(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__normalizedString(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__Executable(struct soap *soap, struct posix__FileName_USCOREType *a)
{	soap_default_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__Executable(struct soap *soap, struct posix__FileName_USCOREType const*a)
{	soap_serialize_posix__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__Executable(struct soap *soap, const struct posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__Executable);
	if (soap_out__posix__Executable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__Executable(struct soap *soap, const char *tag, int id, const struct posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_get__posix__Executable(struct soap *soap, struct posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__Executable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_in__posix__Executable(struct soap *soap, const char *tag, struct posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__Executable, sizeof(struct posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__posix__Executable(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__posix__POSIXApplication(struct soap *soap, struct posix__POSIXApplication_USCOREType *a)
{	soap_default_posix__POSIXApplication_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__posix__POSIXApplication(struct soap *soap, struct posix__POSIXApplication_USCOREType const*a)
{	soap_serialize_posix__POSIXApplication_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__posix__POSIXApplication(struct soap *soap, const struct posix__POSIXApplication_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__posix__POSIXApplication);
	if (soap_out__posix__POSIXApplication(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__posix__POSIXApplication(struct soap *soap, const char *tag, int id, const struct posix__POSIXApplication_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__posix__POSIXApplication), type))
		return soap->error;
	if (soap_out_PointerToposix__FileName_USCOREType(soap, "posix:Executable", -1, &a->posix__Executable, ""))
		return soap->error;
	if (a->posix__Argument)
	{	int i;
		for (i = 0; i < a->__sizeArgument; i++)
			if (soap_out_posix__Argument_USCOREType(soap, "posix:Argument", -1, a->posix__Argument + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToposix__FileName_USCOREType(soap, "posix:Input", -1, &a->posix__Input, ""))
		return soap->error;
	if (soap_out_PointerToposix__FileName_USCOREType(soap, "posix:Output", -1, &a->posix__Output, ""))
		return soap->error;
	if (soap_out_PointerToposix__FileName_USCOREType(soap, "posix:Error", -1, &a->posix__Error, ""))
		return soap->error;
	if (soap_out_PointerToposix__DirectoryName_USCOREType(soap, "posix:WorkingDirectory", -1, &a->posix__WorkingDirectory, ""))
		return soap->error;
	if (a->posix__Environment)
	{	int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
			if (soap_out_posix__Environment_USCOREType(soap, "posix:Environment", -1, a->posix__Environment + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:WallTimeLimit", -1, &a->posix__WallTimeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:FileSizeLimit", -1, &a->posix__FileSizeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:CoreDumpLimit", -1, &a->posix__CoreDumpLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:DataSegmentLimit", -1, &a->posix__DataSegmentLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:LockedMemoryLimit", -1, &a->posix__LockedMemoryLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:MemoryLimit", -1, &a->posix__MemoryLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:OpenDescriptorsLimit", -1, &a->posix__OpenDescriptorsLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:PipeSizeLimit", -1, &a->posix__PipeSizeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:StackSizeLimit", -1, &a->posix__StackSizeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:CPUTimeLimit", -1, &a->posix__CPUTimeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:ProcessCountLimit", -1, &a->posix__ProcessCountLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:VirtualMemoryLimit", -1, &a->posix__VirtualMemoryLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:ThreadCountLimit", -1, &a->posix__ThreadCountLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__UserName_USCOREType(soap, "posix:UserName", -1, &a->posix__UserName, ""))
		return soap->error;
	if (soap_out_PointerToposix__GroupName_USCOREType(soap, "posix:GroupName", -1, &a->posix__GroupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct posix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_get__posix__POSIXApplication(struct soap *soap, struct posix__POSIXApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__posix__POSIXApplication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_in__posix__POSIXApplication(struct soap *soap, const char *tag, struct posix__POSIXApplication_USCOREType *a, const char *type)
{
	short soap_flag_posix__Executable = 1, soap_flag_posix__Argument = 1, soap_flag_posix__Input = 1, soap_flag_posix__Output = 1, soap_flag_posix__Error = 1, soap_flag_posix__WorkingDirectory = 1, soap_flag_posix__Environment = 1, soap_flag_posix__WallTimeLimit = 1, soap_flag_posix__FileSizeLimit = 1, soap_flag_posix__CoreDumpLimit = 1, soap_flag_posix__DataSegmentLimit = 1, soap_flag_posix__LockedMemoryLimit = 1, soap_flag_posix__MemoryLimit = 1, soap_flag_posix__OpenDescriptorsLimit = 1, soap_flag_posix__PipeSizeLimit = 1, soap_flag_posix__StackSizeLimit = 1, soap_flag_posix__CPUTimeLimit = 1, soap_flag_posix__ProcessCountLimit = 1, soap_flag_posix__VirtualMemoryLimit = 1, soap_flag_posix__ThreadCountLimit = 1, soap_flag_posix__UserName = 1, soap_flag_posix__GroupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct posix__POSIXApplication_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__posix__POSIXApplication, sizeof(struct posix__POSIXApplication_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__posix__POSIXApplication(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_posix__Executable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__FileName_USCOREType(soap, "posix:Executable", &a->posix__Executable, "posix:FileName_Type"))
				{	soap_flag_posix__Executable--;
					continue;
				}
			if (soap_flag_posix__Argument && soap->error == SOAP_TAG_MISMATCH)
			{	struct posix__Argument_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeArgument = 0; !soap_element_begin_in(soap, "posix:Argument", 1, NULL); a->__sizeArgument++)
				{	p = (struct posix__Argument_USCOREType *)soap_push_block(soap, sizeof(struct posix__Argument_USCOREType));
					soap_default_posix__Argument_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_posix__Argument_USCOREType(soap, "posix:Argument", p, "posix:Argument_Type"))
						break;
					soap_flag_posix__Argument = 0;
				}
				a->posix__Argument = (struct posix__Argument_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_posix__Argument && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_posix__Input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__FileName_USCOREType(soap, "posix:Input", &a->posix__Input, "posix:FileName_Type"))
				{	soap_flag_posix__Input--;
					continue;
				}
			if (soap_flag_posix__Output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__FileName_USCOREType(soap, "posix:Output", &a->posix__Output, "posix:FileName_Type"))
				{	soap_flag_posix__Output--;
					continue;
				}
			if (soap_flag_posix__Error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__FileName_USCOREType(soap, "posix:Error", &a->posix__Error, "posix:FileName_Type"))
				{	soap_flag_posix__Error--;
					continue;
				}
			if (soap_flag_posix__WorkingDirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__DirectoryName_USCOREType(soap, "posix:WorkingDirectory", &a->posix__WorkingDirectory, "posix:DirectoryName_Type"))
				{	soap_flag_posix__WorkingDirectory--;
					continue;
				}
			if (soap_flag_posix__Environment && soap->error == SOAP_TAG_MISMATCH)
			{	struct posix__Environment_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeEnvironment = 0; !soap_element_begin_in(soap, "posix:Environment", 1, NULL); a->__sizeEnvironment++)
				{	p = (struct posix__Environment_USCOREType *)soap_push_block(soap, sizeof(struct posix__Environment_USCOREType));
					soap_default_posix__Environment_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_posix__Environment_USCOREType(soap, "posix:Environment", p, "posix:Environment_Type"))
						break;
					soap_flag_posix__Environment = 0;
				}
				a->posix__Environment = (struct posix__Environment_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_posix__Environment && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_posix__WallTimeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:WallTimeLimit", &a->posix__WallTimeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__WallTimeLimit--;
					continue;
				}
			if (soap_flag_posix__FileSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:FileSizeLimit", &a->posix__FileSizeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__FileSizeLimit--;
					continue;
				}
			if (soap_flag_posix__CoreDumpLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:CoreDumpLimit", &a->posix__CoreDumpLimit, "posix:Limits_Type"))
				{	soap_flag_posix__CoreDumpLimit--;
					continue;
				}
			if (soap_flag_posix__DataSegmentLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:DataSegmentLimit", &a->posix__DataSegmentLimit, "posix:Limits_Type"))
				{	soap_flag_posix__DataSegmentLimit--;
					continue;
				}
			if (soap_flag_posix__LockedMemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:LockedMemoryLimit", &a->posix__LockedMemoryLimit, "posix:Limits_Type"))
				{	soap_flag_posix__LockedMemoryLimit--;
					continue;
				}
			if (soap_flag_posix__MemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:MemoryLimit", &a->posix__MemoryLimit, "posix:Limits_Type"))
				{	soap_flag_posix__MemoryLimit--;
					continue;
				}
			if (soap_flag_posix__OpenDescriptorsLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:OpenDescriptorsLimit", &a->posix__OpenDescriptorsLimit, "posix:Limits_Type"))
				{	soap_flag_posix__OpenDescriptorsLimit--;
					continue;
				}
			if (soap_flag_posix__PipeSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:PipeSizeLimit", &a->posix__PipeSizeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__PipeSizeLimit--;
					continue;
				}
			if (soap_flag_posix__StackSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:StackSizeLimit", &a->posix__StackSizeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__StackSizeLimit--;
					continue;
				}
			if (soap_flag_posix__CPUTimeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:CPUTimeLimit", &a->posix__CPUTimeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__CPUTimeLimit--;
					continue;
				}
			if (soap_flag_posix__ProcessCountLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:ProcessCountLimit", &a->posix__ProcessCountLimit, "posix:Limits_Type"))
				{	soap_flag_posix__ProcessCountLimit--;
					continue;
				}
			if (soap_flag_posix__VirtualMemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:VirtualMemoryLimit", &a->posix__VirtualMemoryLimit, "posix:Limits_Type"))
				{	soap_flag_posix__VirtualMemoryLimit--;
					continue;
				}
			if (soap_flag_posix__ThreadCountLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:ThreadCountLimit", &a->posix__ThreadCountLimit, "posix:Limits_Type"))
				{	soap_flag_posix__ThreadCountLimit--;
					continue;
				}
			if (soap_flag_posix__UserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__UserName_USCOREType(soap, "posix:UserName", &a->posix__UserName, "posix:UserName_Type"))
				{	soap_flag_posix__UserName--;
					continue;
				}
			if (soap_flag_posix__GroupName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__GroupName_USCOREType(soap, "posix:GroupName", &a->posix__GroupName, "posix:GroupName_Type"))
				{	soap_flag_posix__GroupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct posix__POSIXApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__posix__POSIXApplication, 0, sizeof(struct posix__POSIXApplication_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__app__UserName(struct soap *soap, struct app__UserName_USCOREType *a)
{	soap_default_app__UserName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__app__UserName(struct soap *soap, struct app__UserName_USCOREType const*a)
{	soap_serialize_app__UserName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__app__UserName(struct soap *soap, const struct app__UserName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__app__UserName);
	if (soap_out__app__UserName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__app__UserName(struct soap *soap, const char *tag, int id, const struct app__UserName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__UserName_USCOREType * SOAP_FMAC4 soap_get__app__UserName(struct soap *soap, struct app__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__app__UserName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__UserName_USCOREType * SOAP_FMAC4 soap_in__app__UserName(struct soap *soap, const char *tag, struct app__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__UserName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__app__UserName, sizeof(struct app__UserName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__app__UserName(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__app__Environment(struct soap *soap, struct app__Environment_USCOREType *a)
{	soap_default_app__Environment_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__app__Environment(struct soap *soap, struct app__Environment_USCOREType const*a)
{	soap_serialize_app__Environment_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__app__Environment(struct soap *soap, const struct app__Environment_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__app__Environment);
	if (soap_out__app__Environment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__app__Environment(struct soap *soap, const char *tag, int id, const struct app__Environment_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__Environment_USCOREType * SOAP_FMAC4 soap_get__app__Environment(struct soap *soap, struct app__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__app__Environment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__Environment_USCOREType * SOAP_FMAC4 soap_in__app__Environment(struct soap *soap, const char *tag, struct app__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__Environment_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__app__Environment, sizeof(struct app__Environment_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__app__Environment(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__app__WorkingDirectory(struct soap *soap, struct app__DirectoryName_USCOREType *a)
{	soap_default_app__DirectoryName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__app__WorkingDirectory(struct soap *soap, struct app__DirectoryName_USCOREType const*a)
{	soap_serialize_app__DirectoryName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__app__WorkingDirectory(struct soap *soap, const struct app__DirectoryName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__app__WorkingDirectory);
	if (soap_out__app__WorkingDirectory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__app__WorkingDirectory(struct soap *soap, const char *tag, int id, const struct app__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__DirectoryName_USCOREType * SOAP_FMAC4 soap_get__app__WorkingDirectory(struct soap *soap, struct app__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__app__WorkingDirectory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__DirectoryName_USCOREType * SOAP_FMAC4 soap_in__app__WorkingDirectory(struct soap *soap, const char *tag, struct app__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__DirectoryName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__app__WorkingDirectory, sizeof(struct app__DirectoryName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__app__WorkingDirectory(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__app__Error(struct soap *soap, struct app__FileName_USCOREType *a)
{	soap_default_app__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__app__Error(struct soap *soap, struct app__FileName_USCOREType const*a)
{	soap_serialize_app__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__app__Error(struct soap *soap, const struct app__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__app__Error);
	if (soap_out__app__Error(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__app__Error(struct soap *soap, const char *tag, int id, const struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_get__app__Error(struct soap *soap, struct app__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__app__Error(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_in__app__Error(struct soap *soap, const char *tag, struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__app__Error, sizeof(struct app__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__app__Error(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__app__Output(struct soap *soap, struct app__FileName_USCOREType *a)
{	soap_default_app__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__app__Output(struct soap *soap, struct app__FileName_USCOREType const*a)
{	soap_serialize_app__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__app__Output(struct soap *soap, const struct app__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__app__Output);
	if (soap_out__app__Output(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__app__Output(struct soap *soap, const char *tag, int id, const struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_get__app__Output(struct soap *soap, struct app__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__app__Output(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_in__app__Output(struct soap *soap, const char *tag, struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__app__Output, sizeof(struct app__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__app__Output(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__app__Input(struct soap *soap, struct app__FileName_USCOREType *a)
{	soap_default_app__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__app__Input(struct soap *soap, struct app__FileName_USCOREType const*a)
{	soap_serialize_app__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__app__Input(struct soap *soap, const struct app__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__app__Input);
	if (soap_out__app__Input(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__app__Input(struct soap *soap, const char *tag, int id, const struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_get__app__Input(struct soap *soap, struct app__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__app__Input(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_in__app__Input(struct soap *soap, const char *tag, struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__app__Input, sizeof(struct app__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__app__Input(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__app__Argument(struct soap *soap, struct app__Argument_USCOREType *a)
{	soap_default_app__Argument_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__app__Argument(struct soap *soap, struct app__Argument_USCOREType const*a)
{	soap_serialize_app__Argument_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__app__Argument(struct soap *soap, const struct app__Argument_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__app__Argument);
	if (soap_out__app__Argument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__app__Argument(struct soap *soap, const char *tag, int id, const struct app__Argument_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__Argument_USCOREType * SOAP_FMAC4 soap_get__app__Argument(struct soap *soap, struct app__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__app__Argument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__Argument_USCOREType * SOAP_FMAC4 soap_in__app__Argument(struct soap *soap, const char *tag, struct app__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__Argument_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__app__Argument, sizeof(struct app__Argument_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__app__Argument(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__app__Executable(struct soap *soap, struct app__FileName_USCOREType *a)
{	soap_default_app__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__app__Executable(struct soap *soap, struct app__FileName_USCOREType const*a)
{	soap_serialize_app__FileName_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__app__Executable(struct soap *soap, const struct app__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__app__Executable);
	if (soap_out__app__Executable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__app__Executable(struct soap *soap, const char *tag, int id, const struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_get__app__Executable(struct soap *soap, struct app__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__app__Executable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_in__app__Executable(struct soap *soap, const char *tag, struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__app__Executable, sizeof(struct app__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__app__Executable(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__app__HPCProfileApplication(struct soap *soap, struct app__HPCProfileApplication_USCOREType *a)
{	soap_default_app__HPCProfileApplication_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__app__HPCProfileApplication(struct soap *soap, struct app__HPCProfileApplication_USCOREType const*a)
{	soap_serialize_app__HPCProfileApplication_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__app__HPCProfileApplication(struct soap *soap, const struct app__HPCProfileApplication_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__app__HPCProfileApplication);
	if (soap_out__app__HPCProfileApplication(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__app__HPCProfileApplication(struct soap *soap, const char *tag, int id, const struct app__HPCProfileApplication_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__app__HPCProfileApplication), type))
		return soap->error;
	if (soap_out_PointerToapp__FileName_USCOREType(soap, "app:Executable", -1, &a->app__Executable, ""))
		return soap->error;
	if (a->app__Argument)
	{	int i;
		for (i = 0; i < a->__sizeArgument; i++)
			if (soap_out_app__Argument_USCOREType(soap, "app:Argument", -1, a->app__Argument + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToapp__FileName_USCOREType(soap, "app:Input", -1, &a->app__Input, ""))
		return soap->error;
	if (soap_out_PointerToapp__FileName_USCOREType(soap, "app:Output", -1, &a->app__Output, ""))
		return soap->error;
	if (soap_out_PointerToapp__FileName_USCOREType(soap, "app:Error", -1, &a->app__Error, ""))
		return soap->error;
	if (soap_out_PointerToapp__DirectoryName_USCOREType(soap, "app:WorkingDirectory", -1, &a->app__WorkingDirectory, ""))
		return soap->error;
	if (a->app__Environment)
	{	int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
			if (soap_out_app__Environment_USCOREType(soap, "app:Environment", -1, a->app__Environment + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToapp__UserName_USCOREType(soap, "app:UserName", -1, &a->app__UserName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct app__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_get__app__HPCProfileApplication(struct soap *soap, struct app__HPCProfileApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__app__HPCProfileApplication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_in__app__HPCProfileApplication(struct soap *soap, const char *tag, struct app__HPCProfileApplication_USCOREType *a, const char *type)
{
	short soap_flag_app__Executable = 1, soap_flag_app__Argument = 1, soap_flag_app__Input = 1, soap_flag_app__Output = 1, soap_flag_app__Error = 1, soap_flag_app__WorkingDirectory = 1, soap_flag_app__Environment = 1, soap_flag_app__UserName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct app__HPCProfileApplication_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__app__HPCProfileApplication, sizeof(struct app__HPCProfileApplication_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__app__HPCProfileApplication(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_app__Executable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__FileName_USCOREType(soap, "app:Executable", &a->app__Executable, "app:FileName_Type"))
				{	soap_flag_app__Executable--;
					continue;
				}
			if (soap_flag_app__Argument && soap->error == SOAP_TAG_MISMATCH)
			{	struct app__Argument_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeArgument = 0; !soap_element_begin_in(soap, "app:Argument", 1, NULL); a->__sizeArgument++)
				{	p = (struct app__Argument_USCOREType *)soap_push_block(soap, sizeof(struct app__Argument_USCOREType));
					soap_default_app__Argument_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_app__Argument_USCOREType(soap, "app:Argument", p, "app:Argument_Type"))
						break;
					soap_flag_app__Argument = 0;
				}
				a->app__Argument = (struct app__Argument_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_app__Argument && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_app__Input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__FileName_USCOREType(soap, "app:Input", &a->app__Input, "app:FileName_Type"))
				{	soap_flag_app__Input--;
					continue;
				}
			if (soap_flag_app__Output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__FileName_USCOREType(soap, "app:Output", &a->app__Output, "app:FileName_Type"))
				{	soap_flag_app__Output--;
					continue;
				}
			if (soap_flag_app__Error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__FileName_USCOREType(soap, "app:Error", &a->app__Error, "app:FileName_Type"))
				{	soap_flag_app__Error--;
					continue;
				}
			if (soap_flag_app__WorkingDirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__DirectoryName_USCOREType(soap, "app:WorkingDirectory", &a->app__WorkingDirectory, "app:DirectoryName_Type"))
				{	soap_flag_app__WorkingDirectory--;
					continue;
				}
			if (soap_flag_app__Environment && soap->error == SOAP_TAG_MISMATCH)
			{	struct app__Environment_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeEnvironment = 0; !soap_element_begin_in(soap, "app:Environment", 1, NULL); a->__sizeEnvironment++)
				{	p = (struct app__Environment_USCOREType *)soap_push_block(soap, sizeof(struct app__Environment_USCOREType));
					soap_default_app__Environment_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_app__Environment_USCOREType(soap, "app:Environment", p, "app:Environment_Type"))
						break;
					soap_flag_app__Environment = 0;
				}
				a->app__Environment = (struct app__Environment_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_app__Environment && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_app__UserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__UserName_USCOREType(soap, "app:UserName", &a->app__UserName, "app:UserName_Type"))
				{	soap_flag_app__UserName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct app__HPCProfileApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__app__HPCProfileApplication, 0, sizeof(struct app__HPCProfileApplication_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__Target(struct soap *soap, struct jsdl__SourceTarget_USCOREType *a)
{	soap_default_jsdl__SourceTarget_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__Target(struct soap *soap, struct jsdl__SourceTarget_USCOREType const*a)
{	soap_serialize_jsdl__SourceTarget_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__Target(struct soap *soap, const struct jsdl__SourceTarget_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Target);
	if (soap_out__jsdl__Target(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__Target(struct soap *soap, const char *tag, int id, const struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__Target), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "jsdl:URI", -1, &a->jsdl__URI, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get__jsdl__Target(struct soap *soap, struct jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Target(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in__jsdl__Target(struct soap *soap, const char *tag, struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__URI = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__SourceTarget_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__Target, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__Target(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "jsdl:URI", &a->jsdl__URI, "xsd:anyURI"))
				{	soap_flag_jsdl__URI--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__Target, 0, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__Source(struct soap *soap, struct jsdl__SourceTarget_USCOREType *a)
{	soap_default_jsdl__SourceTarget_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__Source(struct soap *soap, struct jsdl__SourceTarget_USCOREType const*a)
{	soap_serialize_jsdl__SourceTarget_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__Source(struct soap *soap, const struct jsdl__SourceTarget_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Source);
	if (soap_out__jsdl__Source(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__Source(struct soap *soap, const char *tag, int id, const struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__Source), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "jsdl:URI", -1, &a->jsdl__URI, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get__jsdl__Source(struct soap *soap, struct jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Source(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in__jsdl__Source(struct soap *soap, const char *tag, struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__URI = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__SourceTarget_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__Source, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__Source(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "jsdl:URI", &a->jsdl__URI, "xsd:anyURI"))
				{	soap_flag_jsdl__URI--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__Source, 0, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__DataStaging(struct soap *soap, struct jsdl__DataStaging_USCOREType *a)
{	soap_default_jsdl__DataStaging_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__DataStaging(struct soap *soap, struct jsdl__DataStaging_USCOREType const*a)
{	soap_serialize_jsdl__DataStaging_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__DataStaging(struct soap *soap, const struct jsdl__DataStaging_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__DataStaging);
	if (soap_out__jsdl__DataStaging(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__DataStaging(struct soap *soap, const char *tag, int id, const struct jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__DataStaging), type))
		return soap->error;
	if (soap_out_string(soap, "jsdl:FileName", -1, &a->jsdl__FileName, ""))
		return soap->error;
	if (soap_out_xsd__NCName(soap, "jsdl:FilesystemName", -1, &a->jsdl__FilesystemName, ""))
		return soap->error;
	if (soap_out_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", -1, &a->jsdl__CreationFlag, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "jsdl:DeleteOnTermination", -1, &a->jsdl__DeleteOnTermination, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", -1, &a->jsdl__Source, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", -1, &a->jsdl__Target, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_get__jsdl__DataStaging(struct soap *soap, struct jsdl__DataStaging_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__DataStaging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_in__jsdl__DataStaging(struct soap *soap, const char *tag, struct jsdl__DataStaging_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__FileName = 1, soap_flag_jsdl__FilesystemName = 1, soap_flag_jsdl__CreationFlag = 1, soap_flag_jsdl__DeleteOnTermination = 1, soap_flag_jsdl__Source = 1, soap_flag_jsdl__Target = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__DataStaging_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__DataStaging, sizeof(struct jsdl__DataStaging_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__DataStaging(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:FileName", &a->jsdl__FileName, "xsd:string"))
				{	soap_flag_jsdl__FileName--;
					continue;
				}
			if (soap_flag_jsdl__FilesystemName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__NCName(soap, "jsdl:FilesystemName", &a->jsdl__FilesystemName, "xsd:NCName"))
				{	soap_flag_jsdl__FilesystemName--;
					continue;
				}
			if (soap_flag_jsdl__CreationFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", &a->jsdl__CreationFlag, "jsdl:CreationFlagEnumeration"))
				{	soap_flag_jsdl__CreationFlag--;
					continue;
				}
			if (soap_flag_jsdl__DeleteOnTermination && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "jsdl:DeleteOnTermination", &a->jsdl__DeleteOnTermination, "xsd:boolean"))
				{	soap_flag_jsdl__DeleteOnTermination--;
					continue;
				}
			if (soap_flag_jsdl__Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", &a->jsdl__Source, "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Source--;
					continue;
				}
			if (soap_flag_jsdl__Target && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", &a->jsdl__Target, "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Target--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__DataStaging_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__DataStaging, 0, sizeof(struct jsdl__DataStaging_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__FileName > 0 || soap_flag_jsdl__CreationFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__TotalResourceCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__TotalResourceCount(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__TotalResourceCount(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalResourceCount);
	if (soap_out__jsdl__TotalResourceCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__TotalResourceCount(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalResourceCount), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalResourceCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalResourceCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalResourceCount(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalResourceCount, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalResourceCount(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalResourceCount, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__TotalDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__TotalDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__TotalDiskSpace(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalDiskSpace);
	if (soap_out__jsdl__TotalDiskSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__TotalDiskSpace(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalDiskSpace), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalDiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalDiskSpace(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalDiskSpace, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalDiskSpace(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalDiskSpace, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__TotalVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__TotalVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__TotalVirtualMemory(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalVirtualMemory);
	if (soap_out__jsdl__TotalVirtualMemory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__TotalVirtualMemory(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalVirtualMemory), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalVirtualMemory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalVirtualMemory(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalVirtualMemory, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalVirtualMemory(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalVirtualMemory, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__TotalPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__TotalPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__TotalPhysicalMemory(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalPhysicalMemory);
	if (soap_out__jsdl__TotalPhysicalMemory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__TotalPhysicalMemory(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalPhysicalMemory), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalPhysicalMemory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalPhysicalMemory(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalPhysicalMemory, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalPhysicalMemory(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalPhysicalMemory, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__TotalCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__TotalCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__TotalCPUCount(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalCPUCount);
	if (soap_out__jsdl__TotalCPUCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__TotalCPUCount(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalCPUCount), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalCPUCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalCPUCount(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalCPUCount, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalCPUCount(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalCPUCount, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__TotalCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__TotalCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__TotalCPUTime(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__TotalCPUTime);
	if (soap_out__jsdl__TotalCPUTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__TotalCPUTime(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__TotalCPUTime), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__TotalCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__TotalCPUTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__TotalCPUTime(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__TotalCPUTime, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__TotalCPUTime(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__TotalCPUTime, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__IndividualDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__IndividualDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__IndividualDiskSpace(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualDiskSpace);
	if (soap_out__jsdl__IndividualDiskSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__IndividualDiskSpace(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualDiskSpace), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualDiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualDiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualDiskSpace(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualDiskSpace, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualDiskSpace(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualDiskSpace, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__IndividualNetworkBandwidth(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__IndividualNetworkBandwidth(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__IndividualNetworkBandwidth(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualNetworkBandwidth);
	if (soap_out__jsdl__IndividualNetworkBandwidth(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__IndividualNetworkBandwidth(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualNetworkBandwidth), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualNetworkBandwidth(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualNetworkBandwidth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualNetworkBandwidth(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualNetworkBandwidth, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualNetworkBandwidth(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualNetworkBandwidth, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__IndividualVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__IndividualVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__IndividualVirtualMemory(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualVirtualMemory);
	if (soap_out__jsdl__IndividualVirtualMemory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__IndividualVirtualMemory(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualVirtualMemory), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualVirtualMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualVirtualMemory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualVirtualMemory(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualVirtualMemory, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualVirtualMemory(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualVirtualMemory, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__IndividualPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__IndividualPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__IndividualPhysicalMemory(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualPhysicalMemory);
	if (soap_out__jsdl__IndividualPhysicalMemory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__IndividualPhysicalMemory(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualPhysicalMemory), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualPhysicalMemory(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualPhysicalMemory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualPhysicalMemory(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualPhysicalMemory, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualPhysicalMemory(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualPhysicalMemory, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__IndividualCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__IndividualCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__IndividualCPUCount(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualCPUCount);
	if (soap_out__jsdl__IndividualCPUCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__IndividualCPUCount(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualCPUCount), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualCPUCount(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualCPUCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualCPUCount(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualCPUCount, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualCPUCount(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualCPUCount, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__IndividualCPUSpeed(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__IndividualCPUSpeed(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__IndividualCPUSpeed(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualCPUSpeed);
	if (soap_out__jsdl__IndividualCPUSpeed(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__IndividualCPUSpeed(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualCPUSpeed), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualCPUSpeed(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualCPUSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualCPUSpeed(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualCPUSpeed, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualCPUSpeed(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualCPUSpeed, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__IndividualCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__IndividualCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__IndividualCPUTime(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__IndividualCPUTime);
	if (soap_out__jsdl__IndividualCPUTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__IndividualCPUTime(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__IndividualCPUTime), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__IndividualCPUTime(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__IndividualCPUTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__IndividualCPUTime(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__IndividualCPUTime, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__IndividualCPUTime(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__IndividualCPUTime, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__DiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{	soap_default_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__DiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType const*a)
{	soap_serialize_jsdl__RangeValue_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__DiskSpace(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__DiskSpace);
	if (soap_out__jsdl__DiskSpace(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__DiskSpace(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__DiskSpace), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get__jsdl__DiskSpace(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__DiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in__jsdl__DiskSpace(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__DiskSpace, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__DiskSpace(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__DiskSpace, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__FileSystem(struct soap *soap, struct jsdl__FileSystem_USCOREType *a)
{	soap_default_jsdl__FileSystem_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__FileSystem(struct soap *soap, struct jsdl__FileSystem_USCOREType const*a)
{	soap_serialize_jsdl__FileSystem_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__FileSystem(struct soap *soap, const struct jsdl__FileSystem_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__FileSystem);
	if (soap_out__jsdl__FileSystem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__FileSystem(struct soap *soap, const char *tag, int id, const struct jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__FileSystem), type))
		return soap->error;
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", -1, &a->jsdl__FileSystemType, ""))
		return soap->error;
	if (soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, ""))
		return soap->error;
	if (soap_out_string(soap, "jsdl:MountPoint", -1, &a->jsdl__MountPoint, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", -1, &a->jsdl__DiskSpace, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_get__jsdl__FileSystem(struct soap *soap, struct jsdl__FileSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__FileSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_in__jsdl__FileSystem(struct soap *soap, const char *tag, struct jsdl__FileSystem_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__FileSystemType = 1, soap_flag_jsdl__Description = 1, soap_flag_jsdl__MountPoint = 1, soap_flag_jsdl__DiskSpace = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__FileSystem_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__FileSystem, sizeof(struct jsdl__FileSystem_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__FileSystem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileSystemType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", &a->jsdl__FileSystemType, "jsdl:FileSystemTypeEnumeration"))
				{	soap_flag_jsdl__FileSystemType--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag_jsdl__MountPoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:MountPoint", &a->jsdl__MountPoint, "xsd:string"))
				{	soap_flag_jsdl__MountPoint--;
					continue;
				}
			if (soap_flag_jsdl__DiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", &a->jsdl__DiskSpace, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__DiskSpace--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__FileSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__FileSystem, 0, sizeof(struct jsdl__FileSystem_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__CPUArchitecture(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *a)
{	soap_default_jsdl__CPUArchitecture_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__CPUArchitecture(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType const*a)
{	soap_serialize_jsdl__CPUArchitecture_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__CPUArchitecture(struct soap *soap, const struct jsdl__CPUArchitecture_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__CPUArchitecture);
	if (soap_out__jsdl__CPUArchitecture(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__CPUArchitecture(struct soap *soap, const char *tag, int id, const struct jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__CPUArchitecture), type))
		return soap->error;
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", -1, &a->jsdl__CPUArchitectureName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_get__jsdl__CPUArchitecture(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__CPUArchitecture(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_in__jsdl__CPUArchitecture(struct soap *soap, const char *tag, struct jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__CPUArchitectureName = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__CPUArchitecture_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__CPUArchitecture, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__CPUArchitecture(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CPUArchitectureName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", &a->jsdl__CPUArchitectureName, "jsdl:ProcessorArchitectureEnumeration"))
				{	soap_flag_jsdl__CPUArchitectureName--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__CPUArchitecture_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__CPUArchitecture, 0, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__CPUArchitectureName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__OperatingSystemType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *a)
{	soap_default_jsdl__OperatingSystemType_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__OperatingSystemType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType const*a)
{	soap_serialize_jsdl__OperatingSystemType_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__OperatingSystemType(struct soap *soap, const struct jsdl__OperatingSystemType_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__OperatingSystemType);
	if (soap_out__jsdl__OperatingSystemType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__OperatingSystemType(struct soap *soap, const char *tag, int id, const struct jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__OperatingSystemType), type))
		return soap->error;
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", -1, &a->jsdl__OperatingSystemName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_get__jsdl__OperatingSystemType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__OperatingSystemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_in__jsdl__OperatingSystemType(struct soap *soap, const char *tag, struct jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__OperatingSystemName = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__OperatingSystemType_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__OperatingSystemType, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__OperatingSystemType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", &a->jsdl__OperatingSystemName, "jsdl:OperatingSystemTypeEnumeration"))
				{	soap_flag_jsdl__OperatingSystemName--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__OperatingSystemType_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__OperatingSystemType, 0, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__OperatingSystemName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__OperatingSystem(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *a)
{	soap_default_jsdl__OperatingSystem_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__OperatingSystem(struct soap *soap, struct jsdl__OperatingSystem_USCOREType const*a)
{	soap_serialize_jsdl__OperatingSystem_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__OperatingSystem(struct soap *soap, const struct jsdl__OperatingSystem_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__OperatingSystem);
	if (soap_out__jsdl__OperatingSystem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__OperatingSystem(struct soap *soap, const char *tag, int id, const struct jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__OperatingSystem), type))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", -1, &a->jsdl__OperatingSystemType, ""))
		return soap->error;
	if (soap_out_string(soap, "jsdl:OperatingSystemVersion", -1, &a->jsdl__OperatingSystemVersion, ""))
		return soap->error;
	if (soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_get__jsdl__OperatingSystem(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__OperatingSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_in__jsdl__OperatingSystem(struct soap *soap, const char *tag, struct jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__OperatingSystemType = 1, soap_flag_jsdl__OperatingSystemVersion = 1, soap_flag_jsdl__Description = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__OperatingSystem_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__OperatingSystem, sizeof(struct jsdl__OperatingSystem_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__OperatingSystem(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", &a->jsdl__OperatingSystemType, "jsdl:OperatingSystemType_Type"))
				{	soap_flag_jsdl__OperatingSystemType--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystemVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:OperatingSystemVersion", &a->jsdl__OperatingSystemVersion, "xsd:string"))
				{	soap_flag_jsdl__OperatingSystemVersion--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__OperatingSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__OperatingSystem, 0, sizeof(struct jsdl__OperatingSystem_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__CandidateHosts(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *a)
{	soap_default_jsdl__CandidateHosts_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__CandidateHosts(struct soap *soap, struct jsdl__CandidateHosts_USCOREType const*a)
{	soap_serialize_jsdl__CandidateHosts_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__CandidateHosts(struct soap *soap, const struct jsdl__CandidateHosts_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__CandidateHosts);
	if (soap_out__jsdl__CandidateHosts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__CandidateHosts(struct soap *soap, const char *tag, int id, const struct jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__CandidateHosts), type))
		return soap->error;
	if (a->jsdl__HostName)
	{	int i;
		for (i = 0; i < a->__sizeHostName; i++)
			if (soap_out_string(soap, "jsdl:HostName", -1, a->jsdl__HostName + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_get__jsdl__CandidateHosts(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__CandidateHosts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_in__jsdl__CandidateHosts(struct soap *soap, const char *tag, struct jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__HostName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__CandidateHosts_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__CandidateHosts, sizeof(struct jsdl__CandidateHosts_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__CandidateHosts(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__HostName && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeHostName = 0; !soap_element_begin_in(soap, "jsdl:HostName", 1, NULL); a->__sizeHostName++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:HostName", p, "xsd:string"))
						break;
					soap_flag_jsdl__HostName = 0;
				}
				a->jsdl__HostName = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__HostName && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__CandidateHosts_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__CandidateHosts, 0, sizeof(struct jsdl__CandidateHosts_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__Resources(struct soap *soap, struct jsdl__Resources_USCOREType *a)
{	soap_default_jsdl__Resources_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__Resources(struct soap *soap, struct jsdl__Resources_USCOREType const*a)
{	soap_serialize_jsdl__Resources_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__Resources(struct soap *soap, const struct jsdl__Resources_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Resources);
	if (soap_out__jsdl__Resources(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__Resources(struct soap *soap, const char *tag, int id, const struct jsdl__Resources_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__Resources), type))
		return soap->error;
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", -1, &a->jsdl__CandidateHosts, ""))
		return soap->error;
	if (a->jsdl__FileSystem)
	{	int i;
		for (i = 0; i < a->__sizeFileSystem; i++)
			if (soap_out_jsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", -1, a->jsdl__FileSystem + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "jsdl:ExclusiveExecution", -1, &a->jsdl__ExclusiveExecution, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", -1, &a->jsdl__OperatingSystem, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", -1, &a->jsdl__CPUArchitecture, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", -1, &a->jsdl__IndividualCPUSpeed, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", -1, &a->jsdl__IndividualCPUTime, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", -1, &a->jsdl__IndividualCPUCount, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", -1, &a->jsdl__IndividualNetworkBandwidth, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", -1, &a->jsdl__IndividualPhysicalMemory, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", -1, &a->jsdl__IndividualVirtualMemory, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", -1, &a->jsdl__IndividualDiskSpace, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", -1, &a->jsdl__TotalCPUTime, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", -1, &a->jsdl__TotalCPUCount, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", -1, &a->jsdl__TotalPhysicalMemory, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", -1, &a->jsdl__TotalVirtualMemory, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", -1, &a->jsdl__TotalDiskSpace, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", -1, &a->jsdl__TotalResourceCount, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType * SOAP_FMAC4 soap_get__jsdl__Resources(struct soap *soap, struct jsdl__Resources_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Resources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType * SOAP_FMAC4 soap_in__jsdl__Resources(struct soap *soap, const char *tag, struct jsdl__Resources_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__CandidateHosts = 1, soap_flag_jsdl__FileSystem = 1, soap_flag_jsdl__ExclusiveExecution = 1, soap_flag_jsdl__OperatingSystem = 1, soap_flag_jsdl__CPUArchitecture = 1, soap_flag_jsdl__IndividualCPUSpeed = 1, soap_flag_jsdl__IndividualCPUTime = 1, soap_flag_jsdl__IndividualCPUCount = 1, soap_flag_jsdl__IndividualNetworkBandwidth = 1, soap_flag_jsdl__IndividualPhysicalMemory = 1, soap_flag_jsdl__IndividualVirtualMemory = 1, soap_flag_jsdl__IndividualDiskSpace = 1, soap_flag_jsdl__TotalCPUTime = 1, soap_flag_jsdl__TotalCPUCount = 1, soap_flag_jsdl__TotalPhysicalMemory = 1, soap_flag_jsdl__TotalVirtualMemory = 1, soap_flag_jsdl__TotalDiskSpace = 1, soap_flag_jsdl__TotalResourceCount = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Resources_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__Resources, sizeof(struct jsdl__Resources_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__Resources(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CandidateHosts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", &a->jsdl__CandidateHosts, "jsdl:CandidateHosts_Type"))
				{	soap_flag_jsdl__CandidateHosts--;
					continue;
				}
			if (soap_flag_jsdl__FileSystem && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__FileSystem_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeFileSystem = 0; !soap_element_begin_in(soap, "jsdl:FileSystem", 1, NULL); a->__sizeFileSystem++)
				{	p = (struct jsdl__FileSystem_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__FileSystem_USCOREType));
					soap_default_jsdl__FileSystem_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", p, "jsdl:FileSystem_Type"))
						break;
					soap_flag_jsdl__FileSystem = 0;
				}
				a->jsdl__FileSystem = (struct jsdl__FileSystem_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__FileSystem && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl__ExclusiveExecution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "jsdl:ExclusiveExecution", &a->jsdl__ExclusiveExecution, "xsd:boolean"))
				{	soap_flag_jsdl__ExclusiveExecution--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", &a->jsdl__OperatingSystem, "jsdl:OperatingSystem_Type"))
				{	soap_flag_jsdl__OperatingSystem--;
					continue;
				}
			if (soap_flag_jsdl__CPUArchitecture && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", &a->jsdl__CPUArchitecture, "jsdl:CPUArchitecture_Type"))
				{	soap_flag_jsdl__CPUArchitecture--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", &a->jsdl__IndividualCPUSpeed, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUSpeed--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", &a->jsdl__IndividualCPUTime, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUTime--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", &a->jsdl__IndividualCPUCount, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUCount--;
					continue;
				}
			if (soap_flag_jsdl__IndividualNetworkBandwidth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", &a->jsdl__IndividualNetworkBandwidth, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualNetworkBandwidth--;
					continue;
				}
			if (soap_flag_jsdl__IndividualPhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", &a->jsdl__IndividualPhysicalMemory, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualPhysicalMemory--;
					continue;
				}
			if (soap_flag_jsdl__IndividualVirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", &a->jsdl__IndividualVirtualMemory, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualVirtualMemory--;
					continue;
				}
			if (soap_flag_jsdl__IndividualDiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", &a->jsdl__IndividualDiskSpace, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualDiskSpace--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", &a->jsdl__TotalCPUTime, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUTime--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", &a->jsdl__TotalCPUCount, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUCount--;
					continue;
				}
			if (soap_flag_jsdl__TotalPhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", &a->jsdl__TotalPhysicalMemory, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalPhysicalMemory--;
					continue;
				}
			if (soap_flag_jsdl__TotalVirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", &a->jsdl__TotalVirtualMemory, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalVirtualMemory--;
					continue;
				}
			if (soap_flag_jsdl__TotalDiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", &a->jsdl__TotalDiskSpace, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalDiskSpace--;
					continue;
				}
			if (soap_flag_jsdl__TotalResourceCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", &a->jsdl__TotalResourceCount, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalResourceCount--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__Resources_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__Resources, 0, sizeof(struct jsdl__Resources_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__Application(struct soap *soap, struct jsdl__Application_USCOREType *a)
{	soap_default_jsdl__Application_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__Application(struct soap *soap, struct jsdl__Application_USCOREType const*a)
{	soap_serialize_jsdl__Application_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__Application(struct soap *soap, const struct jsdl__Application_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Application);
	if (soap_out__jsdl__Application(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__Application(struct soap *soap, const char *tag, int id, const struct jsdl__Application_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__Application), type))
		return soap->error;
	if (soap_out_string(soap, "jsdl:ApplicationName", -1, &a->jsdl__ApplicationName, ""))
		return soap->error;
	if (soap_out_string(soap, "jsdl:ApplicationVersion", -1, &a->jsdl__ApplicationVersion, ""))
		return soap->error;
	if (soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__Application_USCOREType * SOAP_FMAC4 soap_get__jsdl__Application(struct soap *soap, struct jsdl__Application_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Application(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Application_USCOREType * SOAP_FMAC4 soap_in__jsdl__Application(struct soap *soap, const char *tag, struct jsdl__Application_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__ApplicationName = 1, soap_flag_jsdl__ApplicationVersion = 1, soap_flag_jsdl__Description = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Application_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__Application, sizeof(struct jsdl__Application_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__Application(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__ApplicationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:ApplicationName", &a->jsdl__ApplicationName, "xsd:string"))
				{	soap_flag_jsdl__ApplicationName--;
					continue;
				}
			if (soap_flag_jsdl__ApplicationVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:ApplicationVersion", &a->jsdl__ApplicationVersion, "xsd:string"))
				{	soap_flag_jsdl__ApplicationVersion--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__Application_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__Application, 0, sizeof(struct jsdl__Application_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__JobIdentification(struct soap *soap, struct jsdl__JobIdentification_USCOREType *a)
{	soap_default_jsdl__JobIdentification_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__JobIdentification(struct soap *soap, struct jsdl__JobIdentification_USCOREType const*a)
{	soap_serialize_jsdl__JobIdentification_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__JobIdentification(struct soap *soap, const struct jsdl__JobIdentification_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobIdentification);
	if (soap_out__jsdl__JobIdentification(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__JobIdentification(struct soap *soap, const char *tag, int id, const struct jsdl__JobIdentification_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__JobIdentification), type))
		return soap->error;
	if (soap_out_string(soap, "jsdl:JobName", -1, &a->jsdl__JobName, ""))
		return soap->error;
	if (soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, ""))
		return soap->error;
	if (a->jsdl__JobAnnotation)
	{	int i;
		for (i = 0; i < a->__sizeJobAnnotation; i++)
			if (soap_out_string(soap, "jsdl:JobAnnotation", -1, a->jsdl__JobAnnotation + i, ""))
				return soap->error;
	}
	if (a->jsdl__JobProject)
	{	int i;
		for (i = 0; i < a->__sizeJobProject; i++)
			if (soap_out_string(soap, "jsdl:JobProject", -1, a->jsdl__JobProject + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_get__jsdl__JobIdentification(struct soap *soap, struct jsdl__JobIdentification_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_in__jsdl__JobIdentification(struct soap *soap, const char *tag, struct jsdl__JobIdentification_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobName = 1, soap_flag_jsdl__Description = 1, soap_flag_jsdl__JobAnnotation = 1, soap_flag_jsdl__JobProject = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobIdentification_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__JobIdentification, sizeof(struct jsdl__JobIdentification_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__JobIdentification(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:JobName", &a->jsdl__JobName, "xsd:string"))
				{	soap_flag_jsdl__JobName--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag_jsdl__JobAnnotation && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeJobAnnotation = 0; !soap_element_begin_in(soap, "jsdl:JobAnnotation", 1, NULL); a->__sizeJobAnnotation++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:JobAnnotation", p, "xsd:string"))
						break;
					soap_flag_jsdl__JobAnnotation = 0;
				}
				a->jsdl__JobAnnotation = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__JobAnnotation && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl__JobProject && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeJobProject = 0; !soap_element_begin_in(soap, "jsdl:JobProject", 1, NULL); a->__sizeJobProject++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:JobProject", p, "xsd:string"))
						break;
					soap_flag_jsdl__JobProject = 0;
				}
				a->jsdl__JobProject = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__JobProject && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__JobIdentification_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__JobIdentification, 0, sizeof(struct jsdl__JobIdentification_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__JobDescription(struct soap *soap, struct jsdl__JobDescription_USCOREType *a)
{	soap_default_jsdl__JobDescription_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__JobDescription(struct soap *soap, struct jsdl__JobDescription_USCOREType const*a)
{	soap_serialize_jsdl__JobDescription_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__JobDescription(struct soap *soap, const struct jsdl__JobDescription_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobDescription);
	if (soap_out__jsdl__JobDescription(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__JobDescription(struct soap *soap, const char *tag, int id, const struct jsdl__JobDescription_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__JobDescription), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", -1, &a->jsdl__JobIdentification, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", -1, &a->jsdl__Application, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", -1, &a->jsdl__Resources, ""))
		return soap->error;
	if (a->jsdl__DataStaging)
	{	int i;
		for (i = 0; i < a->__sizeDataStaging; i++)
			if (soap_out_jsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", -1, a->jsdl__DataStaging + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_get__jsdl__JobDescription(struct soap *soap, struct jsdl__JobDescription_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_in__jsdl__JobDescription(struct soap *soap, const char *tag, struct jsdl__JobDescription_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobIdentification = 1, soap_flag_jsdl__Application = 1, soap_flag_jsdl__Resources = 1, soap_flag_jsdl__DataStaging = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobDescription_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__JobDescription, sizeof(struct jsdl__JobDescription_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__JobDescription(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobIdentification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", &a->jsdl__JobIdentification, "jsdl:JobIdentification_Type"))
				{	soap_flag_jsdl__JobIdentification--;
					continue;
				}
			if (soap_flag_jsdl__Application && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", &a->jsdl__Application, "jsdl:Application_Type"))
				{	soap_flag_jsdl__Application--;
					continue;
				}
			if (soap_flag_jsdl__Resources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", &a->jsdl__Resources, "jsdl:Resources_Type"))
				{	soap_flag_jsdl__Resources--;
					continue;
				}
			if (soap_flag_jsdl__DataStaging && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__DataStaging_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeDataStaging = 0; !soap_element_begin_in(soap, "jsdl:DataStaging", 1, NULL); a->__sizeDataStaging++)
				{	p = (struct jsdl__DataStaging_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__DataStaging_USCOREType));
					soap_default_jsdl__DataStaging_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", p, "jsdl:DataStaging_Type"))
						break;
					soap_flag_jsdl__DataStaging = 0;
				}
				a->jsdl__DataStaging = (struct jsdl__DataStaging_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__DataStaging && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__JobDescription_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__JobDescription, 0, sizeof(struct jsdl__JobDescription_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__JobDefinition(struct soap *soap, struct jsdl__JobDefinition_USCOREType *a)
{	soap_default_jsdl__JobDefinition_USCOREType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__JobDefinition(struct soap *soap, struct jsdl__JobDefinition_USCOREType const*a)
{	soap_serialize_jsdl__JobDefinition_USCOREType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__JobDefinition(struct soap *soap, const struct jsdl__JobDefinition_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobDefinition);
	if (soap_out__jsdl__JobDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__JobDefinition(struct soap *soap, const char *tag, int id, const struct jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__jsdl__JobDefinition), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", -1, &a->jsdl__JobDescription, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_get__jsdl__JobDefinition(struct soap *soap, struct jsdl__JobDefinition_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_in__jsdl__JobDefinition(struct soap *soap, const char *tag, struct jsdl__JobDefinition_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobDescription = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobDefinition_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__jsdl__JobDefinition, sizeof(struct jsdl__JobDefinition_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__jsdl__JobDefinition(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 0), &a->id))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", &a->jsdl__JobDescription, "jsdl:JobDescription_Type"))
				{	soap_flag_jsdl__JobDescription--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__JobDefinition_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__jsdl__JobDefinition, 0, sizeof(struct jsdl__JobDefinition_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDescription > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__ProblemAction(struct soap *soap, struct wsa__ProblemActionType *a)
{	soap_default_wsa__ProblemActionType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__ProblemAction(struct soap *soap, struct wsa__ProblemActionType const*a)
{	soap_serialize_wsa__ProblemActionType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ProblemAction(struct soap *soap, const struct wsa__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ProblemAction);
	if (soap_out__wsa__ProblemAction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__ProblemAction(struct soap *soap, const char *tag, int id, const struct wsa__ProblemActionType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__ProblemAction), type))
		return soap->error;
	if (soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Action", -1, &a->wsa__Action, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "wsa:SoapAction", -1, &a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ProblemActionType * SOAP_FMAC4 soap_get__wsa__ProblemAction(struct soap *soap, struct wsa__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ProblemAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ProblemActionType * SOAP_FMAC4 soap_in__wsa__ProblemAction(struct soap *soap, const char *tag, struct wsa__ProblemActionType *a, const char *type)
{
	short soap_flag_wsa__Action = 1, soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ProblemAction, sizeof(struct wsa__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__ProblemAction(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__Action && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Action", &a->wsa__Action, "wsa:AttributedURIType"))
				{	soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "wsa:SoapAction", &a->SoapAction, "xsd:anyURI"))
				{	soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__ProblemAction, 0, sizeof(struct wsa__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__ProblemIRI(struct soap *soap, struct wsa__AttributedURIType *a)
{	soap_default_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__ProblemIRI(struct soap *soap, struct wsa__AttributedURIType const*a)
{	soap_serialize_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ProblemIRI(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ProblemIRI);
	if (soap_out__wsa__ProblemIRI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__ProblemIRI(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get__wsa__ProblemIRI(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ProblemIRI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in__wsa__ProblemIRI(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ProblemIRI, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__ProblemIRI(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__ProblemHeaderQName(struct soap *soap, struct wsa__AttributedQNameType *a)
{	soap_default_wsa__AttributedQNameType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__ProblemHeaderQName(struct soap *soap, struct wsa__AttributedQNameType const*a)
{	soap_serialize_wsa__AttributedQNameType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ProblemHeaderQName(struct soap *soap, const struct wsa__AttributedQNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ProblemHeaderQName);
	if (soap_out__wsa__ProblemHeaderQName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__ProblemHeaderQName(struct soap *soap, const char *tag, int id, const struct wsa__AttributedQNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__AttributedQNameType * SOAP_FMAC4 soap_get__wsa__ProblemHeaderQName(struct soap *soap, struct wsa__AttributedQNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ProblemHeaderQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedQNameType * SOAP_FMAC4 soap_in__wsa__ProblemHeaderQName(struct soap *soap, const char *tag, struct wsa__AttributedQNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedQNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ProblemHeaderQName, sizeof(struct wsa__AttributedQNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__ProblemHeaderQName(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in__QName(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__RetryAfter(struct soap *soap, struct wsa__AttributedUnsignedLongType *a)
{	soap_default_wsa__AttributedUnsignedLongType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__RetryAfter(struct soap *soap, struct wsa__AttributedUnsignedLongType const*a)
{	soap_serialize_wsa__AttributedUnsignedLongType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__RetryAfter(struct soap *soap, const struct wsa__AttributedUnsignedLongType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__RetryAfter);
	if (soap_out__wsa__RetryAfter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__RetryAfter(struct soap *soap, const char *tag, int id, const struct wsa__AttributedUnsignedLongType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedUnsignedLongType * SOAP_FMAC4 soap_get__wsa__RetryAfter(struct soap *soap, struct wsa__AttributedUnsignedLongType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__RetryAfter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedUnsignedLongType * SOAP_FMAC4 soap_in__wsa__RetryAfter(struct soap *soap, const char *tag, struct wsa__AttributedUnsignedLongType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedUnsignedLongType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__RetryAfter, sizeof(struct wsa__AttributedUnsignedLongType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__RetryAfter(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_unsignedLONG64(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__Action(struct soap *soap, struct wsa__AttributedURIType *a)
{	soap_default_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__Action(struct soap *soap, struct wsa__AttributedURIType const*a)
{	soap_serialize_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__Action(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__Action);
	if (soap_out__wsa__Action(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__Action(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get__wsa__Action(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__Action(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in__wsa__Action(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__Action, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__Action(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__To(struct soap *soap, struct wsa__AttributedURIType *a)
{	soap_default_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__To(struct soap *soap, struct wsa__AttributedURIType const*a)
{	soap_serialize_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__To(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__To);
	if (soap_out__wsa__To(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__To(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get__wsa__To(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__To(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in__wsa__To(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__To, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__To(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *a)
{	soap_default_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType const*a)
{	soap_serialize_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__FaultTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__FaultTo);
	if (soap_out__wsa__FaultTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__FaultTo(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__FaultTo), type))
		return soap->error;
	if (soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get__wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in__wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__FaultTo(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType"))
				{	soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__FaultTo, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *a)
{	soap_default_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__From(struct soap *soap, struct wsa__EndpointReferenceType const*a)
{	soap_serialize_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__From(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__From);
	if (soap_out__wsa__From(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__From(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__From), type))
		return soap->error;
	if (soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get__wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in__wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__From(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType"))
				{	soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__From, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *a)
{	soap_default_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType const*a)
{	soap_serialize_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ReplyTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ReplyTo);
	if (soap_out__wsa__ReplyTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__ReplyTo(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__ReplyTo), type))
		return soap->error;
	if (soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get__wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in__wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__ReplyTo(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType"))
				{	soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__ReplyTo, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType *a)
{	soap_default_wsa__RelatesToType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType const*a)
{	soap_serialize_wsa__RelatesToType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__RelatesTo(struct soap *soap, const struct wsa__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__RelatesTo);
	if (soap_out__wsa__RelatesTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__RelatesTo(struct soap *soap, const char *tag, int id, const struct wsa__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__RelatesToType * SOAP_FMAC4 soap_get__wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__RelatesToType * SOAP_FMAC4 soap_in__wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__RelatesToType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__RelatesTo(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__MessageID(struct soap *soap, struct wsa__AttributedURIType *a)
{	soap_default_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__MessageID(struct soap *soap, struct wsa__AttributedURIType const*a)
{	soap_serialize_wsa__AttributedURIType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__MessageID(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__MessageID);
	if (soap_out__wsa__MessageID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__MessageID(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get__wsa__MessageID(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__MessageID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in__wsa__MessageID(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__MessageID, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsa__MessageID(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__Metadata(struct soap *soap, struct wsa__MetadataType *a)
{	soap_default_wsa__MetadataType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__Metadata(struct soap *soap, struct wsa__MetadataType const*a)
{	soap_serialize_wsa__MetadataType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__Metadata(struct soap *soap, const struct wsa__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__Metadata);
	if (soap_out__wsa__Metadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__Metadata(struct soap *soap, const char *tag, int id, const struct wsa__MetadataType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__Metadata), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__MetadataType * SOAP_FMAC4 soap_get__wsa__Metadata(struct soap *soap, struct wsa__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__Metadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__MetadataType * SOAP_FMAC4 soap_in__wsa__Metadata(struct soap *soap, const char *tag, struct wsa__MetadataType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__Metadata, sizeof(struct wsa__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__Metadata(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__Metadata, 0, sizeof(struct wsa__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__ReferenceParameters(struct soap *soap, struct wsa__ReferenceParametersType *a)
{	soap_default_wsa__ReferenceParametersType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__ReferenceParameters(struct soap *soap, struct wsa__ReferenceParametersType const*a)
{	soap_serialize_wsa__ReferenceParametersType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ReferenceParameters(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__ReferenceParameters);
	if (soap_out__wsa__ReferenceParameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__ReferenceParameters(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__ReferenceParameters), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get__wsa__ReferenceParameters(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__ReferenceParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in__wsa__ReferenceParameters(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__ReferenceParameters, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__ReferenceParameters(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__ReferenceParameters, 0, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa__EndpointReference(struct soap *soap, struct wsa__EndpointReferenceType *a)
{	soap_default_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa__EndpointReference(struct soap *soap, struct wsa__EndpointReferenceType const*a)
{	soap_serialize_wsa__EndpointReferenceType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__EndpointReference(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa__EndpointReference);
	if (soap_out__wsa__EndpointReference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa__EndpointReference(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa__EndpointReference), type))
		return soap->error;
	if (soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get__wsa__EndpointReference(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa__EndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in__wsa__EndpointReference(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa__EndpointReference, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsa__EndpointReference(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType"))
				{	soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa__EndpointReference, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__ActivityStatus(struct soap *soap, struct bes__ActivityStatusType *a)
{	soap_default_bes__ActivityStatusType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__ActivityStatus(struct soap *soap, struct bes__ActivityStatusType const*a)
{	soap_serialize_bes__ActivityStatusType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__ActivityStatus(struct soap *soap, const struct bes__ActivityStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__ActivityStatus);
	if (soap_out__bes__ActivityStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__ActivityStatus(struct soap *soap, const char *tag, int id, const struct bes__ActivityStatusType *a, const char *type)
{
	soap_set_attr(soap, "state", soap_bes__ActivityStateEnumeration2s(soap, a->state));
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__ActivityStatus), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__ActivityStatusType * SOAP_FMAC4 soap_get__bes__ActivityStatus(struct soap *soap, struct bes__ActivityStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__ActivityStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityStatusType * SOAP_FMAC4 soap_in__bes__ActivityStatus(struct soap *soap, const char *tag, struct bes__ActivityStatusType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__ActivityStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__ActivityStatus, sizeof(struct bes__ActivityStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__ActivityStatus(soap, a);
	if (soap_s2bes__ActivityStateEnumeration(soap, soap_attr_value(soap, "state", 1), &a->state))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__ActivityStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__ActivityStatus, 0, sizeof(struct bes__ActivityStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__ActivityDocument(struct soap *soap, struct bes__ActivityDocumentType *a)
{	soap_default_bes__ActivityDocumentType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__ActivityDocument(struct soap *soap, struct bes__ActivityDocumentType const*a)
{	soap_serialize_bes__ActivityDocumentType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__ActivityDocument(struct soap *soap, const struct bes__ActivityDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__ActivityDocument);
	if (soap_out__bes__ActivityDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__ActivityDocument(struct soap *soap, const char *tag, int id, const struct bes__ActivityDocumentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__ActivityDocument), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__ActivityDocumentType * SOAP_FMAC4 soap_get__bes__ActivityDocument(struct soap *soap, struct bes__ActivityDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__ActivityDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityDocumentType * SOAP_FMAC4 soap_in__bes__ActivityDocument(struct soap *soap, const char *tag, struct bes__ActivityDocumentType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__ActivityDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__ActivityDocument, sizeof(struct bes__ActivityDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__ActivityDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__ActivityDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__ActivityDocument, 0, sizeof(struct bes__ActivityDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__FactoryResourceAttributesDocument(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType *a)
{	soap_default_bes__FactoryResourceAttributesDocumentType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__FactoryResourceAttributesDocument(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType const*a)
{	soap_serialize_bes__FactoryResourceAttributesDocumentType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__FactoryResourceAttributesDocument(struct soap *soap, const struct bes__FactoryResourceAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__FactoryResourceAttributesDocument);
	if (soap_out__bes__FactoryResourceAttributesDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__FactoryResourceAttributesDocument(struct soap *soap, const char *tag, int id, const struct bes__FactoryResourceAttributesDocumentType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__FactoryResourceAttributesDocument), type))
		return soap->error;
	if (soap_out_PointerTobes__BasicResourceAttributesDocumentType(soap, "bes:BasicResourceAttributesDocument", -1, &a->bes__BasicResourceAttributesDocument, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "bes:IsAcceptingNewActivities", -1, &a->IsAcceptingNewActivities, ""))
		return soap->error;
	if (soap_out_string(soap, "bes:CommonName", -1, &a->CommonName, ""))
		return soap->error;
	if (soap_out_string(soap, "bes:LongDescription", -1, &a->LongDescription, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "bes:TotalNumberOfActivities", -1, &a->TotalNumberOfActivities, ""))
		return soap->error;
	if (a->ActivityReference)
	{	int i;
		for (i = 0; i < a->__sizeActivityReference; i++)
			if (soap_out_wsa__EndpointReferenceType(soap, "bes:ActivityReference", -1, a->ActivityReference + i, ""))
				return soap->error;
	}
	if (soap_out_LONG64(soap, "bes:TotalNumberOfContainedResources", -1, &a->TotalNumberOfContainedResources, ""))
		return soap->error;
	if (a->ContainedResource)
	{	int i;
		for (i = 0; i < a->__sizeContainedResource; i++)
			if (soap_out_xsd__anyType(soap, "bes:ContainedResource", -1, a->ContainedResource + i, ""))
				return soap->error;
	}
	if (a->NamingProfile)
	{	int i;
		for (i = 0; i < a->__sizeNamingProfile; i++)
			if (soap_out_xsd__anyURI(soap, "bes:NamingProfile", -1, a->NamingProfile + i, ""))
				return soap->error;
	}
	if (a->BESExtension)
	{	int i;
		for (i = 0; i < a->__sizeBESExtension; i++)
			if (soap_out_xsd__anyURI(soap, "bes:BESExtension", -1, a->BESExtension + i, ""))
				return soap->error;
	}
	if (soap_out_xsd__anyURI(soap, "bes:LocalResourceManagerType", -1, &a->LocalResourceManagerType, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_get__bes__FactoryResourceAttributesDocument(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__FactoryResourceAttributesDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_in__bes__FactoryResourceAttributesDocument(struct soap *soap, const char *tag, struct bes__FactoryResourceAttributesDocumentType *a, const char *type)
{
	short soap_flag_bes__BasicResourceAttributesDocument = 1, soap_flag_IsAcceptingNewActivities = 1, soap_flag_CommonName = 1, soap_flag_LongDescription = 1, soap_flag_TotalNumberOfActivities = 1, soap_flag_ActivityReference = 1, soap_flag_TotalNumberOfContainedResources = 1, soap_flag_ContainedResource = 1, soap_flag_NamingProfile = 1, soap_flag_BESExtension = 1, soap_flag_LocalResourceManagerType = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__FactoryResourceAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__FactoryResourceAttributesDocument, sizeof(struct bes__FactoryResourceAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__FactoryResourceAttributesDocument(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__BasicResourceAttributesDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__BasicResourceAttributesDocumentType(soap, "bes:BasicResourceAttributesDocument", &a->bes__BasicResourceAttributesDocument, "bes:BasicResourceAttributesDocumentType"))
				{	soap_flag_bes__BasicResourceAttributesDocument--;
					continue;
				}
			if (soap_flag_IsAcceptingNewActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "bes:IsAcceptingNewActivities", &a->IsAcceptingNewActivities, "xsd:boolean"))
				{	soap_flag_IsAcceptingNewActivities--;
					continue;
				}
			if (soap_flag_CommonName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:CommonName", &a->CommonName, "xsd:string"))
				{	soap_flag_CommonName--;
					continue;
				}
			if (soap_flag_LongDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:LongDescription", &a->LongDescription, "xsd:string"))
				{	soap_flag_LongDescription--;
					continue;
				}
			if (soap_flag_TotalNumberOfActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "bes:TotalNumberOfActivities", &a->TotalNumberOfActivities, "xsd:long"))
				{	soap_flag_TotalNumberOfActivities--;
					continue;
				}
			if (soap_flag_ActivityReference && soap->error == SOAP_TAG_MISMATCH)
			{	struct wsa__EndpointReferenceType *p;
				soap_new_block(soap);
				for (a->__sizeActivityReference = 0; !soap_element_begin_in(soap, "bes:ActivityReference", 1, NULL); a->__sizeActivityReference++)
				{	p = (struct wsa__EndpointReferenceType *)soap_push_block(soap, sizeof(struct wsa__EndpointReferenceType));
					soap_default_wsa__EndpointReferenceType(soap, p);
					soap_revert(soap);
					if (!soap_in_wsa__EndpointReferenceType(soap, "bes:ActivityReference", p, "wsa:EndpointReferenceType"))
						break;
					soap_flag_ActivityReference = 0;
				}
				a->ActivityReference = (struct wsa__EndpointReferenceType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ActivityReference && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_TotalNumberOfContainedResources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "bes:TotalNumberOfContainedResources", &a->TotalNumberOfContainedResources, "xsd:long"))
				{	soap_flag_TotalNumberOfContainedResources--;
					continue;
				}
			if (soap_flag_ContainedResource && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__sizeContainedResource = 0; !soap_element_begin_in(soap, "bes:ContainedResource", 1, NULL); a->__sizeContainedResource++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					soap_revert(soap);
					if (!soap_in_xsd__anyType(soap, "bes:ContainedResource", p, "xsd:anyType"))
						break;
					soap_flag_ContainedResource = 0;
				}
				a->ContainedResource = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ContainedResource && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_NamingProfile && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeNamingProfile = 0; !soap_element_begin_in(soap, "bes:NamingProfile", 1, NULL); a->__sizeNamingProfile++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_xsd__anyURI(soap, "bes:NamingProfile", p, "xsd:anyURI"))
						break;
					soap_flag_NamingProfile = 0;
				}
				a->NamingProfile = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_NamingProfile && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_BESExtension && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeBESExtension = 0; !soap_element_begin_in(soap, "bes:BESExtension", 1, NULL); a->__sizeBESExtension++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_xsd__anyURI(soap, "bes:BESExtension", p, "xsd:anyURI"))
						break;
					soap_flag_BESExtension = 0;
				}
				a->BESExtension = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_BESExtension && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_LocalResourceManagerType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "bes:LocalResourceManagerType", &a->LocalResourceManagerType, "xsd:anyURI"))
				{	soap_flag_LocalResourceManagerType--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__FactoryResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__FactoryResourceAttributesDocument, 0, sizeof(struct bes__FactoryResourceAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IsAcceptingNewActivities > 0 || soap_flag_TotalNumberOfActivities > 0 || soap_flag_TotalNumberOfContainedResources > 0 || soap_flag_LocalResourceManagerType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__BasicResourceAttributesDocument(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *a)
{	soap_default_bes__BasicResourceAttributesDocumentType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__BasicResourceAttributesDocument(struct soap *soap, struct bes__BasicResourceAttributesDocumentType const*a)
{	soap_serialize_bes__BasicResourceAttributesDocumentType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__BasicResourceAttributesDocument(struct soap *soap, const struct bes__BasicResourceAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__BasicResourceAttributesDocument);
	if (soap_out__bes__BasicResourceAttributesDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__BasicResourceAttributesDocument(struct soap *soap, const char *tag, int id, const struct bes__BasicResourceAttributesDocumentType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__BasicResourceAttributesDocument), type))
		return soap->error;
	if (soap_out_string(soap, "bes:ResourceName", -1, &a->ResourceName, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "bes:OperatingSystem", -1, &a->OperatingSystem, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "bes:CPUArchitecture", -1, &a->CPUArchitecture, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "bes:CPUCount", -1, &a->CPUCount, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "bes:CPUSpeed", -1, &a->CPUSpeed, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "bes:PhysicalMemory", -1, &a->PhysicalMemory, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "bes:VirtualMemory", -1, &a->VirtualMemory, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType * SOAP_FMAC4 soap_get__bes__BasicResourceAttributesDocument(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__BasicResourceAttributesDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType * SOAP_FMAC4 soap_in__bes__BasicResourceAttributesDocument(struct soap *soap, const char *tag, struct bes__BasicResourceAttributesDocumentType *a, const char *type)
{
	short soap_flag_ResourceName = 1, soap_flag_OperatingSystem = 1, soap_flag_CPUArchitecture = 1, soap_flag_CPUCount = 1, soap_flag_CPUSpeed = 1, soap_flag_PhysicalMemory = 1, soap_flag_VirtualMemory = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__BasicResourceAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__BasicResourceAttributesDocument, sizeof(struct bes__BasicResourceAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__BasicResourceAttributesDocument(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:ResourceName", &a->ResourceName, "xsd:string"))
				{	soap_flag_ResourceName--;
					continue;
				}
			if (soap_flag_OperatingSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "bes:OperatingSystem", &a->OperatingSystem, "jsdl:OperatingSystem_Type"))
				{	soap_flag_OperatingSystem--;
					continue;
				}
			if (soap_flag_CPUArchitecture && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "bes:CPUArchitecture", &a->CPUArchitecture, "jsdl:CPUArchitecture_Type"))
				{	soap_flag_CPUArchitecture--;
					continue;
				}
			if (soap_flag_CPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:CPUCount", &a->CPUCount, "xsd:double"))
				{	soap_flag_CPUCount--;
					continue;
				}
			if (soap_flag_CPUSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:CPUSpeed", &a->CPUSpeed, "xsd:double"))
				{	soap_flag_CPUSpeed--;
					continue;
				}
			if (soap_flag_PhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:PhysicalMemory", &a->PhysicalMemory, "xsd:double"))
				{	soap_flag_PhysicalMemory--;
					continue;
				}
			if (soap_flag_VirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:VirtualMemory", &a->VirtualMemory, "xsd:double"))
				{	soap_flag_VirtualMemory--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__BasicResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__BasicResourceAttributesDocument, 0, sizeof(struct bes__BasicResourceAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__InvalidRequestMessageFault(struct soap *soap, struct bes__InvalidRequestMessageFaultType *a)
{	soap_default_bes__InvalidRequestMessageFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__InvalidRequestMessageFault(struct soap *soap, struct bes__InvalidRequestMessageFaultType const*a)
{	soap_serialize_bes__InvalidRequestMessageFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__InvalidRequestMessageFault(struct soap *soap, const struct bes__InvalidRequestMessageFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__InvalidRequestMessageFault);
	if (soap_out__bes__InvalidRequestMessageFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__InvalidRequestMessageFault(struct soap *soap, const char *tag, int id, const struct bes__InvalidRequestMessageFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__InvalidRequestMessageFault), type))
		return soap->error;
	if (a->InvalidElement)
	{	int i;
		for (i = 0; i < a->__sizeInvalidElement; i++)
			if (soap_out_string(soap, "bes:InvalidElement", -1, a->InvalidElement + i, ""))
				return soap->error;
	}
	if (soap_out_string(soap, "bes:Message", -1, &a->Message, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType * SOAP_FMAC4 soap_get__bes__InvalidRequestMessageFault(struct soap *soap, struct bes__InvalidRequestMessageFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__InvalidRequestMessageFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType * SOAP_FMAC4 soap_in__bes__InvalidRequestMessageFault(struct soap *soap, const char *tag, struct bes__InvalidRequestMessageFaultType *a, const char *type)
{
	short soap_flag_InvalidElement = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__InvalidRequestMessageFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__InvalidRequestMessageFault, sizeof(struct bes__InvalidRequestMessageFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__InvalidRequestMessageFault(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InvalidElement && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeInvalidElement = 0; !soap_element_begin_in(soap, "bes:InvalidElement", 1, NULL); a->__sizeInvalidElement++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "bes:InvalidElement", p, "xsd:string"))
						break;
					soap_flag_InvalidElement = 0;
				}
				a->InvalidElement = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_InvalidElement && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__InvalidRequestMessageFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__InvalidRequestMessageFault, 0, sizeof(struct bes__InvalidRequestMessageFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__InvalidActivityIdentifierFault(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType *a)
{	soap_default_bes__InvalidActivityIdentifierFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__InvalidActivityIdentifierFault(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType const*a)
{	soap_serialize_bes__InvalidActivityIdentifierFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__InvalidActivityIdentifierFault(struct soap *soap, const struct bes__InvalidActivityIdentifierFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__InvalidActivityIdentifierFault);
	if (soap_out__bes__InvalidActivityIdentifierFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__InvalidActivityIdentifierFault(struct soap *soap, const char *tag, int id, const struct bes__InvalidActivityIdentifierFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__InvalidActivityIdentifierFault), type))
		return soap->error;
	if (soap_out_string(soap, "bes:Message", -1, &a->Message, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__InvalidActivityIdentifierFaultType * SOAP_FMAC4 soap_get__bes__InvalidActivityIdentifierFault(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__InvalidActivityIdentifierFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidActivityIdentifierFaultType * SOAP_FMAC4 soap_in__bes__InvalidActivityIdentifierFault(struct soap *soap, const char *tag, struct bes__InvalidActivityIdentifierFaultType *a, const char *type)
{
	short soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__InvalidActivityIdentifierFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__InvalidActivityIdentifierFault, sizeof(struct bes__InvalidActivityIdentifierFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__InvalidActivityIdentifierFault(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__InvalidActivityIdentifierFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__InvalidActivityIdentifierFault, 0, sizeof(struct bes__InvalidActivityIdentifierFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType *a)
{	soap_default_bes__OperationWillBeAppliedEventuallyFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType const*a)
{	soap_serialize_bes__OperationWillBeAppliedEventuallyFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, const struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault);
	if (soap_out__bes__OperationWillBeAppliedEventuallyFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, const char *tag, int id, const struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault), type))
		return soap->error;
	if (soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->ActivityStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "bes:Message", -1, &a->Message, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__OperationWillBeAppliedEventuallyFaultType * SOAP_FMAC4 soap_get__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__OperationWillBeAppliedEventuallyFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__OperationWillBeAppliedEventuallyFaultType * SOAP_FMAC4 soap_in__bes__OperationWillBeAppliedEventuallyFault(struct soap *soap, const char *tag, struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *type)
{
	short soap_flag_ActivityStatus = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__OperationWillBeAppliedEventuallyFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault, sizeof(struct bes__OperationWillBeAppliedEventuallyFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__OperationWillBeAppliedEventuallyFault(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->ActivityStatus, "bes:ActivityStatusType"))
				{	soap_flag_ActivityStatus--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__OperationWillBeAppliedEventuallyFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__OperationWillBeAppliedEventuallyFault, 0, sizeof(struct bes__OperationWillBeAppliedEventuallyFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityStatus > 0 || soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType *a)
{	soap_default_bes__CantApplyOperationToCurrentStateFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType const*a)
{	soap_serialize_bes__CantApplyOperationToCurrentStateFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, const struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault);
	if (soap_out__bes__CantApplyOperationToCurrentStateFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, const char *tag, int id, const struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault), type))
		return soap->error;
	if (soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->ActivityStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "bes:Message", -1, &a->Message, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__CantApplyOperationToCurrentStateFaultType * SOAP_FMAC4 soap_get__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__CantApplyOperationToCurrentStateFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CantApplyOperationToCurrentStateFaultType * SOAP_FMAC4 soap_in__bes__CantApplyOperationToCurrentStateFault(struct soap *soap, const char *tag, struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *type)
{
	short soap_flag_ActivityStatus = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CantApplyOperationToCurrentStateFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault, sizeof(struct bes__CantApplyOperationToCurrentStateFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__CantApplyOperationToCurrentStateFault(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->ActivityStatus, "bes:ActivityStatusType"))
				{	soap_flag_ActivityStatus--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__CantApplyOperationToCurrentStateFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__CantApplyOperationToCurrentStateFault, 0, sizeof(struct bes__CantApplyOperationToCurrentStateFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityStatus > 0 || soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__UnsupportedFeatureFault(struct soap *soap, struct bes__UnsupportedFeatureFaultType *a)
{	soap_default_bes__UnsupportedFeatureFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__UnsupportedFeatureFault(struct soap *soap, struct bes__UnsupportedFeatureFaultType const*a)
{	soap_serialize_bes__UnsupportedFeatureFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__UnsupportedFeatureFault(struct soap *soap, const struct bes__UnsupportedFeatureFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__UnsupportedFeatureFault);
	if (soap_out__bes__UnsupportedFeatureFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__UnsupportedFeatureFault(struct soap *soap, const char *tag, int id, const struct bes__UnsupportedFeatureFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__UnsupportedFeatureFault), type))
		return soap->error;
	if (a->Feature)
	{	int i;
		for (i = 0; i < a->__sizeFeature; i++)
			if (soap_out_string(soap, "bes:Feature", -1, a->Feature + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_get__bes__UnsupportedFeatureFault(struct soap *soap, struct bes__UnsupportedFeatureFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__UnsupportedFeatureFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_in__bes__UnsupportedFeatureFault(struct soap *soap, const char *tag, struct bes__UnsupportedFeatureFaultType *a, const char *type)
{
	short soap_flag_Feature = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__UnsupportedFeatureFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__UnsupportedFeatureFault, sizeof(struct bes__UnsupportedFeatureFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__UnsupportedFeatureFault(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Feature && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeFeature = 0; !soap_element_begin_in(soap, "bes:Feature", 1, NULL); a->__sizeFeature++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "bes:Feature", p, "xsd:string"))
						break;
					soap_flag_Feature = 0;
				}
				a->Feature = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Feature && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__UnsupportedFeatureFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__UnsupportedFeatureFault, 0, sizeof(struct bes__UnsupportedFeatureFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__NotAcceptingNewActivitiesFault(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *a)
{	soap_default_bes__NotAcceptingNewActivitiesFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__NotAcceptingNewActivitiesFault(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType const*a)
{	soap_serialize_bes__NotAcceptingNewActivitiesFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__NotAcceptingNewActivitiesFault(struct soap *soap, const struct bes__NotAcceptingNewActivitiesFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__NotAcceptingNewActivitiesFault);
	if (soap_out__bes__NotAcceptingNewActivitiesFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__NotAcceptingNewActivitiesFault(struct soap *soap, const char *tag, int id, const struct bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__NotAcceptingNewActivitiesFault), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_get__bes__NotAcceptingNewActivitiesFault(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__NotAcceptingNewActivitiesFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_in__bes__NotAcceptingNewActivitiesFault(struct soap *soap, const char *tag, struct bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__NotAcceptingNewActivitiesFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__NotAcceptingNewActivitiesFault, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__NotAcceptingNewActivitiesFault(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__NotAcceptingNewActivitiesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__NotAcceptingNewActivitiesFault, 0, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__NotAuthorizedFault(struct soap *soap, struct bes__NotAuthorizedFaultType *a)
{	soap_default_bes__NotAuthorizedFaultType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__NotAuthorizedFault(struct soap *soap, struct bes__NotAuthorizedFaultType const*a)
{	soap_serialize_bes__NotAuthorizedFaultType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__NotAuthorizedFault(struct soap *soap, const struct bes__NotAuthorizedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__NotAuthorizedFault);
	if (soap_out__bes__NotAuthorizedFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__NotAuthorizedFault(struct soap *soap, const char *tag, int id, const struct bes__NotAuthorizedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__NotAuthorizedFault), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType * SOAP_FMAC4 soap_get__bes__NotAuthorizedFault(struct soap *soap, struct bes__NotAuthorizedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__NotAuthorizedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType * SOAP_FMAC4 soap_in__bes__NotAuthorizedFault(struct soap *soap, const char *tag, struct bes__NotAuthorizedFaultType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__NotAuthorizedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__NotAuthorizedFault, sizeof(struct bes__NotAuthorizedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__NotAuthorizedFault(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__NotAuthorizedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__NotAuthorizedFault, 0, sizeof(struct bes__NotAuthorizedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *a)
{	soap_default_bes__GetFactoryAttributesDocumentResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType const*a)
{	soap_serialize_bes__GetFactoryAttributesDocumentResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, const struct bes__GetFactoryAttributesDocumentResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse);
	if (soap_out__bes__GetFactoryAttributesDocumentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, const char *tag, int id, const struct bes__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse), type))
		return soap->error;
	if (a->__any)
		soap_element_result(soap, "-any");
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_get__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetFactoryAttributesDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_in__bes__GetFactoryAttributesDocumentResponse(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetFactoryAttributesDocumentResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetFactoryAttributesDocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetFactoryAttributesDocumentResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetFactoryAttributesDocumentResponse, 0, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__GetFactoryAttributesDocument(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *a)
{	soap_default_bes__GetFactoryAttributesDocumentType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__GetFactoryAttributesDocument(struct soap *soap, struct bes__GetFactoryAttributesDocumentType const*a)
{	soap_serialize_bes__GetFactoryAttributesDocumentType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__GetFactoryAttributesDocument(struct soap *soap, const struct bes__GetFactoryAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetFactoryAttributesDocument);
	if (soap_out__bes__GetFactoryAttributesDocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetFactoryAttributesDocument(struct soap *soap, const char *tag, int id, const struct bes__GetFactoryAttributesDocumentType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetFactoryAttributesDocument), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_get__bes__GetFactoryAttributesDocument(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetFactoryAttributesDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_in__bes__GetFactoryAttributesDocument(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetFactoryAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetFactoryAttributesDocument, sizeof(struct bes__GetFactoryAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetFactoryAttributesDocument(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetFactoryAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetFactoryAttributesDocument, 0, sizeof(struct bes__GetFactoryAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__GetActivityDocumentsResponse(struct soap *soap, struct bes__GetActivityDocumentsResponseType *a)
{	soap_default_bes__GetActivityDocumentsResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__GetActivityDocumentsResponse(struct soap *soap, struct bes__GetActivityDocumentsResponseType const*a)
{	soap_serialize_bes__GetActivityDocumentsResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__GetActivityDocumentsResponse(struct soap *soap, const struct bes__GetActivityDocumentsResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetActivityDocumentsResponse);
	if (soap_out__bes__GetActivityDocumentsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetActivityDocumentsResponse(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentsResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetActivityDocumentsResponse), type))
		return soap->error;
	if (a->__any)
		soap_element_result(soap, "-any");
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_get__bes__GetActivityDocumentsResponse(struct soap *soap, struct bes__GetActivityDocumentsResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityDocumentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_in__bes__GetActivityDocumentsResponse(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentsResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetActivityDocumentsResponse, sizeof(struct bes__GetActivityDocumentsResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetActivityDocumentsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityDocumentsResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetActivityDocumentsResponse, 0, sizeof(struct bes__GetActivityDocumentsResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__GetActivityDocuments(struct soap *soap, struct bes__GetActivityDocumentsType *a)
{	soap_default_bes__GetActivityDocumentsType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__GetActivityDocuments(struct soap *soap, struct bes__GetActivityDocumentsType const*a)
{	soap_serialize_bes__GetActivityDocumentsType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__GetActivityDocuments(struct soap *soap, const struct bes__GetActivityDocumentsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetActivityDocuments);
	if (soap_out__bes__GetActivityDocuments(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetActivityDocuments(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetActivityDocuments), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityDocumentsType * SOAP_FMAC4 soap_get__bes__GetActivityDocuments(struct soap *soap, struct bes__GetActivityDocumentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityDocuments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsType * SOAP_FMAC4 soap_in__bes__GetActivityDocuments(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetActivityDocuments, sizeof(struct bes__GetActivityDocumentsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetActivityDocuments(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityDocumentsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetActivityDocuments, 0, sizeof(struct bes__GetActivityDocumentsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__TerminateActivitiesResponse(struct soap *soap, struct bes__TerminateActivitiesResponseType *a)
{	soap_default_bes__TerminateActivitiesResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__TerminateActivitiesResponse(struct soap *soap, struct bes__TerminateActivitiesResponseType const*a)
{	soap_serialize_bes__TerminateActivitiesResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__TerminateActivitiesResponse(struct soap *soap, const struct bes__TerminateActivitiesResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__TerminateActivitiesResponse);
	if (soap_out__bes__TerminateActivitiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__TerminateActivitiesResponse(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivitiesResponseType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__TerminateActivitiesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeResponse");
	if (a->Response)
	{	int i;
		for (i = 0; i < a->__sizeResponse; i++)
			if (soap_out_bes__TerminateActivityResponseType(soap, "bes:Response", -1, a->Response + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType * SOAP_FMAC4 soap_get__bes__TerminateActivitiesResponse(struct soap *soap, struct bes__TerminateActivitiesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__TerminateActivitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType * SOAP_FMAC4 soap_in__bes__TerminateActivitiesResponse(struct soap *soap, const char *tag, struct bes__TerminateActivitiesResponseType *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivitiesResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__TerminateActivitiesResponse, sizeof(struct bes__TerminateActivitiesResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__TerminateActivitiesResponse(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && soap->error == SOAP_TAG_MISMATCH)
			{	struct bes__TerminateActivityResponseType *p;
				soap_new_block(soap);
				for (a->__sizeResponse = 0; !soap_element_begin_in(soap, "bes:Response", 1, NULL); a->__sizeResponse++)
				{	p = (struct bes__TerminateActivityResponseType *)soap_push_block(soap, sizeof(struct bes__TerminateActivityResponseType));
					soap_default_bes__TerminateActivityResponseType(soap, p);
					soap_revert(soap);
					if (!soap_in_bes__TerminateActivityResponseType(soap, "bes:Response", p, "bes:TerminateActivityResponseType"))
						break;
					soap_flag_Response = 0;
				}
				a->Response = (struct bes__TerminateActivityResponseType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Response && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			soap_check_result(soap, "-sizeResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__TerminateActivitiesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__TerminateActivitiesResponse, 0, sizeof(struct bes__TerminateActivitiesResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__TerminateActivities(struct soap *soap, struct bes__TerminateActivitiesType *a)
{	soap_default_bes__TerminateActivitiesType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__TerminateActivities(struct soap *soap, struct bes__TerminateActivitiesType const*a)
{	soap_serialize_bes__TerminateActivitiesType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__TerminateActivities(struct soap *soap, const struct bes__TerminateActivitiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__TerminateActivities);
	if (soap_out__bes__TerminateActivities(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__TerminateActivities(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivitiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__TerminateActivities), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__TerminateActivitiesType * SOAP_FMAC4 soap_get__bes__TerminateActivities(struct soap *soap, struct bes__TerminateActivitiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__TerminateActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesType * SOAP_FMAC4 soap_in__bes__TerminateActivities(struct soap *soap, const char *tag, struct bes__TerminateActivitiesType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivitiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__TerminateActivities, sizeof(struct bes__TerminateActivitiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__TerminateActivities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__TerminateActivitiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__TerminateActivities, 0, sizeof(struct bes__TerminateActivitiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__GetActivityStatusesResponse(struct soap *soap, struct bes__GetActivityStatusesResponseType *a)
{	soap_default_bes__GetActivityStatusesResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__GetActivityStatusesResponse(struct soap *soap, struct bes__GetActivityStatusesResponseType const*a)
{	soap_serialize_bes__GetActivityStatusesResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__GetActivityStatusesResponse(struct soap *soap, const struct bes__GetActivityStatusesResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetActivityStatusesResponse);
	if (soap_out__bes__GetActivityStatusesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetActivityStatusesResponse(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusesResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetActivityStatusesResponse), type))
		return soap->error;
	if (a->__any)
		soap_element_result(soap, "-any");
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType * SOAP_FMAC4 soap_get__bes__GetActivityStatusesResponse(struct soap *soap, struct bes__GetActivityStatusesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityStatusesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType * SOAP_FMAC4 soap_in__bes__GetActivityStatusesResponse(struct soap *soap, const char *tag, struct bes__GetActivityStatusesResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusesResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetActivityStatusesResponse, sizeof(struct bes__GetActivityStatusesResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetActivityStatusesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityStatusesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetActivityStatusesResponse, 0, sizeof(struct bes__GetActivityStatusesResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__GetActivityStatuses(struct soap *soap, struct bes__GetActivityStatusesType *a)
{	soap_default_bes__GetActivityStatusesType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__GetActivityStatuses(struct soap *soap, struct bes__GetActivityStatusesType const*a)
{	soap_serialize_bes__GetActivityStatusesType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__GetActivityStatuses(struct soap *soap, const struct bes__GetActivityStatusesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__GetActivityStatuses);
	if (soap_out__bes__GetActivityStatuses(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetActivityStatuses(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__GetActivityStatuses), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityStatusesType * SOAP_FMAC4 soap_get__bes__GetActivityStatuses(struct soap *soap, struct bes__GetActivityStatusesType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityStatuses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesType * SOAP_FMAC4 soap_in__bes__GetActivityStatuses(struct soap *soap, const char *tag, struct bes__GetActivityStatusesType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__GetActivityStatuses, sizeof(struct bes__GetActivityStatusesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__GetActivityStatuses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityStatusesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__GetActivityStatuses, 0, sizeof(struct bes__GetActivityStatusesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__CreateActivityResponse(struct soap *soap, struct bes__CreateActivityResponseType *a)
{	soap_default_bes__CreateActivityResponseType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__CreateActivityResponse(struct soap *soap, struct bes__CreateActivityResponseType const*a)
{	soap_serialize_bes__CreateActivityResponseType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__CreateActivityResponse(struct soap *soap, const struct bes__CreateActivityResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__CreateActivityResponse);
	if (soap_out__bes__CreateActivityResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__CreateActivityResponse(struct soap *soap, const char *tag, int id, const struct bes__CreateActivityResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__CreateActivityResponse), type))
		return soap->error;
	if (a->__any)
		soap_element_result(soap, "-any");
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__CreateActivityResponseType * SOAP_FMAC4 soap_get__bes__CreateActivityResponse(struct soap *soap, struct bes__CreateActivityResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__CreateActivityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityResponseType * SOAP_FMAC4 soap_in__bes__CreateActivityResponse(struct soap *soap, const char *tag, struct bes__CreateActivityResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CreateActivityResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__CreateActivityResponse, sizeof(struct bes__CreateActivityResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__CreateActivityResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__CreateActivityResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__CreateActivityResponse, 0, sizeof(struct bes__CreateActivityResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__bes__CreateActivity(struct soap *soap, struct bes__CreateActivityType *a)
{	soap_default_bes__CreateActivityType(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__bes__CreateActivity(struct soap *soap, struct bes__CreateActivityType const*a)
{	soap_serialize_bes__CreateActivityType(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__bes__CreateActivity(struct soap *soap, const struct bes__CreateActivityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__bes__CreateActivity);
	if (soap_out__bes__CreateActivity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__CreateActivity(struct soap *soap, const char *tag, int id, const struct bes__CreateActivityType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__bes__CreateActivity), type))
		return soap->error;
	if (soap_out_bes__ActivityDocumentType(soap, "bes:ActivityDocument", -1, &a->bes__ActivityDocument, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__CreateActivityType * SOAP_FMAC4 soap_get__bes__CreateActivity(struct soap *soap, struct bes__CreateActivityType *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__CreateActivity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityType * SOAP_FMAC4 soap_in__bes__CreateActivity(struct soap *soap, const char *tag, struct bes__CreateActivityType *a, const char *type)
{
	short soap_flag_bes__ActivityDocument = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CreateActivityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__bes__CreateActivity, sizeof(struct bes__CreateActivityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__bes__CreateActivity(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__ActivityDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bes__ActivityDocumentType(soap, "bes:ActivityDocument", &a->bes__ActivityDocument, "bes:ActivityDocumentType"))
				{	soap_flag_bes__ActivityDocument--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__CreateActivityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__bes__CreateActivity, 0, sizeof(struct bes__CreateActivityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__ActivityDocument > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_posix__POSIXApplication_USCOREType(struct soap *soap, struct posix__POSIXApplication_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->posix__Executable = NULL;
	a->__sizeArgument = 0;
	a->posix__Argument = NULL;
	a->posix__Input = NULL;
	a->posix__Output = NULL;
	a->posix__Error = NULL;
	a->posix__WorkingDirectory = NULL;
	a->__sizeEnvironment = 0;
	a->posix__Environment = NULL;
	a->posix__WallTimeLimit = NULL;
	a->posix__FileSizeLimit = NULL;
	a->posix__CoreDumpLimit = NULL;
	a->posix__DataSegmentLimit = NULL;
	a->posix__LockedMemoryLimit = NULL;
	a->posix__MemoryLimit = NULL;
	a->posix__OpenDescriptorsLimit = NULL;
	a->posix__PipeSizeLimit = NULL;
	a->posix__StackSizeLimit = NULL;
	a->posix__CPUTimeLimit = NULL;
	a->posix__ProcessCountLimit = NULL;
	a->posix__VirtualMemoryLimit = NULL;
	a->posix__ThreadCountLimit = NULL;
	a->posix__UserName = NULL;
	a->posix__GroupName = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_posix__POSIXApplication_USCOREType(struct soap *soap, const struct posix__POSIXApplication_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToposix__FileName_USCOREType(soap, &a->posix__Executable);
	if (a->posix__Argument)
	{	int i;
		for (i = 0; i < a->__sizeArgument; i++)
		{
			soap_embedded(soap, a->posix__Argument + i, SOAP_TYPE_posix__Argument_USCOREType);
			soap_serialize_posix__Argument_USCOREType(soap, a->posix__Argument + i);
		}
	}
	soap_serialize_PointerToposix__FileName_USCOREType(soap, &a->posix__Input);
	soap_serialize_PointerToposix__FileName_USCOREType(soap, &a->posix__Output);
	soap_serialize_PointerToposix__FileName_USCOREType(soap, &a->posix__Error);
	soap_serialize_PointerToposix__DirectoryName_USCOREType(soap, &a->posix__WorkingDirectory);
	if (a->posix__Environment)
	{	int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
		{
			soap_embedded(soap, a->posix__Environment + i, SOAP_TYPE_posix__Environment_USCOREType);
			soap_serialize_posix__Environment_USCOREType(soap, a->posix__Environment + i);
		}
	}
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__WallTimeLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__FileSizeLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__CoreDumpLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__DataSegmentLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__LockedMemoryLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__MemoryLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__OpenDescriptorsLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__PipeSizeLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__StackSizeLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__CPUTimeLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__ProcessCountLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__VirtualMemoryLimit);
	soap_serialize_PointerToposix__Limits_USCOREType(soap, &a->posix__ThreadCountLimit);
	soap_serialize_PointerToposix__UserName_USCOREType(soap, &a->posix__UserName);
	soap_serialize_PointerToposix__GroupName_USCOREType(soap, &a->posix__GroupName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_posix__POSIXApplication_USCOREType(struct soap *soap, const struct posix__POSIXApplication_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_posix__POSIXApplication_USCOREType);
	if (soap_out_posix__POSIXApplication_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_posix__POSIXApplication_USCOREType(struct soap *soap, const char *tag, int id, const struct posix__POSIXApplication_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_posix__POSIXApplication_USCOREType), type))
		return soap->error;
	if (soap_out_PointerToposix__FileName_USCOREType(soap, "posix:Executable", -1, &a->posix__Executable, ""))
		return soap->error;
	if (a->posix__Argument)
	{	int i;
		for (i = 0; i < a->__sizeArgument; i++)
			if (soap_out_posix__Argument_USCOREType(soap, "posix:Argument", -1, a->posix__Argument + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToposix__FileName_USCOREType(soap, "posix:Input", -1, &a->posix__Input, ""))
		return soap->error;
	if (soap_out_PointerToposix__FileName_USCOREType(soap, "posix:Output", -1, &a->posix__Output, ""))
		return soap->error;
	if (soap_out_PointerToposix__FileName_USCOREType(soap, "posix:Error", -1, &a->posix__Error, ""))
		return soap->error;
	if (soap_out_PointerToposix__DirectoryName_USCOREType(soap, "posix:WorkingDirectory", -1, &a->posix__WorkingDirectory, ""))
		return soap->error;
	if (a->posix__Environment)
	{	int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
			if (soap_out_posix__Environment_USCOREType(soap, "posix:Environment", -1, a->posix__Environment + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:WallTimeLimit", -1, &a->posix__WallTimeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:FileSizeLimit", -1, &a->posix__FileSizeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:CoreDumpLimit", -1, &a->posix__CoreDumpLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:DataSegmentLimit", -1, &a->posix__DataSegmentLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:LockedMemoryLimit", -1, &a->posix__LockedMemoryLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:MemoryLimit", -1, &a->posix__MemoryLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:OpenDescriptorsLimit", -1, &a->posix__OpenDescriptorsLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:PipeSizeLimit", -1, &a->posix__PipeSizeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:StackSizeLimit", -1, &a->posix__StackSizeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:CPUTimeLimit", -1, &a->posix__CPUTimeLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:ProcessCountLimit", -1, &a->posix__ProcessCountLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:VirtualMemoryLimit", -1, &a->posix__VirtualMemoryLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__Limits_USCOREType(soap, "posix:ThreadCountLimit", -1, &a->posix__ThreadCountLimit, ""))
		return soap->error;
	if (soap_out_PointerToposix__UserName_USCOREType(soap, "posix:UserName", -1, &a->posix__UserName, ""))
		return soap->error;
	if (soap_out_PointerToposix__GroupName_USCOREType(soap, "posix:GroupName", -1, &a->posix__GroupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct posix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_get_posix__POSIXApplication_USCOREType(struct soap *soap, struct posix__POSIXApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_posix__POSIXApplication_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_in_posix__POSIXApplication_USCOREType(struct soap *soap, const char *tag, struct posix__POSIXApplication_USCOREType *a, const char *type)
{
	short soap_flag_posix__Executable = 1, soap_flag_posix__Argument = 1, soap_flag_posix__Input = 1, soap_flag_posix__Output = 1, soap_flag_posix__Error = 1, soap_flag_posix__WorkingDirectory = 1, soap_flag_posix__Environment = 1, soap_flag_posix__WallTimeLimit = 1, soap_flag_posix__FileSizeLimit = 1, soap_flag_posix__CoreDumpLimit = 1, soap_flag_posix__DataSegmentLimit = 1, soap_flag_posix__LockedMemoryLimit = 1, soap_flag_posix__MemoryLimit = 1, soap_flag_posix__OpenDescriptorsLimit = 1, soap_flag_posix__PipeSizeLimit = 1, soap_flag_posix__StackSizeLimit = 1, soap_flag_posix__CPUTimeLimit = 1, soap_flag_posix__ProcessCountLimit = 1, soap_flag_posix__VirtualMemoryLimit = 1, soap_flag_posix__ThreadCountLimit = 1, soap_flag_posix__UserName = 1, soap_flag_posix__GroupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct posix__POSIXApplication_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_posix__POSIXApplication_USCOREType, sizeof(struct posix__POSIXApplication_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_posix__POSIXApplication_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_posix__Executable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__FileName_USCOREType(soap, "posix:Executable", &a->posix__Executable, "posix:FileName_Type"))
				{	soap_flag_posix__Executable--;
					continue;
				}
			if (soap_flag_posix__Argument && soap->error == SOAP_TAG_MISMATCH)
			{	struct posix__Argument_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeArgument = 0; !soap_element_begin_in(soap, "posix:Argument", 1, NULL); a->__sizeArgument++)
				{	p = (struct posix__Argument_USCOREType *)soap_push_block(soap, sizeof(struct posix__Argument_USCOREType));
					soap_default_posix__Argument_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_posix__Argument_USCOREType(soap, "posix:Argument", p, "posix:Argument_Type"))
						break;
					soap_flag_posix__Argument = 0;
				}
				a->posix__Argument = (struct posix__Argument_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_posix__Argument && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_posix__Input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__FileName_USCOREType(soap, "posix:Input", &a->posix__Input, "posix:FileName_Type"))
				{	soap_flag_posix__Input--;
					continue;
				}
			if (soap_flag_posix__Output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__FileName_USCOREType(soap, "posix:Output", &a->posix__Output, "posix:FileName_Type"))
				{	soap_flag_posix__Output--;
					continue;
				}
			if (soap_flag_posix__Error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__FileName_USCOREType(soap, "posix:Error", &a->posix__Error, "posix:FileName_Type"))
				{	soap_flag_posix__Error--;
					continue;
				}
			if (soap_flag_posix__WorkingDirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__DirectoryName_USCOREType(soap, "posix:WorkingDirectory", &a->posix__WorkingDirectory, "posix:DirectoryName_Type"))
				{	soap_flag_posix__WorkingDirectory--;
					continue;
				}
			if (soap_flag_posix__Environment && soap->error == SOAP_TAG_MISMATCH)
			{	struct posix__Environment_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeEnvironment = 0; !soap_element_begin_in(soap, "posix:Environment", 1, NULL); a->__sizeEnvironment++)
				{	p = (struct posix__Environment_USCOREType *)soap_push_block(soap, sizeof(struct posix__Environment_USCOREType));
					soap_default_posix__Environment_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_posix__Environment_USCOREType(soap, "posix:Environment", p, "posix:Environment_Type"))
						break;
					soap_flag_posix__Environment = 0;
				}
				a->posix__Environment = (struct posix__Environment_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_posix__Environment && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_posix__WallTimeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:WallTimeLimit", &a->posix__WallTimeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__WallTimeLimit--;
					continue;
				}
			if (soap_flag_posix__FileSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:FileSizeLimit", &a->posix__FileSizeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__FileSizeLimit--;
					continue;
				}
			if (soap_flag_posix__CoreDumpLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:CoreDumpLimit", &a->posix__CoreDumpLimit, "posix:Limits_Type"))
				{	soap_flag_posix__CoreDumpLimit--;
					continue;
				}
			if (soap_flag_posix__DataSegmentLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:DataSegmentLimit", &a->posix__DataSegmentLimit, "posix:Limits_Type"))
				{	soap_flag_posix__DataSegmentLimit--;
					continue;
				}
			if (soap_flag_posix__LockedMemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:LockedMemoryLimit", &a->posix__LockedMemoryLimit, "posix:Limits_Type"))
				{	soap_flag_posix__LockedMemoryLimit--;
					continue;
				}
			if (soap_flag_posix__MemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:MemoryLimit", &a->posix__MemoryLimit, "posix:Limits_Type"))
				{	soap_flag_posix__MemoryLimit--;
					continue;
				}
			if (soap_flag_posix__OpenDescriptorsLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:OpenDescriptorsLimit", &a->posix__OpenDescriptorsLimit, "posix:Limits_Type"))
				{	soap_flag_posix__OpenDescriptorsLimit--;
					continue;
				}
			if (soap_flag_posix__PipeSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:PipeSizeLimit", &a->posix__PipeSizeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__PipeSizeLimit--;
					continue;
				}
			if (soap_flag_posix__StackSizeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:StackSizeLimit", &a->posix__StackSizeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__StackSizeLimit--;
					continue;
				}
			if (soap_flag_posix__CPUTimeLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:CPUTimeLimit", &a->posix__CPUTimeLimit, "posix:Limits_Type"))
				{	soap_flag_posix__CPUTimeLimit--;
					continue;
				}
			if (soap_flag_posix__ProcessCountLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:ProcessCountLimit", &a->posix__ProcessCountLimit, "posix:Limits_Type"))
				{	soap_flag_posix__ProcessCountLimit--;
					continue;
				}
			if (soap_flag_posix__VirtualMemoryLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:VirtualMemoryLimit", &a->posix__VirtualMemoryLimit, "posix:Limits_Type"))
				{	soap_flag_posix__VirtualMemoryLimit--;
					continue;
				}
			if (soap_flag_posix__ThreadCountLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__Limits_USCOREType(soap, "posix:ThreadCountLimit", &a->posix__ThreadCountLimit, "posix:Limits_Type"))
				{	soap_flag_posix__ThreadCountLimit--;
					continue;
				}
			if (soap_flag_posix__UserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__UserName_USCOREType(soap, "posix:UserName", &a->posix__UserName, "posix:UserName_Type"))
				{	soap_flag_posix__UserName--;
					continue;
				}
			if (soap_flag_posix__GroupName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToposix__GroupName_USCOREType(soap, "posix:GroupName", &a->posix__GroupName, "posix:GroupName_Type"))
				{	soap_flag_posix__GroupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct posix__POSIXApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_posix__POSIXApplication_USCOREType, 0, sizeof(struct posix__POSIXApplication_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_posix__GroupName_USCOREType(struct soap *soap, struct posix__GroupName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_posix__GroupName_USCOREType(struct soap *soap, const struct posix__GroupName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_posix__GroupName_USCOREType(struct soap *soap, const struct posix__GroupName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_posix__GroupName_USCOREType);
	if (soap_out_posix__GroupName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_posix__GroupName_USCOREType(struct soap *soap, const char *tag, int id, const struct posix__GroupName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__GroupName_USCOREType * SOAP_FMAC4 soap_get_posix__GroupName_USCOREType(struct soap *soap, struct posix__GroupName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_posix__GroupName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__GroupName_USCOREType * SOAP_FMAC4 soap_in_posix__GroupName_USCOREType(struct soap *soap, const char *tag, struct posix__GroupName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__GroupName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_posix__GroupName_USCOREType, sizeof(struct posix__GroupName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_posix__GroupName_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "posix:GroupName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_posix__UserName_USCOREType(struct soap *soap, struct posix__UserName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_posix__UserName_USCOREType(struct soap *soap, const struct posix__UserName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_posix__UserName_USCOREType(struct soap *soap, const struct posix__UserName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_posix__UserName_USCOREType);
	if (soap_out_posix__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_posix__UserName_USCOREType(struct soap *soap, const char *tag, int id, const struct posix__UserName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__UserName_USCOREType * SOAP_FMAC4 soap_get_posix__UserName_USCOREType(struct soap *soap, struct posix__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_posix__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__UserName_USCOREType * SOAP_FMAC4 soap_in_posix__UserName_USCOREType(struct soap *soap, const char *tag, struct posix__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__UserName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_posix__UserName_USCOREType, sizeof(struct posix__UserName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_posix__UserName_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "posix:UserName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_posix__Limits_USCOREType(struct soap *soap, struct posix__Limits_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__nonNegativeInteger(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_posix__Limits_USCOREType(struct soap *soap, const struct posix__Limits_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__nonNegativeInteger(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_posix__Limits_USCOREType(struct soap *soap, const struct posix__Limits_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_posix__Limits_USCOREType);
	if (soap_out_posix__Limits_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_posix__Limits_USCOREType(struct soap *soap, const char *tag, int id, const struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_get_posix__Limits_USCOREType(struct soap *soap, struct posix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_posix__Limits_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType * SOAP_FMAC4 soap_in_posix__Limits_USCOREType(struct soap *soap, const char *tag, struct posix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Limits_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_posix__Limits_USCOREType, sizeof(struct posix__Limits_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_posix__Limits_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->__item, "posix:Limits_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_posix__DirectoryName_USCOREType(struct soap *soap, struct posix__DirectoryName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->filesystemName);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_posix__DirectoryName_USCOREType(struct soap *soap, const struct posix__DirectoryName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_posix__DirectoryName_USCOREType(struct soap *soap, const struct posix__DirectoryName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_posix__DirectoryName_USCOREType);
	if (soap_out_posix__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_posix__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, const struct posix__DirectoryName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__DirectoryName_USCOREType * SOAP_FMAC4 soap_get_posix__DirectoryName_USCOREType(struct soap *soap, struct posix__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_posix__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__DirectoryName_USCOREType * SOAP_FMAC4 soap_in_posix__DirectoryName_USCOREType(struct soap *soap, const char *tag, struct posix__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__DirectoryName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_posix__DirectoryName_USCOREType, sizeof(struct posix__DirectoryName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_posix__DirectoryName_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "posix:DirectoryName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_posix__FileName_USCOREType(struct soap *soap, struct posix__FileName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->filesystemName);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_posix__FileName_USCOREType(struct soap *soap, const struct posix__FileName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_posix__FileName_USCOREType(struct soap *soap, const struct posix__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_posix__FileName_USCOREType);
	if (soap_out_posix__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_posix__FileName_USCOREType(struct soap *soap, const char *tag, int id, const struct posix__FileName_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_get_posix__FileName_USCOREType(struct soap *soap, struct posix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_posix__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__FileName_USCOREType * SOAP_FMAC4 soap_in_posix__FileName_USCOREType(struct soap *soap, const char *tag, struct posix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_posix__FileName_USCOREType, sizeof(struct posix__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_posix__FileName_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "posix:FileName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_posix__Argument_USCOREType(struct soap *soap, struct posix__Argument_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__normalizedString(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->filesystemName);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_posix__Argument_USCOREType(struct soap *soap, const struct posix__Argument_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__normalizedString(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_posix__Argument_USCOREType(struct soap *soap, const struct posix__Argument_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_posix__Argument_USCOREType);
	if (soap_out_posix__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_posix__Argument_USCOREType(struct soap *soap, const char *tag, int id, const struct posix__Argument_USCOREType *a, const char *type)
{
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__normalizedString(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Argument_USCOREType * SOAP_FMAC4 soap_get_posix__Argument_USCOREType(struct soap *soap, struct posix__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_posix__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Argument_USCOREType * SOAP_FMAC4 soap_in_posix__Argument_USCOREType(struct soap *soap, const char *tag, struct posix__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Argument_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_posix__Argument_USCOREType, sizeof(struct posix__Argument_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_posix__Argument_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__normalizedString(soap, tag, &a->__item, "posix:Argument_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_posix__Environment_USCOREType(struct soap *soap, struct posix__Environment_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__NCName(soap, &a->filesystemName);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_posix__Environment_USCOREType(struct soap *soap, const struct posix__Environment_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_posix__Environment_USCOREType(struct soap *soap, const struct posix__Environment_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_posix__Environment_USCOREType);
	if (soap_out_posix__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_posix__Environment_USCOREType(struct soap *soap, const char *tag, int id, const struct posix__Environment_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (a->filesystemName)
		soap_set_attr(soap, "filesystemName", a->filesystemName);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct posix__Environment_USCOREType * SOAP_FMAC4 soap_get_posix__Environment_USCOREType(struct soap *soap, struct posix__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_posix__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Environment_USCOREType * SOAP_FMAC4 soap_in_posix__Environment_USCOREType(struct soap *soap, const char *tag, struct posix__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct posix__Environment_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_posix__Environment_USCOREType, sizeof(struct posix__Environment_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_posix__Environment_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "filesystemName", 0), &a->filesystemName))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "posix:Environment_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__HPCProfileApplication_USCOREType(struct soap *soap, struct app__HPCProfileApplication_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->app__Executable = NULL;
	a->__sizeArgument = 0;
	a->app__Argument = NULL;
	a->app__Input = NULL;
	a->app__Output = NULL;
	a->app__Error = NULL;
	a->app__WorkingDirectory = NULL;
	a->__sizeEnvironment = 0;
	a->app__Environment = NULL;
	a->app__UserName = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_app__HPCProfileApplication_USCOREType(struct soap *soap, const struct app__HPCProfileApplication_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToapp__FileName_USCOREType(soap, &a->app__Executable);
	if (a->app__Argument)
	{	int i;
		for (i = 0; i < a->__sizeArgument; i++)
		{
			soap_embedded(soap, a->app__Argument + i, SOAP_TYPE_app__Argument_USCOREType);
			soap_serialize_app__Argument_USCOREType(soap, a->app__Argument + i);
		}
	}
	soap_serialize_PointerToapp__FileName_USCOREType(soap, &a->app__Input);
	soap_serialize_PointerToapp__FileName_USCOREType(soap, &a->app__Output);
	soap_serialize_PointerToapp__FileName_USCOREType(soap, &a->app__Error);
	soap_serialize_PointerToapp__DirectoryName_USCOREType(soap, &a->app__WorkingDirectory);
	if (a->app__Environment)
	{	int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
		{
			soap_embedded(soap, a->app__Environment + i, SOAP_TYPE_app__Environment_USCOREType);
			soap_serialize_app__Environment_USCOREType(soap, a->app__Environment + i);
		}
	}
	soap_serialize_PointerToapp__UserName_USCOREType(soap, &a->app__UserName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__HPCProfileApplication_USCOREType(struct soap *soap, const struct app__HPCProfileApplication_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__HPCProfileApplication_USCOREType);
	if (soap_out_app__HPCProfileApplication_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_app__HPCProfileApplication_USCOREType(struct soap *soap, const char *tag, int id, const struct app__HPCProfileApplication_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_app__HPCProfileApplication_USCOREType), type))
		return soap->error;
	if (soap_out_PointerToapp__FileName_USCOREType(soap, "app:Executable", -1, &a->app__Executable, ""))
		return soap->error;
	if (a->app__Argument)
	{	int i;
		for (i = 0; i < a->__sizeArgument; i++)
			if (soap_out_app__Argument_USCOREType(soap, "app:Argument", -1, a->app__Argument + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToapp__FileName_USCOREType(soap, "app:Input", -1, &a->app__Input, ""))
		return soap->error;
	if (soap_out_PointerToapp__FileName_USCOREType(soap, "app:Output", -1, &a->app__Output, ""))
		return soap->error;
	if (soap_out_PointerToapp__FileName_USCOREType(soap, "app:Error", -1, &a->app__Error, ""))
		return soap->error;
	if (soap_out_PointerToapp__DirectoryName_USCOREType(soap, "app:WorkingDirectory", -1, &a->app__WorkingDirectory, ""))
		return soap->error;
	if (a->app__Environment)
	{	int i;
		for (i = 0; i < a->__sizeEnvironment; i++)
			if (soap_out_app__Environment_USCOREType(soap, "app:Environment", -1, a->app__Environment + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToapp__UserName_USCOREType(soap, "app:UserName", -1, &a->app__UserName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct app__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_get_app__HPCProfileApplication_USCOREType(struct soap *soap, struct app__HPCProfileApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_app__HPCProfileApplication_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_in_app__HPCProfileApplication_USCOREType(struct soap *soap, const char *tag, struct app__HPCProfileApplication_USCOREType *a, const char *type)
{
	short soap_flag_app__Executable = 1, soap_flag_app__Argument = 1, soap_flag_app__Input = 1, soap_flag_app__Output = 1, soap_flag_app__Error = 1, soap_flag_app__WorkingDirectory = 1, soap_flag_app__Environment = 1, soap_flag_app__UserName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct app__HPCProfileApplication_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__HPCProfileApplication_USCOREType, sizeof(struct app__HPCProfileApplication_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_app__HPCProfileApplication_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_app__Executable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__FileName_USCOREType(soap, "app:Executable", &a->app__Executable, "app:FileName_Type"))
				{	soap_flag_app__Executable--;
					continue;
				}
			if (soap_flag_app__Argument && soap->error == SOAP_TAG_MISMATCH)
			{	struct app__Argument_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeArgument = 0; !soap_element_begin_in(soap, "app:Argument", 1, NULL); a->__sizeArgument++)
				{	p = (struct app__Argument_USCOREType *)soap_push_block(soap, sizeof(struct app__Argument_USCOREType));
					soap_default_app__Argument_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_app__Argument_USCOREType(soap, "app:Argument", p, "app:Argument_Type"))
						break;
					soap_flag_app__Argument = 0;
				}
				a->app__Argument = (struct app__Argument_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_app__Argument && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_app__Input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__FileName_USCOREType(soap, "app:Input", &a->app__Input, "app:FileName_Type"))
				{	soap_flag_app__Input--;
					continue;
				}
			if (soap_flag_app__Output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__FileName_USCOREType(soap, "app:Output", &a->app__Output, "app:FileName_Type"))
				{	soap_flag_app__Output--;
					continue;
				}
			if (soap_flag_app__Error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__FileName_USCOREType(soap, "app:Error", &a->app__Error, "app:FileName_Type"))
				{	soap_flag_app__Error--;
					continue;
				}
			if (soap_flag_app__WorkingDirectory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__DirectoryName_USCOREType(soap, "app:WorkingDirectory", &a->app__WorkingDirectory, "app:DirectoryName_Type"))
				{	soap_flag_app__WorkingDirectory--;
					continue;
				}
			if (soap_flag_app__Environment && soap->error == SOAP_TAG_MISMATCH)
			{	struct app__Environment_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeEnvironment = 0; !soap_element_begin_in(soap, "app:Environment", 1, NULL); a->__sizeEnvironment++)
				{	p = (struct app__Environment_USCOREType *)soap_push_block(soap, sizeof(struct app__Environment_USCOREType));
					soap_default_app__Environment_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_app__Environment_USCOREType(soap, "app:Environment", p, "app:Environment_Type"))
						break;
					soap_flag_app__Environment = 0;
				}
				a->app__Environment = (struct app__Environment_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_app__Environment && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_app__UserName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToapp__UserName_USCOREType(soap, "app:UserName", &a->app__UserName, "app:UserName_Type"))
				{	soap_flag_app__UserName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct app__HPCProfileApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_app__HPCProfileApplication_USCOREType, 0, sizeof(struct app__HPCProfileApplication_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__UserName_USCOREType(struct soap *soap, struct app__UserName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_app__UserName_USCOREType(struct soap *soap, const struct app__UserName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__UserName_USCOREType(struct soap *soap, const struct app__UserName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__UserName_USCOREType);
	if (soap_out_app__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_app__UserName_USCOREType(struct soap *soap, const char *tag, int id, const struct app__UserName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__UserName_USCOREType * SOAP_FMAC4 soap_get_app__UserName_USCOREType(struct soap *soap, struct app__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_app__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__UserName_USCOREType * SOAP_FMAC4 soap_in_app__UserName_USCOREType(struct soap *soap, const char *tag, struct app__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__UserName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__UserName_USCOREType, sizeof(struct app__UserName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_app__UserName_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "app:UserName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__DirectoryName_USCOREType(struct soap *soap, struct app__DirectoryName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_app__DirectoryName_USCOREType(struct soap *soap, const struct app__DirectoryName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__DirectoryName_USCOREType(struct soap *soap, const struct app__DirectoryName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__DirectoryName_USCOREType);
	if (soap_out_app__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_app__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, const struct app__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__DirectoryName_USCOREType * SOAP_FMAC4 soap_get_app__DirectoryName_USCOREType(struct soap *soap, struct app__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_app__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__DirectoryName_USCOREType * SOAP_FMAC4 soap_in_app__DirectoryName_USCOREType(struct soap *soap, const char *tag, struct app__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__DirectoryName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__DirectoryName_USCOREType, sizeof(struct app__DirectoryName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_app__DirectoryName_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "app:DirectoryName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__FileName_USCOREType(struct soap *soap, struct app__FileName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_app__FileName_USCOREType(struct soap *soap, const struct app__FileName_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__FileName_USCOREType(struct soap *soap, const struct app__FileName_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__FileName_USCOREType);
	if (soap_out_app__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_app__FileName_USCOREType(struct soap *soap, const char *tag, int id, const struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_get_app__FileName_USCOREType(struct soap *soap, struct app__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_app__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__FileName_USCOREType * SOAP_FMAC4 soap_in_app__FileName_USCOREType(struct soap *soap, const char *tag, struct app__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__FileName_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__FileName_USCOREType, sizeof(struct app__FileName_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_app__FileName_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "app:FileName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__Argument_USCOREType(struct soap *soap, struct app__Argument_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_app__Argument_USCOREType(struct soap *soap, const struct app__Argument_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__Argument_USCOREType(struct soap *soap, const struct app__Argument_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__Argument_USCOREType);
	if (soap_out_app__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_app__Argument_USCOREType(struct soap *soap, const char *tag, int id, const struct app__Argument_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__Argument_USCOREType * SOAP_FMAC4 soap_get_app__Argument_USCOREType(struct soap *soap, struct app__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_app__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__Argument_USCOREType * SOAP_FMAC4 soap_in_app__Argument_USCOREType(struct soap *soap, const char *tag, struct app__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__Argument_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__Argument_USCOREType, sizeof(struct app__Argument_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_app__Argument_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "app:Argument_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_app__Environment_USCOREType(struct soap *soap, struct app__Environment_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_app__Environment_USCOREType(struct soap *soap, const struct app__Environment_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_app__Environment_USCOREType(struct soap *soap, const struct app__Environment_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_app__Environment_USCOREType);
	if (soap_out_app__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_app__Environment_USCOREType(struct soap *soap, const char *tag, int id, const struct app__Environment_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct app__Environment_USCOREType * SOAP_FMAC4 soap_get_app__Environment_USCOREType(struct soap *soap, struct app__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_app__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__Environment_USCOREType * SOAP_FMAC4 soap_in_app__Environment_USCOREType(struct soap *soap, const char *tag, struct app__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct app__Environment_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_app__Environment_USCOREType, sizeof(struct app__Environment_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_app__Environment_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, &a->__item, "app:Environment_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->jsdl__URI);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__SourceTarget_USCOREType(struct soap *soap, const struct jsdl__SourceTarget_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->jsdl__URI);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__SourceTarget_USCOREType(struct soap *soap, const struct jsdl__SourceTarget_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__SourceTarget_USCOREType);
	if (soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__SourceTarget_USCOREType), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "jsdl:URI", -1, &a->jsdl__URI, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get_jsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, struct jsdl__SourceTarget_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__URI = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__SourceTarget_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__SourceTarget_USCOREType, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__SourceTarget_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "jsdl:URI", &a->jsdl__URI, "xsd:anyURI"))
				{	soap_flag_jsdl__URI--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__SourceTarget_USCOREType, 0, sizeof(struct jsdl__SourceTarget_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->jsdl__FileName);
	soap_default_xsd__NCName(soap, &a->jsdl__FilesystemName);
	soap_default_jsdl__CreationFlagEnumeration(soap, &a->jsdl__CreationFlag);
	a->jsdl__DeleteOnTermination = NULL;
	a->jsdl__Source = NULL;
	a->jsdl__Target = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__DataStaging_USCOREType(struct soap *soap, const struct jsdl__DataStaging_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->jsdl__FileName);
	soap_serialize_xsd__NCName(soap, &a->jsdl__FilesystemName);
	soap_serialize_PointerToxsd__boolean(soap, &a->jsdl__DeleteOnTermination);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &a->jsdl__Source);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &a->jsdl__Target);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__DataStaging_USCOREType(struct soap *soap, const struct jsdl__DataStaging_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__DataStaging_USCOREType);
	if (soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__DataStaging_USCOREType), type))
		return soap->error;
	if (soap_out_string(soap, "jsdl:FileName", -1, &a->jsdl__FileName, ""))
		return soap->error;
	if (soap_out_xsd__NCName(soap, "jsdl:FilesystemName", -1, &a->jsdl__FilesystemName, ""))
		return soap->error;
	if (soap_out_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", -1, &a->jsdl__CreationFlag, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "jsdl:DeleteOnTermination", -1, &a->jsdl__DeleteOnTermination, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", -1, &a->jsdl__Source, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", -1, &a->jsdl__Target, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_get_jsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_in_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, struct jsdl__DataStaging_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__FileName = 1, soap_flag_jsdl__FilesystemName = 1, soap_flag_jsdl__CreationFlag = 1, soap_flag_jsdl__DeleteOnTermination = 1, soap_flag_jsdl__Source = 1, soap_flag_jsdl__Target = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__DataStaging_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__DataStaging_USCOREType, sizeof(struct jsdl__DataStaging_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__DataStaging_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:FileName", &a->jsdl__FileName, "xsd:string"))
				{	soap_flag_jsdl__FileName--;
					continue;
				}
			if (soap_flag_jsdl__FilesystemName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__NCName(soap, "jsdl:FilesystemName", &a->jsdl__FilesystemName, "xsd:NCName"))
				{	soap_flag_jsdl__FilesystemName--;
					continue;
				}
			if (soap_flag_jsdl__CreationFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", &a->jsdl__CreationFlag, "jsdl:CreationFlagEnumeration"))
				{	soap_flag_jsdl__CreationFlag--;
					continue;
				}
			if (soap_flag_jsdl__DeleteOnTermination && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "jsdl:DeleteOnTermination", &a->jsdl__DeleteOnTermination, "xsd:boolean"))
				{	soap_flag_jsdl__DeleteOnTermination--;
					continue;
				}
			if (soap_flag_jsdl__Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", &a->jsdl__Source, "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Source--;
					continue;
				}
			if (soap_flag_jsdl__Target && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", &a->jsdl__Target, "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Target--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__DataStaging_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__DataStaging_USCOREType, 0, sizeof(struct jsdl__DataStaging_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__FileName > 0 || soap_flag_jsdl__CreationFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_jsdl__OperatingSystemTypeEnumeration(soap, &a->jsdl__OperatingSystemName);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const struct jsdl__OperatingSystemType_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const struct jsdl__OperatingSystemType_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType);
	if (soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType), type))
		return soap->error;
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", -1, &a->jsdl__OperatingSystemName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, struct jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__OperatingSystemName = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__OperatingSystemType_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__OperatingSystemType_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", &a->jsdl__OperatingSystemName, "jsdl:OperatingSystemTypeEnumeration"))
				{	soap_flag_jsdl__OperatingSystemName--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__OperatingSystemType_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, 0, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__OperatingSystemName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__OperatingSystemType = NULL;
	soap_default_string(soap, &a->jsdl__OperatingSystemVersion);
	soap_default_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__OperatingSystem_USCOREType(struct soap *soap, const struct jsdl__OperatingSystem_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, &a->jsdl__OperatingSystemType);
	soap_serialize_string(soap, &a->jsdl__OperatingSystemVersion);
	soap_serialize_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__OperatingSystem_USCOREType(struct soap *soap, const struct jsdl__OperatingSystem_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystem_USCOREType);
	if (soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", -1, &a->jsdl__OperatingSystemType, ""))
		return soap->error;
	if (soap_out_string(soap, "jsdl:OperatingSystemVersion", -1, &a->jsdl__OperatingSystemVersion, ""))
		return soap->error;
	if (soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, struct jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__OperatingSystemType = 1, soap_flag_jsdl__OperatingSystemVersion = 1, soap_flag_jsdl__Description = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__OperatingSystem_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, sizeof(struct jsdl__OperatingSystem_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__OperatingSystem_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", &a->jsdl__OperatingSystemType, "jsdl:OperatingSystemType_Type"))
				{	soap_flag_jsdl__OperatingSystemType--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystemVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:OperatingSystemVersion", &a->jsdl__OperatingSystemVersion, "xsd:string"))
				{	soap_flag_jsdl__OperatingSystemVersion--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__OperatingSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, 0, sizeof(struct jsdl__OperatingSystem_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__FileSystemType = NULL;
	soap_default_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	soap_default_string(soap, &a->jsdl__MountPoint);
	a->jsdl__DiskSpace = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__FileSystem_USCOREType(struct soap *soap, const struct jsdl__FileSystem_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, &a->jsdl__FileSystemType);
	soap_serialize_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	soap_serialize_string(soap, &a->jsdl__MountPoint);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__DiskSpace);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__FileSystem_USCOREType(struct soap *soap, const struct jsdl__FileSystem_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__FileSystem_USCOREType);
	if (soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", a->name);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__FileSystem_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", -1, &a->jsdl__FileSystemType, ""))
		return soap->error;
	if (soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, ""))
		return soap->error;
	if (soap_out_string(soap, "jsdl:MountPoint", -1, &a->jsdl__MountPoint, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", -1, &a->jsdl__DiskSpace, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, struct jsdl__FileSystem_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__FileSystemType = 1, soap_flag_jsdl__Description = 1, soap_flag_jsdl__MountPoint = 1, soap_flag_jsdl__DiskSpace = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__FileSystem_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__FileSystem_USCOREType, sizeof(struct jsdl__FileSystem_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__FileSystem_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileSystemType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", &a->jsdl__FileSystemType, "jsdl:FileSystemTypeEnumeration"))
				{	soap_flag_jsdl__FileSystemType--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag_jsdl__MountPoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:MountPoint", &a->jsdl__MountPoint, "xsd:string"))
				{	soap_flag_jsdl__MountPoint--;
					continue;
				}
			if (soap_flag_jsdl__DiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", &a->jsdl__DiskSpace, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__DiskSpace--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__FileSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__FileSystem_USCOREType, 0, sizeof(struct jsdl__FileSystem_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_jsdl__ProcessorArchitectureEnumeration(soap, &a->jsdl__CPUArchitectureName);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const struct jsdl__CPUArchitecture_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const struct jsdl__CPUArchitecture_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType);
	if (soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType), type))
		return soap->error;
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", -1, &a->jsdl__CPUArchitectureName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_get_jsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_in_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, struct jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__CPUArchitectureName = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__CPUArchitecture_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__CPUArchitecture_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CPUArchitectureName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", &a->jsdl__CPUArchitectureName, "jsdl:ProcessorArchitectureEnumeration"))
				{	soap_flag_jsdl__CPUArchitectureName--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__CPUArchitecture_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, 0, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__CPUArchitectureName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeHostName = 0;
	a->jsdl__HostName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__CandidateHosts_USCOREType(struct soap *soap, const struct jsdl__CandidateHosts_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->jsdl__HostName)
	{	int i;
		for (i = 0; i < a->__sizeHostName; i++)
		{
			soap_serialize_string(soap, a->jsdl__HostName + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__CandidateHosts_USCOREType(struct soap *soap, const struct jsdl__CandidateHosts_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__CandidateHosts_USCOREType);
	if (soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType), type))
		return soap->error;
	if (a->jsdl__HostName)
	{	int i;
		for (i = 0; i < a->__sizeHostName; i++)
			if (soap_out_string(soap, "jsdl:HostName", -1, a->jsdl__HostName + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_get_jsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_in_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, struct jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__HostName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__CandidateHosts_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, sizeof(struct jsdl__CandidateHosts_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__CandidateHosts_USCOREType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__HostName && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeHostName = 0; !soap_element_begin_in(soap, "jsdl:HostName", 1, NULL); a->__sizeHostName++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:HostName", p, "xsd:string"))
						break;
					soap_flag_jsdl__HostName = 0;
				}
				a->jsdl__HostName = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__HostName && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__CandidateHosts_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, 0, sizeof(struct jsdl__CandidateHosts_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__CandidateHosts = NULL;
	a->__sizeFileSystem = 0;
	a->jsdl__FileSystem = NULL;
	a->jsdl__ExclusiveExecution = NULL;
	a->jsdl__OperatingSystem = NULL;
	a->jsdl__CPUArchitecture = NULL;
	a->jsdl__IndividualCPUSpeed = NULL;
	a->jsdl__IndividualCPUTime = NULL;
	a->jsdl__IndividualCPUCount = NULL;
	a->jsdl__IndividualNetworkBandwidth = NULL;
	a->jsdl__IndividualPhysicalMemory = NULL;
	a->jsdl__IndividualVirtualMemory = NULL;
	a->jsdl__IndividualDiskSpace = NULL;
	a->jsdl__TotalCPUTime = NULL;
	a->jsdl__TotalCPUCount = NULL;
	a->jsdl__TotalPhysicalMemory = NULL;
	a->jsdl__TotalVirtualMemory = NULL;
	a->jsdl__TotalDiskSpace = NULL;
	a->jsdl__TotalResourceCount = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__Resources_USCOREType(struct soap *soap, const struct jsdl__Resources_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, &a->jsdl__CandidateHosts);
	if (a->jsdl__FileSystem)
	{	int i;
		for (i = 0; i < a->__sizeFileSystem; i++)
		{
			soap_embedded(soap, a->jsdl__FileSystem + i, SOAP_TYPE_jsdl__FileSystem_USCOREType);
			soap_serialize_jsdl__FileSystem_USCOREType(soap, a->jsdl__FileSystem + i);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->jsdl__ExclusiveExecution);
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &a->jsdl__OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &a->jsdl__CPUArchitecture);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualCPUSpeed);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualNetworkBandwidth);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__IndividualDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &a->jsdl__TotalResourceCount);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Resources_USCOREType(struct soap *soap, const struct jsdl__Resources_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Resources_USCOREType);
	if (soap_out_jsdl__Resources_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Resources_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Resources_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", -1, &a->jsdl__CandidateHosts, ""))
		return soap->error;
	if (a->jsdl__FileSystem)
	{	int i;
		for (i = 0; i < a->__sizeFileSystem; i++)
			if (soap_out_jsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", -1, a->jsdl__FileSystem + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "jsdl:ExclusiveExecution", -1, &a->jsdl__ExclusiveExecution, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", -1, &a->jsdl__OperatingSystem, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", -1, &a->jsdl__CPUArchitecture, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", -1, &a->jsdl__IndividualCPUSpeed, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", -1, &a->jsdl__IndividualCPUTime, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", -1, &a->jsdl__IndividualCPUCount, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", -1, &a->jsdl__IndividualNetworkBandwidth, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", -1, &a->jsdl__IndividualPhysicalMemory, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", -1, &a->jsdl__IndividualVirtualMemory, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", -1, &a->jsdl__IndividualDiskSpace, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", -1, &a->jsdl__TotalCPUTime, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", -1, &a->jsdl__TotalCPUCount, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", -1, &a->jsdl__TotalPhysicalMemory, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", -1, &a->jsdl__TotalVirtualMemory, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", -1, &a->jsdl__TotalDiskSpace, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", -1, &a->jsdl__TotalResourceCount, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType * SOAP_FMAC4 soap_get_jsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType * SOAP_FMAC4 soap_in_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, struct jsdl__Resources_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__CandidateHosts = 1, soap_flag_jsdl__FileSystem = 1, soap_flag_jsdl__ExclusiveExecution = 1, soap_flag_jsdl__OperatingSystem = 1, soap_flag_jsdl__CPUArchitecture = 1, soap_flag_jsdl__IndividualCPUSpeed = 1, soap_flag_jsdl__IndividualCPUTime = 1, soap_flag_jsdl__IndividualCPUCount = 1, soap_flag_jsdl__IndividualNetworkBandwidth = 1, soap_flag_jsdl__IndividualPhysicalMemory = 1, soap_flag_jsdl__IndividualVirtualMemory = 1, soap_flag_jsdl__IndividualDiskSpace = 1, soap_flag_jsdl__TotalCPUTime = 1, soap_flag_jsdl__TotalCPUCount = 1, soap_flag_jsdl__TotalPhysicalMemory = 1, soap_flag_jsdl__TotalVirtualMemory = 1, soap_flag_jsdl__TotalDiskSpace = 1, soap_flag_jsdl__TotalResourceCount = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Resources_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Resources_USCOREType, sizeof(struct jsdl__Resources_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__Resources_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CandidateHosts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", &a->jsdl__CandidateHosts, "jsdl:CandidateHosts_Type"))
				{	soap_flag_jsdl__CandidateHosts--;
					continue;
				}
			if (soap_flag_jsdl__FileSystem && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__FileSystem_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeFileSystem = 0; !soap_element_begin_in(soap, "jsdl:FileSystem", 1, NULL); a->__sizeFileSystem++)
				{	p = (struct jsdl__FileSystem_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__FileSystem_USCOREType));
					soap_default_jsdl__FileSystem_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", p, "jsdl:FileSystem_Type"))
						break;
					soap_flag_jsdl__FileSystem = 0;
				}
				a->jsdl__FileSystem = (struct jsdl__FileSystem_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__FileSystem && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl__ExclusiveExecution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "jsdl:ExclusiveExecution", &a->jsdl__ExclusiveExecution, "xsd:boolean"))
				{	soap_flag_jsdl__ExclusiveExecution--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", &a->jsdl__OperatingSystem, "jsdl:OperatingSystem_Type"))
				{	soap_flag_jsdl__OperatingSystem--;
					continue;
				}
			if (soap_flag_jsdl__CPUArchitecture && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", &a->jsdl__CPUArchitecture, "jsdl:CPUArchitecture_Type"))
				{	soap_flag_jsdl__CPUArchitecture--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", &a->jsdl__IndividualCPUSpeed, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUSpeed--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", &a->jsdl__IndividualCPUTime, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUTime--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", &a->jsdl__IndividualCPUCount, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUCount--;
					continue;
				}
			if (soap_flag_jsdl__IndividualNetworkBandwidth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", &a->jsdl__IndividualNetworkBandwidth, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualNetworkBandwidth--;
					continue;
				}
			if (soap_flag_jsdl__IndividualPhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", &a->jsdl__IndividualPhysicalMemory, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualPhysicalMemory--;
					continue;
				}
			if (soap_flag_jsdl__IndividualVirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", &a->jsdl__IndividualVirtualMemory, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualVirtualMemory--;
					continue;
				}
			if (soap_flag_jsdl__IndividualDiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", &a->jsdl__IndividualDiskSpace, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualDiskSpace--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", &a->jsdl__TotalCPUTime, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUTime--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", &a->jsdl__TotalCPUCount, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUCount--;
					continue;
				}
			if (soap_flag_jsdl__TotalPhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", &a->jsdl__TotalPhysicalMemory, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalPhysicalMemory--;
					continue;
				}
			if (soap_flag_jsdl__TotalVirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", &a->jsdl__TotalVirtualMemory, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalVirtualMemory--;
					continue;
				}
			if (soap_flag_jsdl__TotalDiskSpace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", &a->jsdl__TotalDiskSpace, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalDiskSpace--;
					continue;
				}
			if (soap_flag_jsdl__TotalResourceCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", &a->jsdl__TotalResourceCount, "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalResourceCount--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__Resources_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Resources_USCOREType, 0, sizeof(struct jsdl__Resources_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->jsdl__ApplicationName);
	soap_default_string(soap, &a->jsdl__ApplicationVersion);
	soap_default_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__Application_USCOREType(struct soap *soap, const struct jsdl__Application_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->jsdl__ApplicationName);
	soap_serialize_string(soap, &a->jsdl__ApplicationVersion);
	soap_serialize_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Application_USCOREType(struct soap *soap, const struct jsdl__Application_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Application_USCOREType);
	if (soap_out_jsdl__Application_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Application_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Application_USCOREType), type))
		return soap->error;
	if (soap_out_string(soap, "jsdl:ApplicationName", -1, &a->jsdl__ApplicationName, ""))
		return soap->error;
	if (soap_out_string(soap, "jsdl:ApplicationVersion", -1, &a->jsdl__ApplicationVersion, ""))
		return soap->error;
	if (soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__Application_USCOREType * SOAP_FMAC4 soap_get_jsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Application_USCOREType * SOAP_FMAC4 soap_in_jsdl__Application_USCOREType(struct soap *soap, const char *tag, struct jsdl__Application_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__ApplicationName = 1, soap_flag_jsdl__ApplicationVersion = 1, soap_flag_jsdl__Description = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Application_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Application_USCOREType, sizeof(struct jsdl__Application_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__Application_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__ApplicationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:ApplicationName", &a->jsdl__ApplicationName, "xsd:string"))
				{	soap_flag_jsdl__ApplicationName--;
					continue;
				}
			if (soap_flag_jsdl__ApplicationVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:ApplicationVersion", &a->jsdl__ApplicationVersion, "xsd:string"))
				{	soap_flag_jsdl__ApplicationVersion--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__Application_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Application_USCOREType, 0, sizeof(struct jsdl__Application_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->jsdl__JobName);
	soap_default_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	a->__sizeJobAnnotation = 0;
	a->jsdl__JobAnnotation = NULL;
	a->__sizeJobProject = 0;
	a->jsdl__JobProject = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__JobIdentification_USCOREType(struct soap *soap, const struct jsdl__JobIdentification_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->jsdl__JobName);
	soap_serialize_jsdl__Description_USCOREType(soap, &a->jsdl__Description);
	if (a->jsdl__JobAnnotation)
	{	int i;
		for (i = 0; i < a->__sizeJobAnnotation; i++)
		{
			soap_serialize_string(soap, a->jsdl__JobAnnotation + i);
		}
	}
	if (a->jsdl__JobProject)
	{	int i;
		for (i = 0; i < a->__sizeJobProject; i++)
		{
			soap_serialize_string(soap, a->jsdl__JobProject + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__JobIdentification_USCOREType(struct soap *soap, const struct jsdl__JobIdentification_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__JobIdentification_USCOREType);
	if (soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__JobIdentification_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobIdentification_USCOREType), type))
		return soap->error;
	if (soap_out_string(soap, "jsdl:JobName", -1, &a->jsdl__JobName, ""))
		return soap->error;
	if (soap_out_jsdl__Description_USCOREType(soap, "jsdl:Description", -1, &a->jsdl__Description, ""))
		return soap->error;
	if (a->jsdl__JobAnnotation)
	{	int i;
		for (i = 0; i < a->__sizeJobAnnotation; i++)
			if (soap_out_string(soap, "jsdl:JobAnnotation", -1, a->jsdl__JobAnnotation + i, ""))
				return soap->error;
	}
	if (a->jsdl__JobProject)
	{	int i;
		for (i = 0; i < a->__sizeJobProject; i++)
			if (soap_out_string(soap, "jsdl:JobProject", -1, a->jsdl__JobProject + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobIdentification_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobName = 1, soap_flag_jsdl__Description = 1, soap_flag_jsdl__JobAnnotation = 1, soap_flag_jsdl__JobProject = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobIdentification_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobIdentification_USCOREType, sizeof(struct jsdl__JobIdentification_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__JobIdentification_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "jsdl:JobName", &a->jsdl__JobName, "xsd:string"))
				{	soap_flag_jsdl__JobName--;
					continue;
				}
			if (soap_flag_jsdl__Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_jsdl__Description_USCOREType(soap, "jsdl:Description", &a->jsdl__Description, "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description--;
					continue;
				}
			if (soap_flag_jsdl__JobAnnotation && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeJobAnnotation = 0; !soap_element_begin_in(soap, "jsdl:JobAnnotation", 1, NULL); a->__sizeJobAnnotation++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:JobAnnotation", p, "xsd:string"))
						break;
					soap_flag_jsdl__JobAnnotation = 0;
				}
				a->jsdl__JobAnnotation = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__JobAnnotation && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_jsdl__JobProject && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeJobProject = 0; !soap_element_begin_in(soap, "jsdl:JobProject", 1, NULL); a->__sizeJobProject++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "jsdl:JobProject", p, "xsd:string"))
						break;
					soap_flag_jsdl__JobProject = 0;
				}
				a->jsdl__JobProject = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__JobProject && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__JobIdentification_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobIdentification_USCOREType, 0, sizeof(struct jsdl__JobIdentification_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__JobIdentification = NULL;
	a->jsdl__Application = NULL;
	a->jsdl__Resources = NULL;
	a->__sizeDataStaging = 0;
	a->jsdl__DataStaging = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__JobDescription_USCOREType(struct soap *soap, const struct jsdl__JobDescription_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, &a->jsdl__JobIdentification);
	soap_serialize_PointerTojsdl__Application_USCOREType(soap, &a->jsdl__Application);
	soap_serialize_PointerTojsdl__Resources_USCOREType(soap, &a->jsdl__Resources);
	if (a->jsdl__DataStaging)
	{	int i;
		for (i = 0; i < a->__sizeDataStaging; i++)
		{
			soap_embedded(soap, a->jsdl__DataStaging + i, SOAP_TYPE_jsdl__DataStaging_USCOREType);
			soap_serialize_jsdl__DataStaging_USCOREType(soap, a->jsdl__DataStaging + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__JobDescription_USCOREType(struct soap *soap, const struct jsdl__JobDescription_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__JobDescription_USCOREType);
	if (soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__JobDescription_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobDescription_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", -1, &a->jsdl__JobIdentification, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", -1, &a->jsdl__Application, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", -1, &a->jsdl__Resources, ""))
		return soap->error;
	if (a->jsdl__DataStaging)
	{	int i;
		for (i = 0; i < a->__sizeDataStaging; i++)
			if (soap_out_jsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", -1, a->jsdl__DataStaging + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobDescription_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobIdentification = 1, soap_flag_jsdl__Application = 1, soap_flag_jsdl__Resources = 1, soap_flag_jsdl__DataStaging = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobDescription_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobDescription_USCOREType, sizeof(struct jsdl__JobDescription_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__JobDescription_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobIdentification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", &a->jsdl__JobIdentification, "jsdl:JobIdentification_Type"))
				{	soap_flag_jsdl__JobIdentification--;
					continue;
				}
			if (soap_flag_jsdl__Application && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", &a->jsdl__Application, "jsdl:Application_Type"))
				{	soap_flag_jsdl__Application--;
					continue;
				}
			if (soap_flag_jsdl__Resources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", &a->jsdl__Resources, "jsdl:Resources_Type"))
				{	soap_flag_jsdl__Resources--;
					continue;
				}
			if (soap_flag_jsdl__DataStaging && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__DataStaging_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeDataStaging = 0; !soap_element_begin_in(soap, "jsdl:DataStaging", 1, NULL); a->__sizeDataStaging++)
				{	p = (struct jsdl__DataStaging_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__DataStaging_USCOREType));
					soap_default_jsdl__DataStaging_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", p, "jsdl:DataStaging_Type"))
						break;
					soap_flag_jsdl__DataStaging = 0;
				}
				a->jsdl__DataStaging = (struct jsdl__DataStaging_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_jsdl__DataStaging && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__JobDescription_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobDescription_USCOREType, 0, sizeof(struct jsdl__JobDescription_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->jsdl__JobDescription = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__ID(soap, &a->id);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__JobDefinition_USCOREType(struct soap *soap, const struct jsdl__JobDefinition_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, &a->jsdl__JobDescription);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__JobDefinition_USCOREType(struct soap *soap, const struct jsdl__JobDefinition_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__JobDefinition_USCOREType);
	if (soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (a->id)
		soap_set_attr(soap, "id", a->id);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobDefinition_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", -1, &a->jsdl__JobDescription, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobDefinition_USCOREType *a, const char *type)
{
	short soap_flag_jsdl__JobDescription = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__JobDefinition_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobDefinition_USCOREType, sizeof(struct jsdl__JobDefinition_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__JobDefinition_USCOREType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "id", 0), &a->id))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", &a->jsdl__JobDescription, "jsdl:JobDescription_Type"))
				{	soap_flag_jsdl__JobDescription--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__JobDefinition_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobDefinition_USCOREType, 0, sizeof(struct jsdl__JobDefinition_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDescription > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->UpperBoundedRange = NULL;
	a->LowerBoundedRange = NULL;
	a->__sizeExact = 0;
	a->Exact = NULL;
	a->__sizeRange = 0;
	a->Range = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__RangeValue_USCOREType(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &a->UpperBoundedRange);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &a->LowerBoundedRange);
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
		{
			soap_embedded(soap, a->Exact + i, SOAP_TYPE_jsdl__Exact_USCOREType);
			soap_serialize_jsdl__Exact_USCOREType(soap, a->Exact + i);
		}
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
		{
			soap_embedded(soap, a->Range + i, SOAP_TYPE_jsdl__Range_USCOREType);
			soap_serialize_jsdl__Range_USCOREType(soap, a->Range + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__RangeValue_USCOREType(struct soap *soap, const struct jsdl__RangeValue_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__RangeValue_USCOREType);
	if (soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__RangeValue_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &a->UpperBoundedRange, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &a->LowerBoundedRange, ""))
		return soap->error;
	if (a->Exact)
	{	int i;
		for (i = 0; i < a->__sizeExact; i++)
			if (soap_out_jsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, a->Exact + i, ""))
				return soap->error;
	}
	if (a->Range)
	{	int i;
		for (i = 0; i < a->__sizeRange; i++)
			if (soap_out_jsdl__Range_USCOREType(soap, "jsdl:Range", -1, a->Range + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get_jsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType *a, const char *type)
{
	short soap_flag_UpperBoundedRange = 1, soap_flag_LowerBoundedRange = 1, soap_flag_Exact = 1, soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__RangeValue_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__RangeValue_USCOREType, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__RangeValue_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &a->UpperBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange--;
					continue;
				}
			if (soap_flag_LowerBoundedRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &a->LowerBoundedRange, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange--;
					continue;
				}
			if (soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Exact_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeExact = 0; !soap_element_begin_in(soap, "jsdl:Exact", 1, NULL); a->__sizeExact++)
				{	p = (struct jsdl__Exact_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Exact_USCOREType));
					soap_default_jsdl__Exact_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Exact_USCOREType(soap, "jsdl:Exact", p, "jsdl:Exact_Type"))
						break;
					soap_flag_Exact = 0;
				}
				a->Exact = (struct jsdl__Exact_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Exact && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
			{	struct jsdl__Range_USCOREType *p;
				soap_new_block(soap);
				for (a->__sizeRange = 0; !soap_element_begin_in(soap, "jsdl:Range", 1, NULL); a->__sizeRange++)
				{	p = (struct jsdl__Range_USCOREType *)soap_push_block(soap, sizeof(struct jsdl__Range_USCOREType));
					soap_default_jsdl__Range_USCOREType(soap, p);
					soap_revert(soap);
					if (!soap_in_jsdl__Range_USCOREType(soap, "jsdl:Range", p, "jsdl:Range_Type"))
						break;
					soap_flag_Range = 0;
				}
				a->Range = (struct jsdl__Range_USCOREType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__RangeValue_USCOREType, 0, sizeof(struct jsdl__RangeValue_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->LowerBound = NULL;
	a->UpperBound = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__Range_USCOREType(struct soap *soap, const struct jsdl__Range_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &a->LowerBound);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &a->UpperBound);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Range_USCOREType(struct soap *soap, const struct jsdl__Range_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Range_USCOREType);
	if (soap_out_jsdl__Range_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Range_USCOREType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Range_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", -1, &a->LowerBound, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", -1, &a->UpperBound, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct jsdl__Range_USCOREType * SOAP_FMAC4 soap_get_jsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Range_USCOREType * SOAP_FMAC4 soap_in_jsdl__Range_USCOREType(struct soap *soap, const char *tag, struct jsdl__Range_USCOREType *a, const char *type)
{
	short soap_flag_LowerBound = 1, soap_flag_UpperBound = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct jsdl__Range_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Range_USCOREType, sizeof(struct jsdl__Range_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_jsdl__Range_USCOREType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LowerBound && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", &a->LowerBound, "jsdl:Boundary_Type"))
				{	soap_flag_LowerBound--;
					continue;
				}
			if (soap_flag_UpperBound && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", &a->UpperBound, "jsdl:Boundary_Type"))
				{	soap_flag_UpperBound--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct jsdl__Range_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Range_USCOREType, 0, sizeof(struct jsdl__Range_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LowerBound > 0 || soap_flag_UpperBound > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->__item);
	a->epsilon = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__Exact_USCOREType(struct soap *soap, const struct jsdl__Exact_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->__item, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Exact_USCOREType(struct soap *soap, const struct jsdl__Exact_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Exact_USCOREType);
	if (soap_out_jsdl__Exact_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Exact_USCOREType *a, const char *type)
{
	if (a->epsilon)
		soap_set_attr(soap, "epsilon", soap_double2s(soap, *a->epsilon));
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_double(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl__Exact_USCOREType * SOAP_FMAC4 soap_get_jsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Exact_USCOREType * SOAP_FMAC4 soap_in_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, struct jsdl__Exact_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl__Exact_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Exact_USCOREType, sizeof(struct jsdl__Exact_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl__Exact_USCOREType(soap, a);
	{	const char *t = soap_attr_value(soap, "epsilon", 0);
		if (t)
		{
			if (!(a->epsilon = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, a->epsilon))
				return NULL;
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_double(soap, tag, &a->__item, "jsdl:Exact_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->__item);
	a->exclusiveBound = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__Boundary_USCOREType(struct soap *soap, const struct jsdl__Boundary_USCOREType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->__item, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Boundary_USCOREType(struct soap *soap, const struct jsdl__Boundary_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Boundary_USCOREType);
	if (soap_out_jsdl__Boundary_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, const struct jsdl__Boundary_USCOREType *a, const char *type)
{
	if (a->exclusiveBound)
		soap_set_attr(soap, "exclusiveBound", soap_xsd__boolean2s(soap, *a->exclusiveBound));
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_double(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_get_jsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_in_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, struct jsdl__Boundary_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct jsdl__Boundary_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Boundary_USCOREType, sizeof(struct jsdl__Boundary_USCOREType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_jsdl__Boundary_USCOREType(soap, a);
	{	const char *t = soap_attr_value(soap, "exclusiveBound", 0);
		if (t)
		{
			if (!(a->exclusiveBound = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->exclusiveBound))
			return NULL;
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_double(soap, tag, &a->__item, "jsdl:Boundary_Type"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ProblemActionType(struct soap *soap, struct wsa__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsa__Action = NULL;
	soap_default_xsd__anyURI(soap, &a->SoapAction);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ProblemActionType(struct soap *soap, const struct wsa__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__AttributedURIType(soap, &a->wsa__Action);
	soap_serialize_xsd__anyURI(soap, &a->SoapAction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ProblemActionType(struct soap *soap, const struct wsa__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ProblemActionType);
	if (soap_out_wsa__ProblemActionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa__ProblemActionType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ProblemActionType), type))
		return soap->error;
	if (soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Action", -1, &a->wsa__Action, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "wsa:SoapAction", -1, &a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ProblemActionType * SOAP_FMAC4 soap_get_wsa__ProblemActionType(struct soap *soap, struct wsa__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ProblemActionType * SOAP_FMAC4 soap_in_wsa__ProblemActionType(struct soap *soap, const char *tag, struct wsa__ProblemActionType *a, const char *type)
{
	short soap_flag_wsa__Action = 1, soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ProblemActionType, sizeof(struct wsa__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ProblemActionType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__Action && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Action", &a->wsa__Action, "wsa:AttributedURIType"))
				{	soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "wsa:SoapAction", &a->SoapAction, "xsd:anyURI"))
				{	soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ProblemActionType, 0, sizeof(struct wsa__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__AttributedQNameType(struct soap *soap, struct wsa__AttributedQNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__AttributedQNameType(struct soap *soap, const struct wsa__AttributedQNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__AttributedQNameType(struct soap *soap, const struct wsa__AttributedQNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__AttributedQNameType);
	if (soap_out_wsa__AttributedQNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__AttributedQNameType(struct soap *soap, const char *tag, int id, const struct wsa__AttributedQNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__AttributedQNameType * SOAP_FMAC4 soap_get_wsa__AttributedQNameType(struct soap *soap, struct wsa__AttributedQNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__AttributedQNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedQNameType * SOAP_FMAC4 soap_in_wsa__AttributedQNameType(struct soap *soap, const char *tag, struct wsa__AttributedQNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedQNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__AttributedQNameType, sizeof(struct wsa__AttributedQNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__AttributedQNameType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in__QName(soap, tag, &a->__item, "wsa:AttributedQNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__AttributedUnsignedLongType(struct soap *soap, struct wsa__AttributedUnsignedLongType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedLONG64(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__AttributedUnsignedLongType(struct soap *soap, const struct wsa__AttributedUnsignedLongType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__AttributedUnsignedLongType(struct soap *soap, const struct wsa__AttributedUnsignedLongType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__AttributedUnsignedLongType);
	if (soap_out_wsa__AttributedUnsignedLongType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__AttributedUnsignedLongType(struct soap *soap, const char *tag, int id, const struct wsa__AttributedUnsignedLongType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedUnsignedLongType * SOAP_FMAC4 soap_get_wsa__AttributedUnsignedLongType(struct soap *soap, struct wsa__AttributedUnsignedLongType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__AttributedUnsignedLongType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedUnsignedLongType * SOAP_FMAC4 soap_in_wsa__AttributedUnsignedLongType(struct soap *soap, const char *tag, struct wsa__AttributedUnsignedLongType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedUnsignedLongType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__AttributedUnsignedLongType, sizeof(struct wsa__AttributedUnsignedLongType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__AttributedUnsignedLongType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_unsignedLONG64(soap, tag, &a->__item, "wsa:AttributedUnsignedLongType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__AttributedURIType(struct soap *soap, const struct wsa__AttributedURIType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__AttributedURIType(struct soap *soap, const struct wsa__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__AttributedURIType);
	if (soap_out_wsa__AttributedURIType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__AttributedURIType(struct soap *soap, const char *tag, int id, const struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_get_wsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType * SOAP_FMAC4 soap_in_wsa__AttributedURIType(struct soap *soap, const char *tag, struct wsa__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__AttributedURIType, sizeof(struct wsa__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__AttributedURIType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, "wsa:AttributedURIType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__RelatesToType(struct soap *soap, struct wsa__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->__item);
	soap_default_wsa__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__RelatesToType(struct soap *soap, const struct wsa__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelatesToType(struct soap *soap, const struct wsa__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__RelatesToType);
	if (soap_out_wsa__RelatesToType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__RelatesToType * SOAP_FMAC4 soap_get_wsa__RelatesToType(struct soap *soap, struct wsa__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__RelatesToType * SOAP_FMAC4 soap_in_wsa__RelatesToType(struct soap *soap, const char *tag, struct wsa__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelatesToType, sizeof(struct wsa__RelatesToType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__RelatesToType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, "wsa:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__MetadataType(struct soap *soap, struct wsa__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__MetadataType(struct soap *soap, const struct wsa__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__MetadataType(struct soap *soap, const struct wsa__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__MetadataType);
	if (soap_out_wsa__MetadataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa__MetadataType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__MetadataType * SOAP_FMAC4 soap_get_wsa__MetadataType(struct soap *soap, struct wsa__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__MetadataType * SOAP_FMAC4 soap_in_wsa__MetadataType(struct soap *soap, const char *tag, struct wsa__MetadataType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__MetadataType, sizeof(struct wsa__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__MetadataType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__MetadataType, 0, sizeof(struct wsa__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferenceParametersType);
	if (soap_out_wsa__ReferenceParametersType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, 0, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Address = NULL;
	a->wsa__ReferenceParameters = NULL;
	a->wsa__Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__AttributedURIType(soap, &a->Address);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->wsa__ReferenceParameters);
	soap_serialize_PointerTowsa__MetadataType(soap, &a->wsa__Metadata);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__EndpointReferenceType);
	if (soap_out_wsa__EndpointReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (soap_out_PointerTowsa__AttributedURIType(soap, "wsa:Address", -1, &a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->wsa__ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa__MetadataType(soap, "wsa:Metadata", -1, &a->wsa__Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	short soap_flag_Address = 1, soap_flag_wsa__ReferenceParameters = 1, soap_flag_wsa__Metadata = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__AttributedURIType(soap, "wsa:Address", &a->Address, "wsa:AttributedURIType"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_wsa__ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->wsa__ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_wsa__ReferenceParameters--;
					continue;
				}
			if (soap_flag_wsa__Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__MetadataType(soap, "wsa:Metadata", &a->wsa__Metadata, "wsa:MetadataType"))
				{	soap_flag_wsa__Metadata--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__TerminateActivityResponseType(struct soap *soap, struct bes__TerminateActivityResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityIdentifier = NULL;
	soap_default_xsd__boolean(soap, &a->Cancelled);
	a->Fault = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__TerminateActivityResponseType(struct soap *soap, const struct bes__TerminateActivityResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &a->ActivityIdentifier);
	soap_embedded(soap, &a->Cancelled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerToxsd__anyType(soap, &a->Fault);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__TerminateActivityResponseType(struct soap *soap, const struct bes__TerminateActivityResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__TerminateActivityResponseType);
	if (soap_out_bes__TerminateActivityResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__TerminateActivityResponseType(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivityResponseType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__TerminateActivityResponseType), type))
		return soap->error;
	if (soap_out_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", -1, &a->ActivityIdentifier, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "bes:Cancelled", -1, &a->Cancelled, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "bes:Fault", -1, &a->Fault, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__TerminateActivityResponseType * SOAP_FMAC4 soap_get_bes__TerminateActivityResponseType(struct soap *soap, struct bes__TerminateActivityResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__TerminateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivityResponseType * SOAP_FMAC4 soap_in_bes__TerminateActivityResponseType(struct soap *soap, const char *tag, struct bes__TerminateActivityResponseType *a, const char *type)
{
	short soap_flag_ActivityIdentifier = 1, soap_flag_Cancelled = 1, soap_flag_Fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivityResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__TerminateActivityResponseType, sizeof(struct bes__TerminateActivityResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__TerminateActivityResponseType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", &a->ActivityIdentifier, "wsa:EndpointReferenceType"))
				{	soap_flag_ActivityIdentifier--;
					continue;
				}
			if (soap_flag_Cancelled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "bes:Cancelled", &a->Cancelled, "xsd:boolean"))
				{	soap_flag_Cancelled--;
					continue;
				}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "bes:Fault", &a->Fault, "xsd:anyType"))
				{	soap_flag_Fault--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__TerminateActivityResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__TerminateActivityResponseType, 0, sizeof(struct bes__TerminateActivityResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityIdentifier > 0 || soap_flag_Cancelled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__GetActivityDocumentResponseType(struct soap *soap, struct bes__GetActivityDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityIdentifier = NULL;
	a->JobDefinition = NULL;
	a->Fault = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__GetActivityDocumentResponseType(struct soap *soap, const struct bes__GetActivityDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &a->ActivityIdentifier);
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &a->JobDefinition);
	soap_serialize_PointerToxsd__anyType(soap, &a->Fault);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__GetActivityDocumentResponseType(struct soap *soap, const struct bes__GetActivityDocumentResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityDocumentResponseType);
	if (soap_out_bes__GetActivityDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__GetActivityDocumentResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentResponseType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityDocumentResponseType), type))
		return soap->error;
	if (soap_out_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", -1, &a->ActivityIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "bes:JobDefinition", -1, &a->JobDefinition, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "bes:Fault", -1, &a->Fault, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityDocumentResponseType * SOAP_FMAC4 soap_get_bes__GetActivityDocumentResponseType(struct soap *soap, struct bes__GetActivityDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentResponseType * SOAP_FMAC4 soap_in_bes__GetActivityDocumentResponseType(struct soap *soap, const char *tag, struct bes__GetActivityDocumentResponseType *a, const char *type)
{
	short soap_flag_ActivityIdentifier = 1, soap_flag_JobDefinition = 1, soap_flag_Fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityDocumentResponseType, sizeof(struct bes__GetActivityDocumentResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityDocumentResponseType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", &a->ActivityIdentifier, "wsa:EndpointReferenceType"))
				{	soap_flag_ActivityIdentifier--;
					continue;
				}
			if (soap_flag_JobDefinition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, "bes:JobDefinition", &a->JobDefinition, "jsdl:JobDefinition_Type"))
				{	soap_flag_JobDefinition--;
					continue;
				}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "bes:Fault", &a->Fault, "xsd:anyType"))
				{	soap_flag_Fault--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityDocumentResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityDocumentResponseType, 0, sizeof(struct bes__GetActivityDocumentResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityIdentifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__GetActivityStatusResponseType(struct soap *soap, struct bes__GetActivityStatusResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityIdentifier = NULL;
	a->bes__ActivityStatus = NULL;
	a->Fault = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__GetActivityStatusResponseType(struct soap *soap, const struct bes__GetActivityStatusResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &a->ActivityIdentifier);
	soap_serialize_PointerTobes__ActivityStatusType(soap, &a->bes__ActivityStatus);
	soap_serialize_PointerToxsd__anyType(soap, &a->Fault);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__GetActivityStatusResponseType(struct soap *soap, const struct bes__GetActivityStatusResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityStatusResponseType);
	if (soap_out_bes__GetActivityStatusResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__GetActivityStatusResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusResponseType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityStatusResponseType), type))
		return soap->error;
	if (soap_out_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", -1, &a->ActivityIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->bes__ActivityStatus, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "bes:Fault", -1, &a->Fault, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityStatusResponseType * SOAP_FMAC4 soap_get_bes__GetActivityStatusResponseType(struct soap *soap, struct bes__GetActivityStatusResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityStatusResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusResponseType * SOAP_FMAC4 soap_in_bes__GetActivityStatusResponseType(struct soap *soap, const char *tag, struct bes__GetActivityStatusResponseType *a, const char *type)
{
	short soap_flag_ActivityIdentifier = 1, soap_flag_bes__ActivityStatus = 1, soap_flag_Fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityStatusResponseType, sizeof(struct bes__GetActivityStatusResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityStatusResponseType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__EndpointReferenceType(soap, "bes:ActivityIdentifier", &a->ActivityIdentifier, "wsa:EndpointReferenceType"))
				{	soap_flag_ActivityIdentifier--;
					continue;
				}
			if (soap_flag_bes__ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->bes__ActivityStatus, "bes:ActivityStatusType"))
				{	soap_flag_bes__ActivityStatus--;
					continue;
				}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "bes:Fault", &a->Fault, "xsd:anyType"))
				{	soap_flag_Fault--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityStatusResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityStatusResponseType, 0, sizeof(struct bes__GetActivityStatusResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityIdentifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_bes__ActivityStateEnumeration(soap, &a->state);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__ActivityStatusType(struct soap *soap, const struct bes__ActivityStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__ActivityStatusType(struct soap *soap, const struct bes__ActivityStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__ActivityStatusType);
	if (soap_out_bes__ActivityStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__ActivityStatusType(struct soap *soap, const char *tag, int id, const struct bes__ActivityStatusType *a, const char *type)
{
	soap_set_attr(soap, "state", soap_bes__ActivityStateEnumeration2s(soap, a->state));
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__ActivityStatusType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__ActivityStatusType * SOAP_FMAC4 soap_get_bes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__ActivityStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityStatusType * SOAP_FMAC4 soap_in_bes__ActivityStatusType(struct soap *soap, const char *tag, struct bes__ActivityStatusType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__ActivityStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__ActivityStatusType, sizeof(struct bes__ActivityStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__ActivityStatusType(soap, a);
	if (soap_s2bes__ActivityStateEnumeration(soap, soap_attr_value(soap, "state", 1), &a->state))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__ActivityStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__ActivityStatusType, 0, sizeof(struct bes__ActivityStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__ActivityDocumentType(struct soap *soap, struct bes__ActivityDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__ActivityDocumentType(struct soap *soap, const struct bes__ActivityDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__ActivityDocumentType(struct soap *soap, const struct bes__ActivityDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__ActivityDocumentType);
	if (soap_out_bes__ActivityDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__ActivityDocumentType(struct soap *soap, const char *tag, int id, const struct bes__ActivityDocumentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__ActivityDocumentType), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__ActivityDocumentType * SOAP_FMAC4 soap_get_bes__ActivityDocumentType(struct soap *soap, struct bes__ActivityDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__ActivityDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityDocumentType * SOAP_FMAC4 soap_in_bes__ActivityDocumentType(struct soap *soap, const char *tag, struct bes__ActivityDocumentType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__ActivityDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__ActivityDocumentType, sizeof(struct bes__ActivityDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__ActivityDocumentType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__ActivityDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__ActivityDocumentType, 0, sizeof(struct bes__ActivityDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__FactoryResourceAttributesDocumentType(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__BasicResourceAttributesDocument = NULL;
	soap_default_xsd__boolean(soap, &a->IsAcceptingNewActivities);
	soap_default_string(soap, &a->CommonName);
	soap_default_string(soap, &a->LongDescription);
	soap_default_LONG64(soap, &a->TotalNumberOfActivities);
	a->__sizeActivityReference = 0;
	a->ActivityReference = NULL;
	soap_default_LONG64(soap, &a->TotalNumberOfContainedResources);
	a->__sizeContainedResource = 0;
	a->ContainedResource = NULL;
	a->__sizeNamingProfile = 0;
	a->NamingProfile = NULL;
	a->__sizeBESExtension = 0;
	a->BESExtension = NULL;
	soap_default_xsd__anyURI(soap, &a->LocalResourceManagerType);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__FactoryResourceAttributesDocumentType(struct soap *soap, const struct bes__FactoryResourceAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__BasicResourceAttributesDocumentType(soap, &a->bes__BasicResourceAttributesDocument);
	soap_embedded(soap, &a->IsAcceptingNewActivities, SOAP_TYPE_xsd__boolean);
	soap_serialize_string(soap, &a->CommonName);
	soap_serialize_string(soap, &a->LongDescription);
	if (a->ActivityReference)
	{	int i;
		for (i = 0; i < a->__sizeActivityReference; i++)
		{
			soap_embedded(soap, a->ActivityReference + i, SOAP_TYPE_wsa__EndpointReferenceType);
			soap_serialize_wsa__EndpointReferenceType(soap, a->ActivityReference + i);
		}
	}
	if (a->ContainedResource)
	{	int i;
		for (i = 0; i < a->__sizeContainedResource; i++)
		{
			soap_embedded(soap, a->ContainedResource + i, SOAP_TYPE_xsd__anyType);
			soap_serialize_xsd__anyType(soap, a->ContainedResource + i);
		}
	}
	if (a->NamingProfile)
	{	int i;
		for (i = 0; i < a->__sizeNamingProfile; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->NamingProfile + i);
		}
	}
	if (a->BESExtension)
	{	int i;
		for (i = 0; i < a->__sizeBESExtension; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->BESExtension + i);
		}
	}
	soap_serialize_xsd__anyURI(soap, &a->LocalResourceManagerType);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__FactoryResourceAttributesDocumentType(struct soap *soap, const struct bes__FactoryResourceAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__FactoryResourceAttributesDocumentType);
	if (soap_out_bes__FactoryResourceAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__FactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, int id, const struct bes__FactoryResourceAttributesDocumentType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__FactoryResourceAttributesDocumentType), type))
		return soap->error;
	if (soap_out_PointerTobes__BasicResourceAttributesDocumentType(soap, "bes:BasicResourceAttributesDocument", -1, &a->bes__BasicResourceAttributesDocument, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "bes:IsAcceptingNewActivities", -1, &a->IsAcceptingNewActivities, ""))
		return soap->error;
	if (soap_out_string(soap, "bes:CommonName", -1, &a->CommonName, ""))
		return soap->error;
	if (soap_out_string(soap, "bes:LongDescription", -1, &a->LongDescription, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "bes:TotalNumberOfActivities", -1, &a->TotalNumberOfActivities, ""))
		return soap->error;
	if (a->ActivityReference)
	{	int i;
		for (i = 0; i < a->__sizeActivityReference; i++)
			if (soap_out_wsa__EndpointReferenceType(soap, "bes:ActivityReference", -1, a->ActivityReference + i, ""))
				return soap->error;
	}
	if (soap_out_LONG64(soap, "bes:TotalNumberOfContainedResources", -1, &a->TotalNumberOfContainedResources, ""))
		return soap->error;
	if (a->ContainedResource)
	{	int i;
		for (i = 0; i < a->__sizeContainedResource; i++)
			if (soap_out_xsd__anyType(soap, "bes:ContainedResource", -1, a->ContainedResource + i, ""))
				return soap->error;
	}
	if (a->NamingProfile)
	{	int i;
		for (i = 0; i < a->__sizeNamingProfile; i++)
			if (soap_out_xsd__anyURI(soap, "bes:NamingProfile", -1, a->NamingProfile + i, ""))
				return soap->error;
	}
	if (a->BESExtension)
	{	int i;
		for (i = 0; i < a->__sizeBESExtension; i++)
			if (soap_out_xsd__anyURI(soap, "bes:BESExtension", -1, a->BESExtension + i, ""))
				return soap->error;
	}
	if (soap_out_xsd__anyURI(soap, "bes:LocalResourceManagerType", -1, &a->LocalResourceManagerType, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_get_bes__FactoryResourceAttributesDocumentType(struct soap *soap, struct bes__FactoryResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__FactoryResourceAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_in_bes__FactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, struct bes__FactoryResourceAttributesDocumentType *a, const char *type)
{
	short soap_flag_bes__BasicResourceAttributesDocument = 1, soap_flag_IsAcceptingNewActivities = 1, soap_flag_CommonName = 1, soap_flag_LongDescription = 1, soap_flag_TotalNumberOfActivities = 1, soap_flag_ActivityReference = 1, soap_flag_TotalNumberOfContainedResources = 1, soap_flag_ContainedResource = 1, soap_flag_NamingProfile = 1, soap_flag_BESExtension = 1, soap_flag_LocalResourceManagerType = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__FactoryResourceAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__FactoryResourceAttributesDocumentType, sizeof(struct bes__FactoryResourceAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__FactoryResourceAttributesDocumentType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__BasicResourceAttributesDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__BasicResourceAttributesDocumentType(soap, "bes:BasicResourceAttributesDocument", &a->bes__BasicResourceAttributesDocument, "bes:BasicResourceAttributesDocumentType"))
				{	soap_flag_bes__BasicResourceAttributesDocument--;
					continue;
				}
			if (soap_flag_IsAcceptingNewActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "bes:IsAcceptingNewActivities", &a->IsAcceptingNewActivities, "xsd:boolean"))
				{	soap_flag_IsAcceptingNewActivities--;
					continue;
				}
			if (soap_flag_CommonName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:CommonName", &a->CommonName, "xsd:string"))
				{	soap_flag_CommonName--;
					continue;
				}
			if (soap_flag_LongDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:LongDescription", &a->LongDescription, "xsd:string"))
				{	soap_flag_LongDescription--;
					continue;
				}
			if (soap_flag_TotalNumberOfActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "bes:TotalNumberOfActivities", &a->TotalNumberOfActivities, "xsd:long"))
				{	soap_flag_TotalNumberOfActivities--;
					continue;
				}
			if (soap_flag_ActivityReference && soap->error == SOAP_TAG_MISMATCH)
			{	struct wsa__EndpointReferenceType *p;
				soap_new_block(soap);
				for (a->__sizeActivityReference = 0; !soap_element_begin_in(soap, "bes:ActivityReference", 1, NULL); a->__sizeActivityReference++)
				{	p = (struct wsa__EndpointReferenceType *)soap_push_block(soap, sizeof(struct wsa__EndpointReferenceType));
					soap_default_wsa__EndpointReferenceType(soap, p);
					soap_revert(soap);
					if (!soap_in_wsa__EndpointReferenceType(soap, "bes:ActivityReference", p, "wsa:EndpointReferenceType"))
						break;
					soap_flag_ActivityReference = 0;
				}
				a->ActivityReference = (struct wsa__EndpointReferenceType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ActivityReference && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_TotalNumberOfContainedResources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "bes:TotalNumberOfContainedResources", &a->TotalNumberOfContainedResources, "xsd:long"))
				{	soap_flag_TotalNumberOfContainedResources--;
					continue;
				}
			if (soap_flag_ContainedResource && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__sizeContainedResource = 0; !soap_element_begin_in(soap, "bes:ContainedResource", 1, NULL); a->__sizeContainedResource++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					soap_revert(soap);
					if (!soap_in_xsd__anyType(soap, "bes:ContainedResource", p, "xsd:anyType"))
						break;
					soap_flag_ContainedResource = 0;
				}
				a->ContainedResource = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_ContainedResource && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_NamingProfile && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeNamingProfile = 0; !soap_element_begin_in(soap, "bes:NamingProfile", 1, NULL); a->__sizeNamingProfile++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_xsd__anyURI(soap, "bes:NamingProfile", p, "xsd:anyURI"))
						break;
					soap_flag_NamingProfile = 0;
				}
				a->NamingProfile = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_NamingProfile && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_BESExtension && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeBESExtension = 0; !soap_element_begin_in(soap, "bes:BESExtension", 1, NULL); a->__sizeBESExtension++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_xsd__anyURI(soap, "bes:BESExtension", p, "xsd:anyURI"))
						break;
					soap_flag_BESExtension = 0;
				}
				a->BESExtension = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_BESExtension && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_LocalResourceManagerType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "bes:LocalResourceManagerType", &a->LocalResourceManagerType, "xsd:anyURI"))
				{	soap_flag_LocalResourceManagerType--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__FactoryResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__FactoryResourceAttributesDocumentType, 0, sizeof(struct bes__FactoryResourceAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IsAcceptingNewActivities > 0 || soap_flag_TotalNumberOfActivities > 0 || soap_flag_TotalNumberOfContainedResources > 0 || soap_flag_LocalResourceManagerType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ResourceName);
	a->OperatingSystem = NULL;
	a->CPUArchitecture = NULL;
	a->CPUCount = NULL;
	a->CPUSpeed = NULL;
	a->PhysicalMemory = NULL;
	a->VirtualMemory = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__BasicResourceAttributesDocumentType(struct soap *soap, const struct bes__BasicResourceAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ResourceName);
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &a->OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &a->CPUArchitecture);
	soap_serialize_PointerTodouble(soap, &a->CPUCount);
	soap_serialize_PointerTodouble(soap, &a->CPUSpeed);
	soap_serialize_PointerTodouble(soap, &a->PhysicalMemory);
	soap_serialize_PointerTodouble(soap, &a->VirtualMemory);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__BasicResourceAttributesDocumentType(struct soap *soap, const struct bes__BasicResourceAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__BasicResourceAttributesDocumentType);
	if (soap_out_bes__BasicResourceAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__BasicResourceAttributesDocumentType(struct soap *soap, const char *tag, int id, const struct bes__BasicResourceAttributesDocumentType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__BasicResourceAttributesDocumentType), type))
		return soap->error;
	if (soap_out_string(soap, "bes:ResourceName", -1, &a->ResourceName, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "bes:OperatingSystem", -1, &a->OperatingSystem, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "bes:CPUArchitecture", -1, &a->CPUArchitecture, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "bes:CPUCount", -1, &a->CPUCount, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "bes:CPUSpeed", -1, &a->CPUSpeed, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "bes:PhysicalMemory", -1, &a->PhysicalMemory, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "bes:VirtualMemory", -1, &a->VirtualMemory, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType * SOAP_FMAC4 soap_get_bes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__BasicResourceAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType * SOAP_FMAC4 soap_in_bes__BasicResourceAttributesDocumentType(struct soap *soap, const char *tag, struct bes__BasicResourceAttributesDocumentType *a, const char *type)
{
	short soap_flag_ResourceName = 1, soap_flag_OperatingSystem = 1, soap_flag_CPUArchitecture = 1, soap_flag_CPUCount = 1, soap_flag_CPUSpeed = 1, soap_flag_PhysicalMemory = 1, soap_flag_VirtualMemory = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__BasicResourceAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__BasicResourceAttributesDocumentType, sizeof(struct bes__BasicResourceAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__BasicResourceAttributesDocumentType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResourceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:ResourceName", &a->ResourceName, "xsd:string"))
				{	soap_flag_ResourceName--;
					continue;
				}
			if (soap_flag_OperatingSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "bes:OperatingSystem", &a->OperatingSystem, "jsdl:OperatingSystem_Type"))
				{	soap_flag_OperatingSystem--;
					continue;
				}
			if (soap_flag_CPUArchitecture && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "bes:CPUArchitecture", &a->CPUArchitecture, "jsdl:CPUArchitecture_Type"))
				{	soap_flag_CPUArchitecture--;
					continue;
				}
			if (soap_flag_CPUCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:CPUCount", &a->CPUCount, "xsd:double"))
				{	soap_flag_CPUCount--;
					continue;
				}
			if (soap_flag_CPUSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:CPUSpeed", &a->CPUSpeed, "xsd:double"))
				{	soap_flag_CPUSpeed--;
					continue;
				}
			if (soap_flag_PhysicalMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:PhysicalMemory", &a->PhysicalMemory, "xsd:double"))
				{	soap_flag_PhysicalMemory--;
					continue;
				}
			if (soap_flag_VirtualMemory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "bes:VirtualMemory", &a->VirtualMemory, "xsd:double"))
				{	soap_flag_VirtualMemory--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__BasicResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__BasicResourceAttributesDocumentType, 0, sizeof(struct bes__BasicResourceAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeInvalidElement = 0;
	a->InvalidElement = NULL;
	soap_default_string(soap, &a->Message);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__InvalidRequestMessageFaultType(struct soap *soap, const struct bes__InvalidRequestMessageFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->InvalidElement)
	{	int i;
		for (i = 0; i < a->__sizeInvalidElement; i++)
		{
			soap_serialize_string(soap, a->InvalidElement + i);
		}
	}
	soap_serialize_string(soap, &a->Message);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__InvalidRequestMessageFaultType(struct soap *soap, const struct bes__InvalidRequestMessageFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__InvalidRequestMessageFaultType);
	if (soap_out_bes__InvalidRequestMessageFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__InvalidRequestMessageFaultType(struct soap *soap, const char *tag, int id, const struct bes__InvalidRequestMessageFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__InvalidRequestMessageFaultType), type))
		return soap->error;
	if (a->InvalidElement)
	{	int i;
		for (i = 0; i < a->__sizeInvalidElement; i++)
			if (soap_out_string(soap, "bes:InvalidElement", -1, a->InvalidElement + i, ""))
				return soap->error;
	}
	if (soap_out_string(soap, "bes:Message", -1, &a->Message, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType * SOAP_FMAC4 soap_get_bes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__InvalidRequestMessageFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType * SOAP_FMAC4 soap_in_bes__InvalidRequestMessageFaultType(struct soap *soap, const char *tag, struct bes__InvalidRequestMessageFaultType *a, const char *type)
{
	short soap_flag_InvalidElement = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__InvalidRequestMessageFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__InvalidRequestMessageFaultType, sizeof(struct bes__InvalidRequestMessageFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__InvalidRequestMessageFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InvalidElement && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeInvalidElement = 0; !soap_element_begin_in(soap, "bes:InvalidElement", 1, NULL); a->__sizeInvalidElement++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "bes:InvalidElement", p, "xsd:string"))
						break;
					soap_flag_InvalidElement = 0;
				}
				a->InvalidElement = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_InvalidElement && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__InvalidRequestMessageFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__InvalidRequestMessageFaultType, 0, sizeof(struct bes__InvalidRequestMessageFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__InvalidActivityIdentifierFaultType(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__InvalidActivityIdentifierFaultType(struct soap *soap, const struct bes__InvalidActivityIdentifierFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Message);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__InvalidActivityIdentifierFaultType(struct soap *soap, const struct bes__InvalidActivityIdentifierFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__InvalidActivityIdentifierFaultType);
	if (soap_out_bes__InvalidActivityIdentifierFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__InvalidActivityIdentifierFaultType(struct soap *soap, const char *tag, int id, const struct bes__InvalidActivityIdentifierFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__InvalidActivityIdentifierFaultType), type))
		return soap->error;
	if (soap_out_string(soap, "bes:Message", -1, &a->Message, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__InvalidActivityIdentifierFaultType * SOAP_FMAC4 soap_get_bes__InvalidActivityIdentifierFaultType(struct soap *soap, struct bes__InvalidActivityIdentifierFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__InvalidActivityIdentifierFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidActivityIdentifierFaultType * SOAP_FMAC4 soap_in_bes__InvalidActivityIdentifierFaultType(struct soap *soap, const char *tag, struct bes__InvalidActivityIdentifierFaultType *a, const char *type)
{
	short soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__InvalidActivityIdentifierFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__InvalidActivityIdentifierFaultType, sizeof(struct bes__InvalidActivityIdentifierFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__InvalidActivityIdentifierFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__InvalidActivityIdentifierFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__InvalidActivityIdentifierFaultType, 0, sizeof(struct bes__InvalidActivityIdentifierFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityStatus = NULL;
	soap_default_string(soap, &a->Message);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, const struct bes__OperationWillBeAppliedEventuallyFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__ActivityStatusType(soap, &a->ActivityStatus);
	soap_serialize_string(soap, &a->Message);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, const struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType);
	if (soap_out_bes__OperationWillBeAppliedEventuallyFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, const char *tag, int id, const struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType), type))
		return soap->error;
	if (soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->ActivityStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "bes:Message", -1, &a->Message, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__OperationWillBeAppliedEventuallyFaultType * SOAP_FMAC4 soap_get_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, struct bes__OperationWillBeAppliedEventuallyFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__OperationWillBeAppliedEventuallyFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__OperationWillBeAppliedEventuallyFaultType * SOAP_FMAC4 soap_in_bes__OperationWillBeAppliedEventuallyFaultType(struct soap *soap, const char *tag, struct bes__OperationWillBeAppliedEventuallyFaultType *a, const char *type)
{
	short soap_flag_ActivityStatus = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__OperationWillBeAppliedEventuallyFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType, sizeof(struct bes__OperationWillBeAppliedEventuallyFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__OperationWillBeAppliedEventuallyFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->ActivityStatus, "bes:ActivityStatusType"))
				{	soap_flag_ActivityStatus--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__OperationWillBeAppliedEventuallyFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__OperationWillBeAppliedEventuallyFaultType, 0, sizeof(struct bes__OperationWillBeAppliedEventuallyFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityStatus > 0 || soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ActivityStatus = NULL;
	soap_default_string(soap, &a->Message);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, const struct bes__CantApplyOperationToCurrentStateFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__ActivityStatusType(soap, &a->ActivityStatus);
	soap_serialize_string(soap, &a->Message);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, const struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType);
	if (soap_out_bes__CantApplyOperationToCurrentStateFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, const char *tag, int id, const struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType), type))
		return soap->error;
	if (soap_out_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", -1, &a->ActivityStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "bes:Message", -1, &a->Message, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__CantApplyOperationToCurrentStateFaultType * SOAP_FMAC4 soap_get_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, struct bes__CantApplyOperationToCurrentStateFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__CantApplyOperationToCurrentStateFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CantApplyOperationToCurrentStateFaultType * SOAP_FMAC4 soap_in_bes__CantApplyOperationToCurrentStateFaultType(struct soap *soap, const char *tag, struct bes__CantApplyOperationToCurrentStateFaultType *a, const char *type)
{
	short soap_flag_ActivityStatus = 1, soap_flag_Message = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CantApplyOperationToCurrentStateFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType, sizeof(struct bes__CantApplyOperationToCurrentStateFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__CantApplyOperationToCurrentStateFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__ActivityStatusType(soap, "bes:ActivityStatus", &a->ActivityStatus, "bes:ActivityStatusType"))
				{	soap_flag_ActivityStatus--;
					continue;
				}
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bes:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__CantApplyOperationToCurrentStateFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__CantApplyOperationToCurrentStateFaultType, 0, sizeof(struct bes__CantApplyOperationToCurrentStateFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ActivityStatus > 0 || soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeFeature = 0;
	a->Feature = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__UnsupportedFeatureFaultType(struct soap *soap, const struct bes__UnsupportedFeatureFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Feature)
	{	int i;
		for (i = 0; i < a->__sizeFeature; i++)
		{
			soap_serialize_string(soap, a->Feature + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__UnsupportedFeatureFaultType(struct soap *soap, const struct bes__UnsupportedFeatureFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__UnsupportedFeatureFaultType);
	if (soap_out_bes__UnsupportedFeatureFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, int id, const struct bes__UnsupportedFeatureFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__UnsupportedFeatureFaultType), type))
		return soap->error;
	if (a->Feature)
	{	int i;
		for (i = 0; i < a->__sizeFeature; i++)
			if (soap_out_string(soap, "bes:Feature", -1, a->Feature + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_get_bes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__UnsupportedFeatureFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_in_bes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, struct bes__UnsupportedFeatureFaultType *a, const char *type)
{
	short soap_flag_Feature = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__UnsupportedFeatureFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__UnsupportedFeatureFaultType, sizeof(struct bes__UnsupportedFeatureFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__UnsupportedFeatureFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Feature && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (a->__sizeFeature = 0; !soap_element_begin_in(soap, "bes:Feature", 1, NULL); a->__sizeFeature++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_string(soap, "bes:Feature", p, "xsd:string"))
						break;
					soap_flag_Feature = 0;
				}
				a->Feature = (char **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Feature && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__UnsupportedFeatureFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__UnsupportedFeatureFaultType, 0, sizeof(struct bes__UnsupportedFeatureFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const struct bes__NotAcceptingNewActivitiesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const struct bes__NotAcceptingNewActivitiesFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType);
	if (soap_out_bes__NotAcceptingNewActivitiesFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, int id, const struct bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_get_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_in_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, struct bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__NotAcceptingNewActivitiesFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__NotAcceptingNewActivitiesFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__NotAcceptingNewActivitiesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType, 0, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__NotAuthorizedFaultType(struct soap *soap, const struct bes__NotAuthorizedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__NotAuthorizedFaultType(struct soap *soap, const struct bes__NotAuthorizedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__NotAuthorizedFaultType);
	if (soap_out_bes__NotAuthorizedFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__NotAuthorizedFaultType(struct soap *soap, const char *tag, int id, const struct bes__NotAuthorizedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__NotAuthorizedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType * SOAP_FMAC4 soap_get_bes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__NotAuthorizedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType * SOAP_FMAC4 soap_in_bes__NotAuthorizedFaultType(struct soap *soap, const char *tag, struct bes__NotAuthorizedFaultType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__NotAuthorizedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__NotAuthorizedFaultType, sizeof(struct bes__NotAuthorizedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__NotAuthorizedFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__NotAuthorizedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__NotAuthorizedFaultType, 0, sizeof(struct bes__NotAuthorizedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const struct bes__GetFactoryAttributesDocumentResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const struct bes__GetFactoryAttributesDocumentResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType);
	if (soap_out_bes__GetFactoryAttributesDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType), type))
		return soap->error;
	if (a->__any)
		soap_element_result(soap, "-any");
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_get_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetFactoryAttributesDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_in_bes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetFactoryAttributesDocumentResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetFactoryAttributesDocumentResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetFactoryAttributesDocumentResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType, 0, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__GetFactoryAttributesDocumentType(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__GetFactoryAttributesDocumentType(struct soap *soap, const struct bes__GetFactoryAttributesDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__GetFactoryAttributesDocumentType(struct soap *soap, const struct bes__GetFactoryAttributesDocumentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetFactoryAttributesDocumentType);
	if (soap_out_bes__GetFactoryAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, int id, const struct bes__GetFactoryAttributesDocumentType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetFactoryAttributesDocumentType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_get_bes__GetFactoryAttributesDocumentType(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetFactoryAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_in_bes__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetFactoryAttributesDocumentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetFactoryAttributesDocumentType, sizeof(struct bes__GetFactoryAttributesDocumentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetFactoryAttributesDocumentType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetFactoryAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetFactoryAttributesDocumentType, 0, sizeof(struct bes__GetFactoryAttributesDocumentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__GetActivityDocumentsResponseType(struct soap *soap, const struct bes__GetActivityDocumentsResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__GetActivityDocumentsResponseType(struct soap *soap, const struct bes__GetActivityDocumentsResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityDocumentsResponseType);
	if (soap_out_bes__GetActivityDocumentsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentsResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityDocumentsResponseType), type))
		return soap->error;
	if (a->__any)
		soap_element_result(soap, "-any");
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_get_bes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityDocumentsResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_in_bes__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentsResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityDocumentsResponseType, sizeof(struct bes__GetActivityDocumentsResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityDocumentsResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityDocumentsResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityDocumentsResponseType, 0, sizeof(struct bes__GetActivityDocumentsResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__GetActivityDocumentsType(struct soap *soap, struct bes__GetActivityDocumentsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__GetActivityDocumentsType(struct soap *soap, const struct bes__GetActivityDocumentsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__GetActivityDocumentsType(struct soap *soap, const struct bes__GetActivityDocumentsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityDocumentsType);
	if (soap_out_bes__GetActivityDocumentsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__GetActivityDocumentsType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityDocumentsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityDocumentsType), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityDocumentsType * SOAP_FMAC4 soap_get_bes__GetActivityDocumentsType(struct soap *soap, struct bes__GetActivityDocumentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityDocumentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsType * SOAP_FMAC4 soap_in_bes__GetActivityDocumentsType(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityDocumentsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityDocumentsType, sizeof(struct bes__GetActivityDocumentsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityDocumentsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityDocumentsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityDocumentsType, 0, sizeof(struct bes__GetActivityDocumentsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResponse = 0;
	a->Response = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__TerminateActivitiesResponseType(struct soap *soap, const struct bes__TerminateActivitiesResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Response)
	{	int i;
		for (i = 0; i < a->__sizeResponse; i++)
		{
			soap_embedded(soap, a->Response + i, SOAP_TYPE_bes__TerminateActivityResponseType);
			soap_serialize_bes__TerminateActivityResponseType(soap, a->Response + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__TerminateActivitiesResponseType(struct soap *soap, const struct bes__TerminateActivitiesResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__TerminateActivitiesResponseType);
	if (soap_out_bes__TerminateActivitiesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__TerminateActivitiesResponseType(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivitiesResponseType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__TerminateActivitiesResponseType), type))
		return soap->error;
	soap_element_result(soap, "-sizeResponse");
	if (a->Response)
	{	int i;
		for (i = 0; i < a->__sizeResponse; i++)
			if (soap_out_bes__TerminateActivityResponseType(soap, "bes:Response", -1, a->Response + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType * SOAP_FMAC4 soap_get_bes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__TerminateActivitiesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType * SOAP_FMAC4 soap_in_bes__TerminateActivitiesResponseType(struct soap *soap, const char *tag, struct bes__TerminateActivitiesResponseType *a, const char *type)
{
	short soap_flag_Response = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivitiesResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__TerminateActivitiesResponseType, sizeof(struct bes__TerminateActivitiesResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__TerminateActivitiesResponseType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Response && soap->error == SOAP_TAG_MISMATCH)
			{	struct bes__TerminateActivityResponseType *p;
				soap_new_block(soap);
				for (a->__sizeResponse = 0; !soap_element_begin_in(soap, "bes:Response", 1, NULL); a->__sizeResponse++)
				{	p = (struct bes__TerminateActivityResponseType *)soap_push_block(soap, sizeof(struct bes__TerminateActivityResponseType));
					soap_default_bes__TerminateActivityResponseType(soap, p);
					soap_revert(soap);
					if (!soap_in_bes__TerminateActivityResponseType(soap, "bes:Response", p, "bes:TerminateActivityResponseType"))
						break;
					soap_flag_Response = 0;
				}
				a->Response = (struct bes__TerminateActivityResponseType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Response && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			soap_check_result(soap, "-sizeResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__TerminateActivitiesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__TerminateActivitiesResponseType, 0, sizeof(struct bes__TerminateActivitiesResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__TerminateActivitiesType(struct soap *soap, struct bes__TerminateActivitiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__TerminateActivitiesType(struct soap *soap, const struct bes__TerminateActivitiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__TerminateActivitiesType(struct soap *soap, const struct bes__TerminateActivitiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__TerminateActivitiesType);
	if (soap_out_bes__TerminateActivitiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__TerminateActivitiesType(struct soap *soap, const char *tag, int id, const struct bes__TerminateActivitiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__TerminateActivitiesType), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__TerminateActivitiesType * SOAP_FMAC4 soap_get_bes__TerminateActivitiesType(struct soap *soap, struct bes__TerminateActivitiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__TerminateActivitiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesType * SOAP_FMAC4 soap_in_bes__TerminateActivitiesType(struct soap *soap, const char *tag, struct bes__TerminateActivitiesType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__TerminateActivitiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__TerminateActivitiesType, sizeof(struct bes__TerminateActivitiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__TerminateActivitiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__TerminateActivitiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__TerminateActivitiesType, 0, sizeof(struct bes__TerminateActivitiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__GetActivityStatusesResponseType(struct soap *soap, const struct bes__GetActivityStatusesResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__GetActivityStatusesResponseType(struct soap *soap, const struct bes__GetActivityStatusesResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityStatusesResponseType);
	if (soap_out_bes__GetActivityStatusesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__GetActivityStatusesResponseType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusesResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityStatusesResponseType), type))
		return soap->error;
	if (a->__any)
		soap_element_result(soap, "-any");
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType * SOAP_FMAC4 soap_get_bes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityStatusesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType * SOAP_FMAC4 soap_in_bes__GetActivityStatusesResponseType(struct soap *soap, const char *tag, struct bes__GetActivityStatusesResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusesResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityStatusesResponseType, sizeof(struct bes__GetActivityStatusesResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityStatusesResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityStatusesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityStatusesResponseType, 0, sizeof(struct bes__GetActivityStatusesResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__GetActivityStatusesType(struct soap *soap, struct bes__GetActivityStatusesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__GetActivityStatusesType(struct soap *soap, const struct bes__GetActivityStatusesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__GetActivityStatusesType(struct soap *soap, const struct bes__GetActivityStatusesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__GetActivityStatusesType);
	if (soap_out_bes__GetActivityStatusesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__GetActivityStatusesType(struct soap *soap, const char *tag, int id, const struct bes__GetActivityStatusesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__GetActivityStatusesType), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__GetActivityStatusesType * SOAP_FMAC4 soap_get_bes__GetActivityStatusesType(struct soap *soap, struct bes__GetActivityStatusesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__GetActivityStatusesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesType * SOAP_FMAC4 soap_in_bes__GetActivityStatusesType(struct soap *soap, const char *tag, struct bes__GetActivityStatusesType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__GetActivityStatusesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__GetActivityStatusesType, sizeof(struct bes__GetActivityStatusesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__GetActivityStatusesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityStatusesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__GetActivityStatusesType, 0, sizeof(struct bes__GetActivityStatusesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__CreateActivityResponseType(struct soap *soap, const struct bes__CreateActivityResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__CreateActivityResponseType(struct soap *soap, const struct bes__CreateActivityResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__CreateActivityResponseType);
	if (soap_out_bes__CreateActivityResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__CreateActivityResponseType(struct soap *soap, const char *tag, int id, const struct bes__CreateActivityResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__CreateActivityResponseType), type))
		return soap->error;
	if (a->__any)
		soap_element_result(soap, "-any");
	if (soap_out_PointerToxsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__CreateActivityResponseType * SOAP_FMAC4 soap_get_bes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__CreateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityResponseType * SOAP_FMAC4 soap_in_bes__CreateActivityResponseType(struct soap *soap, const char *tag, struct bes__CreateActivityResponseType *a, const char *type)
{
	short soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CreateActivityResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__CreateActivityResponseType, sizeof(struct bes__CreateActivityResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__CreateActivityResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			soap_check_result(soap, "-any");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__CreateActivityResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__CreateActivityResponseType, 0, sizeof(struct bes__CreateActivityResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bes__ActivityDocumentType(soap, &a->bes__ActivityDocument);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bes__CreateActivityType(struct soap *soap, const struct bes__CreateActivityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_bes__ActivityDocumentType(soap, &a->bes__ActivityDocument);
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__CreateActivityType(struct soap *soap, const struct bes__CreateActivityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__CreateActivityType);
	if (soap_out_bes__CreateActivityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__CreateActivityType(struct soap *soap, const char *tag, int id, const struct bes__CreateActivityType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__CreateActivityType), type))
		return soap->error;
	if (soap_out_bes__ActivityDocumentType(soap, "bes:ActivityDocument", -1, &a->bes__ActivityDocument, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bes__CreateActivityType * SOAP_FMAC4 soap_get_bes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__CreateActivityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityType * SOAP_FMAC4 soap_in_bes__CreateActivityType(struct soap *soap, const char *tag, struct bes__CreateActivityType *a, const char *type)
{
	short soap_flag_bes__ActivityDocument = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bes__CreateActivityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes__CreateActivityType, sizeof(struct bes__CreateActivityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bes__CreateActivityType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__ActivityDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bes__ActivityDocumentType(soap, "bes:ActivityDocument", &a->bes__ActivityDocument, "bes:ActivityDocumentType"))
				{	soap_flag_bes__ActivityDocument--;
					continue;
				}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	struct soap_dom_element *p;
				soap_new_block(soap);
				for (a->__size = 0; !soap_peek_element(soap); a->__size++)
				{	p = (struct soap_dom_element *)soap_push_block(soap, sizeof(struct soap_dom_element));
					soap_default_xsd__anyType(soap, p);
					if (!soap_in_xsd__anyType(soap, "-any", p, "xsd:anyType"))
						break;
					soap_flag___any = 0;
				}
				a->__any = (struct soap_dom_element *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bes__CreateActivityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__CreateActivityType, 0, sizeof(struct bes__CreateActivityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bes__ActivityDocument > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyAttribute(struct soap *soap, const struct soap_dom_attribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyAttribute);
	if (soap_out_xsd__anyAttribute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_attribute * SOAP_FMAC4 soap_get_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyType(struct soap *soap, const struct soap_dom_element *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (soap_out_xsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, struct soap_dom_element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	short soap_flag_wsu__Timestamp = 1, soap_flag_UsernameToken = 1, soap_flag_BinarySecurityToken = 1, soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	short soap_flag_Modulus = 1, soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	short soap_flag_G = 1, soap_flag_Y = 1, soap_flag_J = 1, soap_flag_P = 1, soap_flag_Q = 1, soap_flag_Seed = 1, soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
		return soap->error;
	if (soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	short soap_flag_X509IssuerName = 1, soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	short soap_flag_X509IssuerSerial = 1, soap_flag_X509SKI = 1, soap_flag_X509SubjectName = 1, soap_flag_X509Certificate = 1, soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	short soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	short soap_flag_DSAKeyValue = 1, soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	short soap_flag_c14n__InclusiveNamespaces = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	short soap_flag_Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transform && soap->error == SOAP_TAG_MISMATCH)
			{	struct ds__TransformType *p;
				soap_new_block(soap);
				for (a->__sizeTransform = 0; !soap_element_begin_in(soap, "ds:Transform", 1, NULL); a->__sizeTransform++)
				{	p = (struct ds__TransformType *)soap_push_block(soap, sizeof(struct ds__TransformType));
					soap_default_ds__TransformType(soap, p);
					soap_revert(soap);
					if (!soap_in_ds__TransformType(soap, "ds:Transform", p, "ds:TransformType"))
						break;
					soap_flag_Transform = 0;
				}
				a->Transform = (struct ds__TransformType *)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Transform && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	short soap_flag_Transforms = 1, soap_flag_DigestMethod = 1, soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	short soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	short soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	short soap_flag_KeyName = 1, soap_flag_KeyValue = 1, soap_flag_RetrievalMethod = 1, soap_flag_X509Data = 1, soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	short soap_flag_CanonicalizationMethod = 1, soap_flag_SignatureMethod = 1, soap_flag_Reference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
			{	struct ds__ReferenceType **p;
				soap_new_block(soap);
				for (a->__sizeReference = 0; !soap_element_begin_in(soap, "ds:Reference", 1, NULL); a->__sizeReference++)
				{	p = (struct ds__ReferenceType **)soap_push_block(soap, sizeof(struct ds__ReferenceType *));
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTods__ReferenceType(soap, "ds:Reference", p, "ds:ReferenceType"))
						break;
					soap_flag_Reference = 0;
				}
				a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	short soap_flag_SignedInfo = 1, soap_flag_SignatureValue = 1, soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	short soap_flag_Reference = 1, soap_flag_KeyIdentifier = 1, soap_flag_Embedded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	short soap_flag_Username = 1, soap_flag_Password = 1, soap_flag_Nonce = 1, soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	short soap_flag_Created = 1, soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType))
		soap_serialize_bes__GetFactoryAttributesDocumentResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentResponseType);
	if (soap_out_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, int id, struct bes__GetFactoryAttributesDocumentResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__GetFactoryAttributesDocumentResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType ** SOAP_FMAC4 soap_get_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, struct bes__GetFactoryAttributesDocumentResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__GetFactoryAttributesDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentResponseType ** SOAP_FMAC4 soap_in_PointerTobes__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__GetFactoryAttributesDocumentResponseType **)soap_malloc(soap, sizeof(struct bes__GetFactoryAttributesDocumentResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__GetFactoryAttributesDocumentResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__GetFactoryAttributesDocumentResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__GetFactoryAttributesDocumentResponseType, sizeof(struct bes__GetFactoryAttributesDocumentResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__GetFactoryAttributesDocumentType(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__GetFactoryAttributesDocumentType))
		soap_serialize_bes__GetFactoryAttributesDocumentType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__GetFactoryAttributesDocumentType(struct soap *soap, struct bes__GetFactoryAttributesDocumentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__GetFactoryAttributesDocumentType);
	if (soap_out_PointerTobes__GetFactoryAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, int id, struct bes__GetFactoryAttributesDocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__GetFactoryAttributesDocumentType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__GetFactoryAttributesDocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType ** SOAP_FMAC4 soap_get_PointerTobes__GetFactoryAttributesDocumentType(struct soap *soap, struct bes__GetFactoryAttributesDocumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__GetFactoryAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetFactoryAttributesDocumentType ** SOAP_FMAC4 soap_in_PointerTobes__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, struct bes__GetFactoryAttributesDocumentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__GetFactoryAttributesDocumentType **)soap_malloc(soap, sizeof(struct bes__GetFactoryAttributesDocumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__GetFactoryAttributesDocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__GetFactoryAttributesDocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__GetFactoryAttributesDocumentType, sizeof(struct bes__GetFactoryAttributesDocumentType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__GetActivityDocumentsResponseType))
		soap_serialize_bes__GetActivityDocumentsResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__GetActivityDocumentsResponseType);
	if (soap_out_PointerTobes__GetActivityDocumentsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, int id, struct bes__GetActivityDocumentsResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__GetActivityDocumentsResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__GetActivityDocumentsResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType ** SOAP_FMAC4 soap_get_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, struct bes__GetActivityDocumentsResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__GetActivityDocumentsResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityDocumentsResponseType ** SOAP_FMAC4 soap_in_PointerTobes__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, struct bes__GetActivityDocumentsResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__GetActivityDocumentsResponseType **)soap_malloc(soap, sizeof(struct bes__GetActivityDocumentsResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__GetActivityDocumentsResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityDocumentsResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__GetActivityDocumentsResponseType, sizeof(struct bes__GetActivityDocumentsResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__TerminateActivitiesResponseType))
		soap_serialize_bes__TerminateActivitiesResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__TerminateActivitiesResponseType);
	if (soap_out_PointerTobes__TerminateActivitiesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, const char *tag, int id, struct bes__TerminateActivitiesResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__TerminateActivitiesResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__TerminateActivitiesResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType ** SOAP_FMAC4 soap_get_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, struct bes__TerminateActivitiesResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__TerminateActivitiesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivitiesResponseType ** SOAP_FMAC4 soap_in_PointerTobes__TerminateActivitiesResponseType(struct soap *soap, const char *tag, struct bes__TerminateActivitiesResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__TerminateActivitiesResponseType **)soap_malloc(soap, sizeof(struct bes__TerminateActivitiesResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__TerminateActivitiesResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__TerminateActivitiesResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__TerminateActivitiesResponseType, sizeof(struct bes__TerminateActivitiesResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__GetActivityStatusesResponseType))
		soap_serialize_bes__GetActivityStatusesResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__GetActivityStatusesResponseType);
	if (soap_out_PointerTobes__GetActivityStatusesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, const char *tag, int id, struct bes__GetActivityStatusesResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__GetActivityStatusesResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__GetActivityStatusesResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType ** SOAP_FMAC4 soap_get_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, struct bes__GetActivityStatusesResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__GetActivityStatusesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__GetActivityStatusesResponseType ** SOAP_FMAC4 soap_in_PointerTobes__GetActivityStatusesResponseType(struct soap *soap, const char *tag, struct bes__GetActivityStatusesResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__GetActivityStatusesResponseType **)soap_malloc(soap, sizeof(struct bes__GetActivityStatusesResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__GetActivityStatusesResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__GetActivityStatusesResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__GetActivityStatusesResponseType, sizeof(struct bes__GetActivityStatusesResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__CreateActivityResponseType))
		soap_serialize_bes__CreateActivityResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__CreateActivityResponseType);
	if (soap_out_PointerTobes__CreateActivityResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__CreateActivityResponseType(struct soap *soap, const char *tag, int id, struct bes__CreateActivityResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__CreateActivityResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__CreateActivityResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__CreateActivityResponseType ** SOAP_FMAC4 soap_get_PointerTobes__CreateActivityResponseType(struct soap *soap, struct bes__CreateActivityResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__CreateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityResponseType ** SOAP_FMAC4 soap_in_PointerTobes__CreateActivityResponseType(struct soap *soap, const char *tag, struct bes__CreateActivityResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__CreateActivityResponseType **)soap_malloc(soap, sizeof(struct bes__CreateActivityResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__CreateActivityResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__CreateActivityResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__CreateActivityResponseType, sizeof(struct bes__CreateActivityResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__CreateActivityType))
		soap_serialize_bes__CreateActivityType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__CreateActivityType);
	if (soap_out_PointerTobes__CreateActivityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__CreateActivityType(struct soap *soap, const char *tag, int id, struct bes__CreateActivityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__CreateActivityType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__CreateActivityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__CreateActivityType ** SOAP_FMAC4 soap_get_PointerTobes__CreateActivityType(struct soap *soap, struct bes__CreateActivityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__CreateActivityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__CreateActivityType ** SOAP_FMAC4 soap_in_PointerTobes__CreateActivityType(struct soap *soap, const char *tag, struct bes__CreateActivityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__CreateActivityType **)soap_malloc(soap, sizeof(struct bes__CreateActivityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__CreateActivityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__CreateActivityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__CreateActivityType, sizeof(struct bes__CreateActivityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__UnsupportedFeatureFaultType))
		soap_serialize_bes__UnsupportedFeatureFaultType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__UnsupportedFeatureFaultType);
	if (soap_out_PointerTobes__UnsupportedFeatureFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, int id, struct bes__UnsupportedFeatureFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__UnsupportedFeatureFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__UnsupportedFeatureFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType ** SOAP_FMAC4 soap_get_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, struct bes__UnsupportedFeatureFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__UnsupportedFeatureFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__UnsupportedFeatureFaultType ** SOAP_FMAC4 soap_in_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, struct bes__UnsupportedFeatureFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__UnsupportedFeatureFaultType **)soap_malloc(soap, sizeof(struct bes__UnsupportedFeatureFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__UnsupportedFeatureFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__UnsupportedFeatureFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__UnsupportedFeatureFaultType, sizeof(struct bes__UnsupportedFeatureFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__NotAuthorizedFaultType))
		soap_serialize_bes__NotAuthorizedFaultType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__NotAuthorizedFaultType);
	if (soap_out_PointerTobes__NotAuthorizedFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__NotAuthorizedFaultType(struct soap *soap, const char *tag, int id, struct bes__NotAuthorizedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__NotAuthorizedFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__NotAuthorizedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType ** SOAP_FMAC4 soap_get_PointerTobes__NotAuthorizedFaultType(struct soap *soap, struct bes__NotAuthorizedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__NotAuthorizedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAuthorizedFaultType ** SOAP_FMAC4 soap_in_PointerTobes__NotAuthorizedFaultType(struct soap *soap, const char *tag, struct bes__NotAuthorizedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__NotAuthorizedFaultType **)soap_malloc(soap, sizeof(struct bes__NotAuthorizedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__NotAuthorizedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__NotAuthorizedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__NotAuthorizedFaultType, sizeof(struct bes__NotAuthorizedFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType))
		soap_serialize_bes__NotAcceptingNewActivitiesFaultType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__NotAcceptingNewActivitiesFaultType);
	if (soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, int id, struct bes__NotAcceptingNewActivitiesFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__NotAcceptingNewActivitiesFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType ** SOAP_FMAC4 soap_get_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, struct bes__NotAcceptingNewActivitiesFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__NotAcceptingNewActivitiesFaultType ** SOAP_FMAC4 soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, struct bes__NotAcceptingNewActivitiesFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__NotAcceptingNewActivitiesFaultType **)soap_malloc(soap, sizeof(struct bes__NotAcceptingNewActivitiesFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__NotAcceptingNewActivitiesFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__NotAcceptingNewActivitiesFaultType, sizeof(struct bes__NotAcceptingNewActivitiesFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__InvalidRequestMessageFaultType))
		soap_serialize_bes__InvalidRequestMessageFaultType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__InvalidRequestMessageFaultType);
	if (soap_out_PointerTobes__InvalidRequestMessageFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, const char *tag, int id, struct bes__InvalidRequestMessageFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__InvalidRequestMessageFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__InvalidRequestMessageFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType ** SOAP_FMAC4 soap_get_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, struct bes__InvalidRequestMessageFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__InvalidRequestMessageFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__InvalidRequestMessageFaultType ** SOAP_FMAC4 soap_in_PointerTobes__InvalidRequestMessageFaultType(struct soap *soap, const char *tag, struct bes__InvalidRequestMessageFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__InvalidRequestMessageFaultType **)soap_malloc(soap, sizeof(struct bes__InvalidRequestMessageFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__InvalidRequestMessageFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__InvalidRequestMessageFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__InvalidRequestMessageFaultType, sizeof(struct bes__InvalidRequestMessageFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__FaultTo))
		soap_serialize__wsa__FaultTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__FaultTo);
	if (soap_out_PointerTo_wsa__FaultTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__ReplyTo))
		soap_serialize__wsa__ReplyTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__ReplyTo);
	if (soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__From))
		soap_serialize__wsa__From(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__From);
	if (soap_out_PointerTo_wsa__From(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__From(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__RelatesTo))
		soap_serialize__wsa__RelatesTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__RelatesTo);
	if (soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__RelatesToType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__RelatesToType **)soap_malloc(soap, sizeof(struct wsa__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__RelatesToType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__URI(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__URI(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__URI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__URI);
	if (soap_out__jsdl__URI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__URI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__URI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__URI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__URI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__URI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__URI, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__FilesystemName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__FilesystemName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__FilesystemName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__FilesystemName);
	if (soap_out__jsdl__FilesystemName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__FilesystemName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__FilesystemName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__FilesystemName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__FilesystemName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__FilesystemName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__FilesystemName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__FileName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__FileName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__FileName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__FileName);
	if (soap_out__jsdl__FileName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__FileName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__FileName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__FileName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__FileName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__FileName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__FileName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__MountPoint(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__MountPoint(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__MountPoint(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__MountPoint);
	if (soap_out__jsdl__MountPoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__MountPoint(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__MountPoint);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__MountPoint(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__MountPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__MountPoint(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__MountPoint, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__OperatingSystemVersion(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__OperatingSystemVersion(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__OperatingSystemVersion(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__OperatingSystemVersion);
	if (soap_out__jsdl__OperatingSystemVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__OperatingSystemVersion(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__OperatingSystemVersion);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__OperatingSystemVersion(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__OperatingSystemVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__OperatingSystemVersion(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__OperatingSystemVersion, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__HostName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__HostName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__HostName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__HostName);
	if (soap_out__jsdl__HostName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__HostName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__HostName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__HostName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__HostName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__HostName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__HostName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__ApplicationVersion(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__ApplicationVersion(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__ApplicationVersion(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__ApplicationVersion);
	if (soap_out__jsdl__ApplicationVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__ApplicationVersion(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__ApplicationVersion);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__ApplicationVersion(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__ApplicationVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__ApplicationVersion(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__ApplicationVersion, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__ApplicationName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__ApplicationName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__ApplicationName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__ApplicationName);
	if (soap_out__jsdl__ApplicationName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__ApplicationName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__ApplicationName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__ApplicationName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__ApplicationName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__ApplicationName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__ApplicationName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__JobProject(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__JobProject(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__JobProject(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobProject);
	if (soap_out__jsdl__JobProject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__JobProject(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__JobProject);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__JobProject(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__JobProject(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__JobProject, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__JobAnnotation(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__JobAnnotation(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__JobAnnotation(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobAnnotation);
	if (soap_out__jsdl__JobAnnotation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__JobAnnotation(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__JobAnnotation);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__JobAnnotation(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__JobAnnotation(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__JobAnnotation, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__Description(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__Description(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__Description(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__Description);
	if (soap_out__jsdl__Description(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__Description(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__Description);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__Description(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__Description(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__Description, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__jsdl__JobName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__jsdl__JobName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__jsdl__JobName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__jsdl__JobName);
	if (soap_out__jsdl__JobName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__jsdl__JobName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__jsdl__JobName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__jsdl__JobName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__jsdl__JobName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__jsdl__JobName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__jsdl__JobName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToposix__GroupName_USCOREType(struct soap *soap, struct posix__GroupName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_posix__GroupName_USCOREType))
		soap_serialize_posix__GroupName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToposix__GroupName_USCOREType(struct soap *soap, struct posix__GroupName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToposix__GroupName_USCOREType);
	if (soap_out_PointerToposix__GroupName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToposix__GroupName_USCOREType(struct soap *soap, const char *tag, int id, struct posix__GroupName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_posix__GroupName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_posix__GroupName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct posix__GroupName_USCOREType ** SOAP_FMAC4 soap_get_PointerToposix__GroupName_USCOREType(struct soap *soap, struct posix__GroupName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToposix__GroupName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__GroupName_USCOREType ** SOAP_FMAC4 soap_in_PointerToposix__GroupName_USCOREType(struct soap *soap, const char *tag, struct posix__GroupName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct posix__GroupName_USCOREType **)soap_malloc(soap, sizeof(struct posix__GroupName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_posix__GroupName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct posix__GroupName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_posix__GroupName_USCOREType, sizeof(struct posix__GroupName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToposix__UserName_USCOREType(struct soap *soap, struct posix__UserName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_posix__UserName_USCOREType))
		soap_serialize_posix__UserName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToposix__UserName_USCOREType(struct soap *soap, struct posix__UserName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToposix__UserName_USCOREType);
	if (soap_out_PointerToposix__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToposix__UserName_USCOREType(struct soap *soap, const char *tag, int id, struct posix__UserName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_posix__UserName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_posix__UserName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct posix__UserName_USCOREType ** SOAP_FMAC4 soap_get_PointerToposix__UserName_USCOREType(struct soap *soap, struct posix__UserName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToposix__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__UserName_USCOREType ** SOAP_FMAC4 soap_in_PointerToposix__UserName_USCOREType(struct soap *soap, const char *tag, struct posix__UserName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct posix__UserName_USCOREType **)soap_malloc(soap, sizeof(struct posix__UserName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_posix__UserName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct posix__UserName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_posix__UserName_USCOREType, sizeof(struct posix__UserName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToposix__Limits_USCOREType(struct soap *soap, struct posix__Limits_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_posix__Limits_USCOREType))
		soap_serialize_posix__Limits_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToposix__Limits_USCOREType(struct soap *soap, struct posix__Limits_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToposix__Limits_USCOREType);
	if (soap_out_PointerToposix__Limits_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToposix__Limits_USCOREType(struct soap *soap, const char *tag, int id, struct posix__Limits_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_posix__Limits_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_posix__Limits_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct posix__Limits_USCOREType ** SOAP_FMAC4 soap_get_PointerToposix__Limits_USCOREType(struct soap *soap, struct posix__Limits_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToposix__Limits_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Limits_USCOREType ** SOAP_FMAC4 soap_in_PointerToposix__Limits_USCOREType(struct soap *soap, const char *tag, struct posix__Limits_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct posix__Limits_USCOREType **)soap_malloc(soap, sizeof(struct posix__Limits_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_posix__Limits_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct posix__Limits_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_posix__Limits_USCOREType, sizeof(struct posix__Limits_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToposix__Environment_USCOREType(struct soap *soap, struct posix__Environment_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_posix__Environment_USCOREType))
		soap_serialize_posix__Environment_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToposix__Environment_USCOREType(struct soap *soap, struct posix__Environment_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToposix__Environment_USCOREType);
	if (soap_out_PointerToposix__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToposix__Environment_USCOREType(struct soap *soap, const char *tag, int id, struct posix__Environment_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_posix__Environment_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_posix__Environment_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct posix__Environment_USCOREType ** SOAP_FMAC4 soap_get_PointerToposix__Environment_USCOREType(struct soap *soap, struct posix__Environment_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToposix__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Environment_USCOREType ** SOAP_FMAC4 soap_in_PointerToposix__Environment_USCOREType(struct soap *soap, const char *tag, struct posix__Environment_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct posix__Environment_USCOREType **)soap_malloc(soap, sizeof(struct posix__Environment_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_posix__Environment_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct posix__Environment_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_posix__Environment_USCOREType, sizeof(struct posix__Environment_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToposix__DirectoryName_USCOREType(struct soap *soap, struct posix__DirectoryName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_posix__DirectoryName_USCOREType))
		soap_serialize_posix__DirectoryName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToposix__DirectoryName_USCOREType(struct soap *soap, struct posix__DirectoryName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToposix__DirectoryName_USCOREType);
	if (soap_out_PointerToposix__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, struct posix__DirectoryName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_posix__DirectoryName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_posix__DirectoryName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct posix__DirectoryName_USCOREType ** SOAP_FMAC4 soap_get_PointerToposix__DirectoryName_USCOREType(struct soap *soap, struct posix__DirectoryName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToposix__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__DirectoryName_USCOREType ** SOAP_FMAC4 soap_in_PointerToposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, struct posix__DirectoryName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct posix__DirectoryName_USCOREType **)soap_malloc(soap, sizeof(struct posix__DirectoryName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_posix__DirectoryName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct posix__DirectoryName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_posix__DirectoryName_USCOREType, sizeof(struct posix__DirectoryName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToposix__Argument_USCOREType(struct soap *soap, struct posix__Argument_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_posix__Argument_USCOREType))
		soap_serialize_posix__Argument_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToposix__Argument_USCOREType(struct soap *soap, struct posix__Argument_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToposix__Argument_USCOREType);
	if (soap_out_PointerToposix__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToposix__Argument_USCOREType(struct soap *soap, const char *tag, int id, struct posix__Argument_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_posix__Argument_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_posix__Argument_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct posix__Argument_USCOREType ** SOAP_FMAC4 soap_get_PointerToposix__Argument_USCOREType(struct soap *soap, struct posix__Argument_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToposix__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__Argument_USCOREType ** SOAP_FMAC4 soap_in_PointerToposix__Argument_USCOREType(struct soap *soap, const char *tag, struct posix__Argument_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct posix__Argument_USCOREType **)soap_malloc(soap, sizeof(struct posix__Argument_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_posix__Argument_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct posix__Argument_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_posix__Argument_USCOREType, sizeof(struct posix__Argument_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToposix__FileName_USCOREType(struct soap *soap, struct posix__FileName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_posix__FileName_USCOREType))
		soap_serialize_posix__FileName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToposix__FileName_USCOREType(struct soap *soap, struct posix__FileName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToposix__FileName_USCOREType);
	if (soap_out_PointerToposix__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToposix__FileName_USCOREType(struct soap *soap, const char *tag, int id, struct posix__FileName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_posix__FileName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_posix__FileName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct posix__FileName_USCOREType ** SOAP_FMAC4 soap_get_PointerToposix__FileName_USCOREType(struct soap *soap, struct posix__FileName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToposix__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct posix__FileName_USCOREType ** SOAP_FMAC4 soap_in_PointerToposix__FileName_USCOREType(struct soap *soap, const char *tag, struct posix__FileName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct posix__FileName_USCOREType **)soap_malloc(soap, sizeof(struct posix__FileName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_posix__FileName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct posix__FileName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_posix__FileName_USCOREType, sizeof(struct posix__FileName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__UserName_USCOREType(struct soap *soap, struct app__UserName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_app__UserName_USCOREType))
		soap_serialize_app__UserName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__UserName_USCOREType(struct soap *soap, struct app__UserName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__UserName_USCOREType);
	if (soap_out_PointerToapp__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapp__UserName_USCOREType(struct soap *soap, const char *tag, int id, struct app__UserName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__UserName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_app__UserName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct app__UserName_USCOREType ** SOAP_FMAC4 soap_get_PointerToapp__UserName_USCOREType(struct soap *soap, struct app__UserName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapp__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__UserName_USCOREType ** SOAP_FMAC4 soap_in_PointerToapp__UserName_USCOREType(struct soap *soap, const char *tag, struct app__UserName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct app__UserName_USCOREType **)soap_malloc(soap, sizeof(struct app__UserName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_app__UserName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct app__UserName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__UserName_USCOREType, sizeof(struct app__UserName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__Environment_USCOREType(struct soap *soap, struct app__Environment_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_app__Environment_USCOREType))
		soap_serialize_app__Environment_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__Environment_USCOREType(struct soap *soap, struct app__Environment_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__Environment_USCOREType);
	if (soap_out_PointerToapp__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapp__Environment_USCOREType(struct soap *soap, const char *tag, int id, struct app__Environment_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__Environment_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_app__Environment_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct app__Environment_USCOREType ** SOAP_FMAC4 soap_get_PointerToapp__Environment_USCOREType(struct soap *soap, struct app__Environment_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapp__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__Environment_USCOREType ** SOAP_FMAC4 soap_in_PointerToapp__Environment_USCOREType(struct soap *soap, const char *tag, struct app__Environment_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct app__Environment_USCOREType **)soap_malloc(soap, sizeof(struct app__Environment_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_app__Environment_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct app__Environment_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__Environment_USCOREType, sizeof(struct app__Environment_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__DirectoryName_USCOREType(struct soap *soap, struct app__DirectoryName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_app__DirectoryName_USCOREType))
		soap_serialize_app__DirectoryName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__DirectoryName_USCOREType(struct soap *soap, struct app__DirectoryName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__DirectoryName_USCOREType);
	if (soap_out_PointerToapp__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapp__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, struct app__DirectoryName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__DirectoryName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_app__DirectoryName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct app__DirectoryName_USCOREType ** SOAP_FMAC4 soap_get_PointerToapp__DirectoryName_USCOREType(struct soap *soap, struct app__DirectoryName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapp__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__DirectoryName_USCOREType ** SOAP_FMAC4 soap_in_PointerToapp__DirectoryName_USCOREType(struct soap *soap, const char *tag, struct app__DirectoryName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct app__DirectoryName_USCOREType **)soap_malloc(soap, sizeof(struct app__DirectoryName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_app__DirectoryName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct app__DirectoryName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__DirectoryName_USCOREType, sizeof(struct app__DirectoryName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__Argument_USCOREType(struct soap *soap, struct app__Argument_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_app__Argument_USCOREType))
		soap_serialize_app__Argument_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__Argument_USCOREType(struct soap *soap, struct app__Argument_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__Argument_USCOREType);
	if (soap_out_PointerToapp__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapp__Argument_USCOREType(struct soap *soap, const char *tag, int id, struct app__Argument_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__Argument_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_app__Argument_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct app__Argument_USCOREType ** SOAP_FMAC4 soap_get_PointerToapp__Argument_USCOREType(struct soap *soap, struct app__Argument_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapp__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__Argument_USCOREType ** SOAP_FMAC4 soap_in_PointerToapp__Argument_USCOREType(struct soap *soap, const char *tag, struct app__Argument_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct app__Argument_USCOREType **)soap_malloc(soap, sizeof(struct app__Argument_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_app__Argument_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct app__Argument_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__Argument_USCOREType, sizeof(struct app__Argument_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToapp__FileName_USCOREType(struct soap *soap, struct app__FileName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_app__FileName_USCOREType))
		soap_serialize_app__FileName_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToapp__FileName_USCOREType(struct soap *soap, struct app__FileName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToapp__FileName_USCOREType);
	if (soap_out_PointerToapp__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToapp__FileName_USCOREType(struct soap *soap, const char *tag, int id, struct app__FileName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_app__FileName_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_app__FileName_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct app__FileName_USCOREType ** SOAP_FMAC4 soap_get_PointerToapp__FileName_USCOREType(struct soap *soap, struct app__FileName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToapp__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct app__FileName_USCOREType ** SOAP_FMAC4 soap_in_PointerToapp__FileName_USCOREType(struct soap *soap, const char *tag, struct app__FileName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct app__FileName_USCOREType **)soap_malloc(soap, sizeof(struct app__FileName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_app__FileName_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct app__FileName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_app__FileName_USCOREType, sizeof(struct app__FileName_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__SourceTarget_USCOREType))
		soap_serialize_jsdl__SourceTarget_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType);
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__SourceTarget_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__SourceTarget_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, struct jsdl__SourceTarget_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, struct jsdl__SourceTarget_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__SourceTarget_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__SourceTarget_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__SourceTarget_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__SourceTarget_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__SourceTarget_USCOREType, sizeof(struct jsdl__SourceTarget_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType))
		soap_serialize_jsdl__OperatingSystemType_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__OperatingSystemType_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, struct jsdl__OperatingSystemType_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, struct jsdl__OperatingSystemType_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__OperatingSystemType_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__OperatingSystemType_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__OperatingSystemType_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, sizeof(struct jsdl__OperatingSystemType_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration);
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, enum jsdl__FileSystemTypeEnumeration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum jsdl__FileSystemTypeEnumeration **)soap_malloc(soap, sizeof(enum jsdl__FileSystemTypeEnumeration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__RangeValue_USCOREType))
		soap_serialize_jsdl__RangeValue_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType);
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__RangeValue_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__RangeValue_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, struct jsdl__RangeValue_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, struct jsdl__RangeValue_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__RangeValue_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__RangeValue_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__RangeValue_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__RangeValue_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__RangeValue_USCOREType, sizeof(struct jsdl__RangeValue_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__FileSystem_USCOREType))
		soap_serialize_jsdl__FileSystem_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType);
	if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__FileSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__FileSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, struct jsdl__FileSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, struct jsdl__FileSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__FileSystem_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__FileSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__FileSystem_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__FileSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__FileSystem_USCOREType, sizeof(struct jsdl__FileSystem_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType))
		soap_serialize_jsdl__CandidateHosts_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType);
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__CandidateHosts_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__CandidateHosts_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, struct jsdl__CandidateHosts_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, struct jsdl__CandidateHosts_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__CandidateHosts_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__CandidateHosts_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__CandidateHosts_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, sizeof(struct jsdl__CandidateHosts_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__DataStaging_USCOREType))
		soap_serialize_jsdl__DataStaging_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType);
	if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__DataStaging_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__DataStaging_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, struct jsdl__DataStaging_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, struct jsdl__DataStaging_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__DataStaging_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__DataStaging_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__DataStaging_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__DataStaging_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__DataStaging_USCOREType, sizeof(struct jsdl__DataStaging_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Resources_USCOREType))
		soap_serialize_jsdl__Resources_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Resources_USCOREType);
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Resources_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Resources_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Resources_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Resources_USCOREType(struct soap *soap, struct jsdl__Resources_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, struct jsdl__Resources_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Resources_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Resources_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__Resources_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__Resources_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Resources_USCOREType, sizeof(struct jsdl__Resources_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Application_USCOREType))
		soap_serialize_jsdl__Application_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Application_USCOREType);
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Application_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Application_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Application_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Application_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Application_USCOREType(struct soap *soap, struct jsdl__Application_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Application_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, struct jsdl__Application_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Application_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Application_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__Application_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__Application_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Application_USCOREType, sizeof(struct jsdl__Application_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobIdentification_USCOREType))
		soap_serialize_jsdl__JobIdentification_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType);
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__JobIdentification_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobIdentification_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, struct jsdl__JobIdentification_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobIdentification_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__JobIdentification_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__JobIdentification_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__JobIdentification_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__JobIdentification_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobIdentification_USCOREType, sizeof(struct jsdl__JobIdentification_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobDescription_USCOREType))
		soap_serialize_jsdl__JobDescription_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType);
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__JobDescription_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobDescription_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, struct jsdl__JobDescription_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobDescription_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__JobDescription_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__JobDescription_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__JobDescription_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__JobDescription_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobDescription_USCOREType, sizeof(struct jsdl__JobDescription_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Range_USCOREType))
		soap_serialize_jsdl__Range_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Range_USCOREType);
	if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Range_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Range_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Range_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Range_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Range_USCOREType(struct soap *soap, struct jsdl__Range_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Range_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, struct jsdl__Range_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Range_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Range_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__Range_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__Range_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Range_USCOREType, sizeof(struct jsdl__Range_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Exact_USCOREType))
		soap_serialize_jsdl__Exact_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Exact_USCOREType);
	if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Exact_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Exact_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Exact_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Exact_USCOREType(struct soap *soap, struct jsdl__Exact_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, struct jsdl__Exact_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Exact_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Exact_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__Exact_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__Exact_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Exact_USCOREType, sizeof(struct jsdl__Exact_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Boundary_USCOREType))
		soap_serialize_jsdl__Boundary_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Boundary_USCOREType);
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__Boundary_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Boundary_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Boundary_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Boundary_USCOREType(struct soap *soap, struct jsdl__Boundary_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, struct jsdl__Boundary_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__Boundary_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__Boundary_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__Boundary_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__Boundary_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Boundary_USCOREType, sizeof(struct jsdl__Boundary_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__MetadataType(struct soap *soap, struct wsa__MetadataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__MetadataType))
		soap_serialize_wsa__MetadataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__MetadataType(struct soap *soap, struct wsa__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__MetadataType);
	if (soap_out_PointerTowsa__MetadataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__MetadataType(struct soap *soap, const char *tag, int id, struct wsa__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__MetadataType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa__MetadataType(struct soap *soap, struct wsa__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa__MetadataType(struct soap *soap, const char *tag, struct wsa__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__MetadataType **)soap_malloc(soap, sizeof(struct wsa__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__MetadataType, sizeof(struct wsa__MetadataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferenceParametersType))
		soap_serialize_wsa__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ReferenceParametersType);
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__AttributedURIType))
		soap_serialize_wsa__AttributedURIType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__AttributedURIType);
	if (soap_out_PointerTowsa__AttributedURIType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__AttributedURIType(struct soap *soap, const char *tag, int id, struct wsa__AttributedURIType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__AttributedURIType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__AttributedURIType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__AttributedURIType ** SOAP_FMAC4 soap_get_PointerTowsa__AttributedURIType(struct soap *soap, struct wsa__AttributedURIType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__AttributedURIType ** SOAP_FMAC4 soap_in_PointerTowsa__AttributedURIType(struct soap *soap, const char *tag, struct wsa__AttributedURIType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__AttributedURIType **)soap_malloc(soap, sizeof(struct wsa__AttributedURIType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__AttributedURIType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__AttributedURIType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__AttributedURIType, sizeof(struct wsa__AttributedURIType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobDefinition_USCOREType))
		soap_serialize_jsdl__JobDefinition_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType);
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__JobDefinition_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobDefinition_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, struct jsdl__JobDefinition_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, struct jsdl__JobDefinition_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__JobDefinition_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__JobDefinition_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__JobDefinition_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__JobDefinition_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobDefinition_USCOREType, sizeof(struct jsdl__JobDefinition_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__EndpointReferenceType))
		soap_serialize_wsa__EndpointReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__EndpointReferenceType);
	if (soap_out_PointerTowsa__EndpointReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__BasicResourceAttributesDocumentType))
		soap_serialize_bes__BasicResourceAttributesDocumentType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__BasicResourceAttributesDocumentType);
	if (soap_out_PointerTobes__BasicResourceAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, const char *tag, int id, struct bes__BasicResourceAttributesDocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__BasicResourceAttributesDocumentType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__BasicResourceAttributesDocumentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType ** SOAP_FMAC4 soap_get_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, struct bes__BasicResourceAttributesDocumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__BasicResourceAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__BasicResourceAttributesDocumentType ** SOAP_FMAC4 soap_in_PointerTobes__BasicResourceAttributesDocumentType(struct soap *soap, const char *tag, struct bes__BasicResourceAttributesDocumentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__BasicResourceAttributesDocumentType **)soap_malloc(soap, sizeof(struct bes__BasicResourceAttributesDocumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__BasicResourceAttributesDocumentType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__BasicResourceAttributesDocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__BasicResourceAttributesDocumentType, sizeof(struct bes__BasicResourceAttributesDocumentType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType))
		soap_serialize_jsdl__CPUArchitecture_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType);
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__CPUArchitecture_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, struct jsdl__CPUArchitecture_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, struct jsdl__CPUArchitecture_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__CPUArchitecture_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__CPUArchitecture_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__CPUArchitecture_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, sizeof(struct jsdl__CPUArchitecture_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType))
		soap_serialize_jsdl__OperatingSystem_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, struct jsdl__OperatingSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__OperatingSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, struct jsdl__OperatingSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, struct jsdl__OperatingSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct jsdl__OperatingSystem_USCOREType **)soap_malloc(soap, sizeof(struct jsdl__OperatingSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct jsdl__OperatingSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, sizeof(struct jsdl__OperatingSystem_USCOREType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__ActivityStatusType))
		soap_serialize_bes__ActivityStatusType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__ActivityStatusType);
	if (soap_out_PointerTobes__ActivityStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__ActivityStatusType(struct soap *soap, const char *tag, int id, struct bes__ActivityStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__ActivityStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__ActivityStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__ActivityStatusType ** SOAP_FMAC4 soap_get_PointerTobes__ActivityStatusType(struct soap *soap, struct bes__ActivityStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__ActivityStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__ActivityStatusType ** SOAP_FMAC4 soap_in_PointerTobes__ActivityStatusType(struct soap *soap, const char *tag, struct bes__ActivityStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__ActivityStatusType **)soap_malloc(soap, sizeof(struct bes__ActivityStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__ActivityStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__ActivityStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__ActivityStatusType, sizeof(struct bes__ActivityStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__TerminateActivityResponseType(struct soap *soap, struct bes__TerminateActivityResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__TerminateActivityResponseType))
		soap_serialize_bes__TerminateActivityResponseType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__TerminateActivityResponseType(struct soap *soap, struct bes__TerminateActivityResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobes__TerminateActivityResponseType);
	if (soap_out_PointerTobes__TerminateActivityResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__TerminateActivityResponseType(struct soap *soap, const char *tag, int id, struct bes__TerminateActivityResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__TerminateActivityResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_bes__TerminateActivityResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bes__TerminateActivityResponseType ** SOAP_FMAC4 soap_get_PointerTobes__TerminateActivityResponseType(struct soap *soap, struct bes__TerminateActivityResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__TerminateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bes__TerminateActivityResponseType ** SOAP_FMAC4 soap_in_PointerTobes__TerminateActivityResponseType(struct soap *soap, const char *tag, struct bes__TerminateActivityResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bes__TerminateActivityResponseType **)soap_malloc(soap, sizeof(struct bes__TerminateActivityResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__TerminateActivityResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bes__TerminateActivityResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__TerminateActivityResponseType, sizeof(struct bes__TerminateActivityResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__Description_USCOREType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__Description_USCOREType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Description_USCOREType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Description_USCOREType);
	if (soap_out_jsdl__Description_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_jsdl__Description_USCOREType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_jsdl__Description_USCOREType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_jsdl__Description_USCOREType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_jsdl__Description_USCOREType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__FaultCodesOpenEnumType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__FaultCodesOpenEnumType);
	if (soap_out_wsa__FaultCodesOpenEnumType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wsa__FaultCodesOpenEnumType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__RelationshipTypeOpenEnum(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__RelationshipTypeOpenEnum);
	if (soap_out_wsa__RelationshipTypeOpenEnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_wsa__RelationshipTypeOpenEnum, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, struct soap_dom_element *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		soap_serialize_xsd__anyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, struct soap_dom_element *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, struct soap_dom_element *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct soap_dom_element ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, struct soap_dom_element **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct soap_dom_element ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, struct soap_dom_element **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct soap_dom_element **)soap_malloc(soap, sizeof(struct soap_dom_element *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct soap_dom_element **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(struct soap_dom_element), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__normalizedString(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__normalizedString(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__normalizedString(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__normalizedString);
	if (soap_out_xsd__normalizedString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__normalizedString(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__normalizedString);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__normalizedString(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__normalizedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__normalizedString(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__normalizedString, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__nonNegativeInteger(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__NCName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	if (soap_out_xsd__NCName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__ID(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	if (soap_out_xsd__ID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__ID);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__ID, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
	if (soap_out_PointerTods__TransformType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

#ifdef __cplusplus
}
#endif

/* End of soapC.c */
